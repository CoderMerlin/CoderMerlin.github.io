<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>玩转 IDEA 系列教程——强烈推荐官方中文(汉化)插件！</title>
      <link href="/2020/06/04/idea/idea01/"/>
      <url>/2020/06/04/idea/idea01/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7326374-6ced95eb61b5c7f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="玩转 IDEA 系列教程"></p><blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人博客网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p>IDEA2020.1版本的到来，官方也悄悄更新了IDEA的中文插件。至今为止也有一段时间了，本人也下载使用过，对于英语底子薄弱的同学来说，中文插件还是非常友好的！</p><p>有兴趣的童鞋也可以下载尝尝鲜~</p><p>接下来，我们来介绍如何安装这款插件！</p><h3 id="一、在线安装"><a href="#一、在线安装" class="headerlink" title="一、在线安装"></a>一、在线安装</h3><p>打开设置——&gt;插件  </p><p>输入框<strong>搜索</strong>：<code>Chinese (Simplified) Language Pack</code></p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-83502d2553bef53b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="settings"></p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-865b2992d6e8bf3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="搜索安装"></p><p>之后重启即可使用！</p><h3 id="二、离线安装"><a href="#二、离线安装" class="headerlink" title="二、离线安装"></a>二、离线安装</h3><p>离线下载地址：<a href="https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack-eap" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack-eap</a></p><blockquote><p>注意事项：需要根据自身的IDEA版本号进行相应的选择下载！</p></blockquote><h4 id="下载离线包"><a href="#下载离线包" class="headerlink" title="下载离线包"></a>下载离线包</h4><p><img src="https://upload-images.jianshu.io/upload_images/7326374-2e619f00d788d070.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载地址"></p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-d931e1f8b8cb89a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看对应的版本号"></p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-5f306ae6f01494f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build.png"></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><blockquote><p>安装离线包有两张方法</p></blockquote><p>方式一：</p><p>File -&gt; Settings -&gt; Plugins -&gt; 安装本地插件包</p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-5e6b0d36aaae4838.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地安装"></p><p>方式二：</p><p>直接将插件包托入到IDEA框内即可！</p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-964e7ab9ae57523c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="离线安装方式2"></p><p>之后重启即可使用！</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://upload-images.jianshu.io/upload_images/7326374-77788a7f9f4174f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装完成"></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><p>文章收录至<br>Github: <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCoderMerlin%2Fcoder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2F573059382%2Fcoder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~</p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-0c9d0fbd2c954edb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建-博客搭建完整教程</title>
      <link href="/2020/05/14/BLOG03-HEXO-JC/"/>
      <url>/2020/05/14/BLOG03-HEXO-JC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师！</p></blockquote><blockquote><p>欢迎大家访问我的博客：<a href="https://codermerlin.github.io/" target="_blank" rel="noopener">Coder编程——个人博客</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实早在三年前，刚毕业那会就在网上学着搭建自己的个人博客。后面由于其他原因（主要是<strong>懒</strong>）就没再继续管理。如今又为何重新拾起呢？</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/emoticon/htwyakszb.jpg" alt="后退我要开始装逼啦"></p><p>第一：自己本身从毕业到工作也已经有了三年时间，或多或少有了一些工作经验和感悟。<br>第二：平时有时间的时候，自己也会看看博客，写写文章（划划水）。<br>第三：工作这么久，也要记录一下自己的学习记录，分享给大家。<br>….</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/emoticon/hlbbzdl.jpg" alt="我知道了"></p><p>下面的开始写教程了，这篇教程主要参考：</p><ul><li><a href="https://www.itrhx.com/" target="_blank" rel="noopener">https://www.itrhx.com/</a></li></ul><p>他的教程写的非常详细！本文也主要参考他写的内容，并修改~</p><p>推荐文章： <a href="http://www.cnblogs.com/jhzhu/p/3893297.html" target="_blank" rel="noopener">《我为什么写博客》</a> （By 知明所以）<br>　　　　 　<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="noopener">《为什么你应该（从现在开始就）写博客》</a> (By 刘未鹏 | Mind Hacks)</p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><h3 id="1-1-Github-Pages"><a href="#1-1-Github-Pages" class="headerlink" title="1.1 Github Pages"></a>1.1 Github Pages</h3><p><strong>Github Pages</strong>可以被认为是用户编写的、托管在github上的静态网页。使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。</p><p>类似Github Pages的</p><ul><li>Gitee Pages</li><li>Gitlab Pages</li><li>Coding</li></ul><p>等等</p><p>后续我也会写文章专门介绍，这几个Pages的搭建过程，欢迎大家关注~</p><h3 id="1-2-Hexo"><a href="#1-2-Hexo" class="headerlink" title="1.2 Hexo"></a>1.2 Hexo</h3><p><strong>Hexo</strong> 是一个快速、简洁且高效的博客框架。<strong>Hexo</strong> 使用 <strong>Markdown</strong>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="2-环境安装"><a href="#2-环境安装" class="headerlink" title="2. 环境安装"></a>2. 环境安装</h2><h3 id="2-1-安装Node-js"><a href="#2-1-安装Node-js" class="headerlink" title="2.1 安装Node.js"></a>2.1 安装Node.js</h3><p>访问<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>，按需下载相应版本，默认安装可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG01/A02.png" alt="Node"></p><p>更多详细教程：</p><ul><li><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-install-setup.html</a></li><li><a href="https://blog.csdn.net/antma/article/details/86104068" target="_blank" rel="noopener">https://blog.csdn.net/antma/article/details/86104068</a></li></ul><h3 id="2-2-安装Git"><a href="#2-2-安装Git" class="headerlink" title="2.2 安装Git"></a>2.2 安装Git</h3><p>访问<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">官网</a>，按需下载相应版本，默认安装即可。</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG01/A02-1.png" alt="Git官网"></p><p>更多详细教程：</p><ul><li>Win10安装：<a href="https://blog.csdn.net/qq_32786873/article/details/80570783" target="_blank" rel="noopener">https://blog.csdn.net/qq_32786873/article/details/80570783</a></li><li>Mac安装：<a href="https://www.jianshu.com/p/b91f848655af" target="_blank" rel="noopener">https://www.jianshu.com/p/b91f848655af</a></li></ul><h3 id="2-3-检查软件是否安装成功"><a href="#2-3-检查软件是否安装成功" class="headerlink" title="2.3 检查软件是否安装成功"></a>2.3 检查软件是否安装成功</h3><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG01/A04.png" alt="Git"><br>同时按下 Win 键和 R 键打开运行窗口,输入 cmd ，然后输入以下命令，有相应版本信息显示则安装成功，若不正确可以卸载软件重新安装，此外若安装成功，在桌面右键鼠标，可以看到菜单里多了 Git GUI Here 和 Git Bash Here两个选项，第一个是图形界面的Git操作，另一个是命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG01/A03.png" alt="检查版本"></p><p>正确输出版本号，说明安装成功了~</p><h2 id="3-Hexo安装"><a href="#3-Hexo安装" class="headerlink" title="3. Hexo安装"></a>3. Hexo安装</h2><p>正在编写。。。</p>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建-设置标签/分类/归档相关页面</title>
      <link href="/2020/05/12/BLOG02-HEXO-BQFLGD/"/>
      <url>/2020/05/12/BLOG02-HEXO-BQFLGD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近晚上有时间就忙着倒腾自己的博客网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p><p>网站还在建设当中，我会慢慢分享自己的搭建博客的过程和遇到的问题，在这里与大家一起分享！</p><h3 id="设置标签页面"><a href="#设置标签页面" class="headerlink" title="设置标签页面"></a>设置标签页面</h3><p>主题的 _config.yml 文件中，找到如下配置<code>menu_desktop</code> 或者 <code>menu_mobile</code>。(注意：填写的路径要对应上)</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BOLG03/04.png" alt="配置项"></p><p>在<code>\source\tags</code> 中新建index.md。写入以下内容即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: tag</span><br><span class="line">index: true</span><br><span class="line">title: 所有标签</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>在需要发布的文章同样注意加入tags。举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Java学习路线整理</span><br><span class="line">updated: 2020-03-19 00:34:14</span><br><span class="line">date: 2020-03-19 00:34:14</span><br><span class="line">categories: </span><br><span class="line">  - [Java]</span><br><span class="line">  - [面试]</span><br><span class="line">tags:</span><br><span class="line">  - [Java]</span><br><span class="line">  - [面试]</span><br><span class="line">  </span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>效果如图：<br><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BOLG03/02.png" alt="标签图"></p><h3 id="设置分类页面"><a href="#设置分类页面" class="headerlink" title="设置分类页面"></a>设置分类页面</h3><p>主题的 _config.yml 文件中，找到如下配置<code>menu_desktop</code> 或者 <code>menu_mobile</code>。(注意：填写的路径要对应上)</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BOLG03/04.png" alt="配置项"></p><p>在<code>\source\categories</code> 中新建index.md。写入以下内容即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: category</span><br><span class="line">title: 所有分类</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>在需要发布的文章同样注意加入tags。举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Java学习路线整理</span><br><span class="line">updated: 2020-03-19 00:34:14</span><br><span class="line">date: 2020-03-19 00:34:14</span><br><span class="line">categories: </span><br><span class="line">  - [Java]</span><br><span class="line">  - [面试]</span><br><span class="line">tags:</span><br><span class="line">  - [Java]</span><br><span class="line">  - [面试]</span><br><span class="line">  </span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>效果如图：<br><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BOLG03/01.png" alt="分类图"></p><h3 id="设置归档页面"><a href="#设置归档页面" class="headerlink" title="设置归档页面"></a>设置归档页面</h3><p><strong>归档页面不要添加任何文件！</strong><br><strong>归档页面不要添加任何文件！</strong><br><strong>归档页面不要添加任何文件！</strong><br>重要的事说三遍！</p><p>只需要在主题的 _config.yml 文件中，找到如下配置<code>menu_desktop</code> 或者 <code>menu_mobile</code>。(注意：填写的路径要对应上), 填写<code>archives/</code>即可。</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BOLG03/04.png" alt="配置项"></p><p>效果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BOLG03/03.png" alt="归档图"></p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&mid=2247484326&idx=1&sn=0f11d4a0d23ac377a83f9fba1d4a67d4&chksm=96e672b5a191fba32b18844de26ba6dc2060a8e16b184d73c6f9dd45ca0498062eaa9273d86c&token=475512204&lang=zh_CN#rd?_blank" target="_blank" rel="noopener">[博客搭建] 增加百度统计功能</a></p><p><a href="https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21" target="_blank" rel="noopener">ProcessOn是一个在线作图工具的聚合平台~</a></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/coder-programming-wechat.webp.jpg" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建-增加百度统计功能</title>
      <link href="/2020/05/12/BLOG01-HEXO-BDTJ/"/>
      <url>/2020/05/12/BLOG01-HEXO-BDTJ/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近晚上有时间就忙着倒腾自己的博客网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p><p>网站还在建设当中，我会慢慢分享自己的搭建博客的过程和遇到的问题，在这里与大家一起分享！</p><p>百度统计是百度推出的一款免费的专业网站流量分析工具，能够告诉用户访客是如何找到并浏览用户的网站，在网站上做了些什么，非常有趣，接下来我们把百度统计添加到自己博客当中</p><p>访问<a href="https://tongji.baidu.com/" target="_blank" rel="noopener">百度统计首页</a>，注册一个账号后登陆，添加你的博客网站</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG02BDTJ/01.png" alt="01"></p><p>点击<strong>增加网站</strong>,填写个人网站的信息。</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG02BDTJ/02.png" alt="02"></p><p>接着点击代码获取，复制该代码<br><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG02BDTJ/03.png" alt="03"></p><p>然后到目录<code>\themes\hexo-theme-material-x\layout\_partial\head.ejs</code>，里面粘贴你刚刚复制的代码。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (config.baidu_analytics_key) &#123; %&gt;</span><br><span class="line">    &lt;!-- ba --&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    var _hmt &#x3D; _hmt || [];</span><br><span class="line">    (function() &#123;</span><br><span class="line">      var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">      hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?&lt;%&#x3D; config.baidu_analytics_key %&gt;&quot;;</span><br><span class="line">      var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">      s.parentNode.insertBefore(hm, s);</span><br><span class="line">    &#125;)();</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>修改博客根目录下的 _config.yml 文件(注意：不是主题下的_config.yml)，将你的key填写进去：</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG02BDTJ/05.png" alt="05"></p><p>所有操作完成后可以在百度统计管理页面检查代码是否安装成功，如果代码安装正确，一般20分钟后，可以查看网站分析数据</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG02BDTJ/06.png" alt="06"></p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG02BDTJ/07.png" alt="07"></p><p>另外推荐：<a href="https://web.umeng.com/main.php?c=user&a=index" target="_blank" rel="noopener">友盟</a>，2010年4月在北京成立，安全、可靠、公正、第三方的网站流量统计分析系统</p><p>参考：<br><a href="https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/" target="_blank" rel="noopener">https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/</a></p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21" target="_blank" rel="noopener">ProcessOn是一个在线作图工具的聚合平台~</a></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/coder-programming-wechat.webp.jpg" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 百度统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习路线整理</title>
      <link href="/2020/03/19/java/"/>
      <url>/2020/03/19/java/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#java">Java</a><ul><li><a href="#基础">基础</a></li><li><a href="#并发">并发</a></li><li><a href="#jvm">JVM</a></li><li><a href="#java8-新特性">Java8 新特性</a></li><li><a href="#代码优化">代码优化</a></li></ul></li><li><a href="#网络">网络</a></li><li><a href="#操作系统">操作系统</a></li><li><a href="#数据结构">数据结构</a></li><li><a href="#算法">算法</a><ul><li><a href="#入门">入门</a></li><li><a href="#经典">经典</a></li><li><a href="#面试">面试</a></li></ul></li><li><a href="#数据库">数据库</a></li><li><a href="#系统设计">系统设计</a><ul><li><a href="#设计模式">设计模式</a></li><li><a href="#常用框架">常用框架</a><ul><li><a href="#springspringboot">Spring/SpringBoot</a></li><li><a href="#netty">Netty</a></li></ul></li><li><a href="#分布式">分布式</a></li><li><a href="#网站架构">网站架构</a></li><li><a href="#软件底层">软件底层</a></li><li><a href="#其他">其他</a></li></ul></li><li><a href="#其他-1">其他</a></li></ul><!-- /TOC --><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li><strong><a href="https://book.douban.com/subject/2000732/" target="_blank" rel="noopener">《Head First Java》</a></strong> ：  可以说是我的 Java 启蒙书籍了，特别适合新手读当然也适合我们用来温故 Java 知识点。</li><li><strong><a href="https://book.douban.com/subject/25762168/" target="_blank" rel="noopener">《Java 核心技术卷 1+卷 2》</a></strong>: 很棒的两本书，建议有点 Java 基础之后再读，介绍的还是比较深入的，非常推荐。这两本书我一般也会用来巩固知识点或者当做工具书参考，是两本适合放在自己身边的好书。</li><li><strong><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">《Java 编程思想 (第 4 版)》</a></strong>（推荐，豆瓣评分 9.1，3.2K+人评价）：大部分人称之为Java领域的圣经，但我不推荐初学者阅读，有点劝退的味道。稍微有点基础后阅读更好。</li><li><strong><a href="https://book.douban.com/subject/26259017/" target="_blank" rel="noopener">《JAVA 网络编程 第 4 版》</a></strong>：  可以系统的学习一下网络的一些概念以及网络编程在 Java 中的使用。</li><li><strong><a href="https://book.douban.com/subject/26740520/" target="_blank" rel="noopener">《Java性能权威指南》</a></strong>：O’Reilly 家族书，性能调优的入门书，我个人觉得性能调优是每个 Java 从业者必备知识，这本书的缺点就是太老了，但是这本书可以作为一个实战书，尤其是 JVM 调优！不适合初学者。前置书籍：《深入理解 Java 虚拟机》</li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li><strong><a href="https://book.douban.com/subject/30351286/" target="_blank" rel="noopener">《Java 并发编程之美》</a></strong> ：<strong>我觉得这本书还是非常适合我们用来学习 Java 多线程的。这本书的讲解非常通俗易懂，作者从并发编程基础到实战都是信手拈来。</strong> 另外，这本书的作者加多自身也会经常在网上发布各种技术文章。我觉得这本书也是加多大佬这么多年在多线程领域的沉淀所得的结果吧！他书中的内容基本都是结合代码讲解，非常有说服力！</li><li><strong><a href="https://book.douban.com/subject/26663605/" target="_blank" rel="noopener">《实战 Java 高并发程序设计》</a></strong>： 这个是我第二本要推荐的书籍，比较适合作为多线程入门/进阶书籍来看。这本书内容同样是理论结合实战，对于每个知识点的讲解也比较通俗易懂，整体结构也比较清。</li><li><strong><a href="https://github.com/RedSpider1/concurrent" target="_blank" rel="noopener">《深入浅出 Java 多线程》</a></strong>：这本书是几位大厂（如阿里）的大佬开源的，Github 地址：<a href="https://github.com/RedSpider1/concurrent" target="_blank" rel="noopener">https://github.com/RedSpider1/concurrent</a>几位作者为了写好《深入浅出 Java 多线程》这本书阅读了大量的 Java 多线程方面的书籍和博客，然后再加上他们的经验总结、Demo 实例、源码解析，最终才形成了这本书。这本书的质量也是非常过硬！给作者们点个赞！这本书有统一的排版规则和语言风格、清晰的表达方式和逻辑。并且每篇文章初稿写完后，作者们就会互相审校，合并到主分支时所有成员会再次审校，最后再通篇修订了三遍。</li><li><strong>《Java 并发编程的艺术》</strong> ：这本书不是很适合作为 Java 多线程入门书籍，需要具备一定的 JVM 基础，有些东西讲的还是挺深入的。另外，就我自己阅读这本书的感觉来说，我觉得这本书的章节规划有点杂乱，但是，具体到某个知识点又很棒！这可能也和这本书由三名作者共同编写完成有关系吧！</li><li>……</li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li><strong><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解 Java 虚拟机（第 3 版）》</a>）</strong>：必读！必读！必读！神书，建议多刷几篇。里面不光有丰富地JVM理论知识，还有JVM实战案例！必读！</li><li><strong><a href="https://book.douban.com/subject/26354292/" target="_blank" rel="noopener">《实战 JAVA 虚拟机》</a></strong>：作为入门的了解 Java 虚拟机的知识还是不错的。</li></ul><h3 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h3><ul><li><strong><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="noopener">《Java 8 实战》</a></strong>：面向 Java 8 的技能升级，包括 Lambdas、流和函数式编程特性。实战系列的一贯风格让自己快速上手应用起来。Java 8 支持的 Lambda 是精简表达在语法上提供的支持。Java 8 提供了 Stream，学习和使用可以建立流式编程的认知。</li><li><strong><a href="https://book.douban.com/subject/26556574/" target="_blank" rel="noopener">《Java 8 编程参考官方教程》</a></strong>：建议当做工具书来用！哪里不会翻哪里！</li></ul><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ul><li><strong><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构_改善既有代码的设计》</a></strong>：豆瓣 9.1 分，重构书籍的开山鼻祖。</li><li><strong><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">《Effective java 》</a></strong>：本书介绍了在 Java 编程中很多极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。这篇文章能够非常实际地帮助你写出更加清晰、健壮和高效的代码。本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。</li><li><strong><a href="https://book.douban.com/subject/5442024/" target="_blank" rel="noopener">《代码整洁之道》</a></strong>：虽然是用 Java 语言作为例子，全篇都是在阐述 Java 面向对象的思想，但是其中大部分内容其它语言也能应用到。</li><li><strong>阿里巴巴 Java 开发手册</strong> ：<a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">https://github.com/alibaba/p3c</a></li><li><strong>Google Java 编程风格指南：</strong> <a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">http://www.hawstein.com/posts/google-java-style.html</a></li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li><strong><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解 HTTP》</a></strong>： 讲漫画一样的讲 HTTP，很有意思，不会觉得枯燥，大概也涵盖也 HTTP 常见的知识点。因为篇幅问题，内容可能不太全面。不过，如果不是专门做网络方向研究的小伙伴想研究 HTTP 相关知识的话，读这本书的话应该来说就差不多了。</li><li><strong><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">《HTTP 权威指南》</a></strong>:如果要全面了解 HTTP 非此书不可！</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li><strong><a href="https://book.douban.com/subject/4889838/" target="_blank" rel="noopener">《鸟哥的 Linux 私房菜》</a></strong>：本书是最具知名度的 Linux 入门书《鸟哥的 Linux 私房菜基础学习篇》的最新版，全面而详细地介绍了 Linux 操作系统。</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><strong><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="noopener">《大话数据结构》</a></strong>：入门类型的书籍，读起来比较浅显易懂，适合没有数据结构基础或者说数据结构没学好的小伙伴用来入门数据结构。</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ul><li><strong><a href="https://book.douban.com/subject/30357170/" target="_blank" rel="noopener">《我的第一本算法书》</a> （豆瓣评分 7.1，0.2K+人评价）</strong> 一本不那么“专业”的算法书籍。和下面两本推荐的算法书籍都是比较通俗易懂，“不那么深入”的算法书籍。我个人非常推荐，配图和讲解都非常不错！</li><li><strong><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">《算法图解》</a>（豆瓣评分 8.4，1.5K+人评价）</strong> ：入门类型的书籍，读起来比较浅显易懂，非常适合没有算法基础或者说算法没学好的小伙伴用来入门。示例丰富，图文并茂，以让人容易理解的方式阐释了算法.读起来比较快，内容不枯燥！</li><li><strong><a href="https://book.douban.com/subject/25894685/" target="_blank" rel="noopener">《啊哈!算法》</a> （豆瓣评分 7.7，0.5K+人评价）</strong> ：和《算法图解》类似的算法趣味入门书籍。</li></ul><h3 id="经典"><a href="#经典" class="headerlink" title="经典"></a>经典</h3><blockquote><p>下面这些书籍都是经典中的经典，但是阅读起来难度也比较大，不做太多阐述，神书就完事了！推荐先看 《算法》，然后再选下面的书籍进行进一步阅读。不需要都看，找一本好好看或者找某本书的某一个章节知识点好好看。</p></blockquote><ul><li><strong><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">《算法 第四版》</a>（豆瓣评分 9.3，0.4K+人评价）：</strong> 我在大二的时候被我们的一个老师强烈安利过！自己也在当时购买了一本放在宿舍，到离开大学的时候自己大概看了一半多一点。因为内容实在太多了！另外，这本书还提供了详细的Java代码，非常适合学习 Java 的朋友来看，可以说是 Java 程序员的必备书籍之一了。再来介绍一下这本书籍吧！这本书籍算的上是算法领域经典的参考书，全面介绍了关于算法和数据结构的必备知识，并特别针对排序、搜索、图处理和字符串处理进行了论述。</li><li><strong><a href="https://book.douban.com/subject/3227098/" target="_blank" rel="noopener">编程珠玑</a>（豆瓣评分 9.1，2K+人评价）</strong> ：经典名著，被无数读者强烈推荐的书籍，几乎是顶级程序员必看的书籍之一了。这本书的作者也非常厉害，Java之父 James Gosling 就是他的学生。很多人都说这本书不是教你具体的算法，而是教你一种编程的思考方式。这种思考方式不仅仅在编程领域适用，在其他同样适用。</li><li><strong><a href="https://book.douban.com/subject/4048566/" target="_blank" rel="noopener">《算法设计手册》</a>（豆瓣评分9.1 ， 45人评价）</strong> :被 <a href="https://teachyourselfcs.com/" target="_blank" rel="noopener">Teach Yourself Computer Science</a> 强烈推荐的一本算法书籍。</li><li><strong><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">《算法导论》</a> （豆瓣评分 9.2，0.4K+人评价）</strong></li><li><strong><a href="https://book.douban.com/subject/1130500/" target="_blank" rel="noopener">《计算机程序设计艺术（第1卷）》</a>（豆瓣评分 9.4，0.4K+人评价）</strong> </li></ul><h3 id="面试-1"><a href="#面试-1" class="headerlink" title="面试"></a>面试</h3><ol><li><strong><a href="https://book.douban.com/subject/6966465/" target="_blank" rel="noopener">《剑指Offer》</a>（豆瓣评分 8.3，0.7K+人评价）</strong>这本面试宝典上面涵盖了很多经典的算法面试题，如果你要准备大厂面试的话一定不要错过这本书。《剑指Offer》 对应的算法编程题部分的开源项目解析：<a href="https://github.com/gatieme/CodingInterviews" target="_blank" rel="noopener">CodingInterviews</a></li><li><strong><a href="https://book.douban.com/subject/30422021/" target="_blank" rel="noopener">程序员代码面试指南：IT名企算法与数据结构题目最优解（第2版）</a> （豆瓣评分 8.7，0.2K+人评价）</strong> ：题目相比于《剑指 offer》 来说要难很多，题目涵盖面相比于《剑指 offer》也更加全面。全书一共有将近300道真实出现过的经典代码面试题。</li><li><strong><a href="https://book.douban.com/subject/3004255/" target="_blank" rel="noopener">编程之美</a>（豆瓣评分 8.4，3K+人评价）</strong>：这本书收集了约60道算法和程序设计题目，这些题目大部分在近年的笔试、面试中出现过，或者是被微软员工热烈讨论过。作者试图从书中各种有趣的问题出发，引导读者发现问题，分析问题，解决问题，寻找更优的解法。</li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><strong>MySQL:</strong></p><ul><li><strong><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">《高性能 MySQL》</a></strong>：这本书不用多说了把！MySQL 领域的经典之作，拥有广泛的影响力。不但适合数据库管理员（dba）阅读，也适合开发人员参考学习。不管是数据库新手还是专家，相信都能从本书有所收获。如果你的时间不够的话，第5章关于索引的内容和第6章关于查询的内容是必读的！</li><li><a href="https://book.douban.com/subject/24708143/" target="_blank" rel="noopener">《MySQL 技术内幕-InnoDB 存储引擎》</a>（推荐，豆瓣评分 8.7）：了解 InnoDB 存储引擎底层原理必备的一本书，比较深入。</li></ul><p><strong>Redis:</strong></p><ul><li><strong><a href="https://book.douban.com/subject/26612779/" target="_blank" rel="noopener">《Redis 实战》</a></strong>：如果你想了解 Redis 的一些概念性知识的话，这本书真的非常不错。</li><li><strong><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis 设计与实现》</a></strong>：也还行吧！</li></ul><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li><strong><a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">《设计模式 : 可复用面向对象软件的基础》</a></strong> ：设计模式的经典！</li><li><strong><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式（中文版）》</a></strong> ：相当赞的一本设计模式入门书籍。用实际的编程案例讲解算法设计中会遇到的各种问题和需求变更（对的，连需求变更都考虑到了！），并以此逐步推导出良好的设计模式解决办法。</li><li><strong><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></strong> ：本书通篇都是以情景对话的形式，用多个小故事或编程示例来组织讲解GOF(即《设计模式 : 可复用面向对象软件的基础》这本书))，但是不像《设计模式 : 可复用面向对象软件的基础》难懂。但是设计模式只看书是不够的，还是需要在实际项目中运用，在实战中体会。</li></ul><h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><h4 id="Spring-SpringBoot"><a href="#Spring-SpringBoot" class="headerlink" title="Spring/SpringBoot"></a>Spring/SpringBoot</h4><ul><li><strong><a href="https://book.douban.com/subject/26767354/" target="_blank" rel="noopener">《Spring 实战（第 4 版）》</a></strong> ：不建议当做入门书籍读，入门的话可以找点国人的书或者视频看。这本定位就相当于是关于 Spring 的新华字典，只有一些基本概念的介绍和示例，涵盖了 Spring 的各个方面，但都不够深入。就像作者在最后一页写的那样：“学习 Spring，这才刚刚开始”。</li><li><strong>《<a href="https://book.douban.com/subject/30452948/" target="_blank" rel="noopener">Spring源码深度解析 第2版</a>》</strong>  ：读Spring源码必备的一本书籍。市面上关于Spring源码分析的书籍太少了。</li><li><strong><a href="https://book.douban.com/subject/30452637/" target="_blank" rel="noopener">《Spring 5高级编程（第5版）》</a></strong> ：推荐阅读，对于Spring5的新特性介绍的很好！不过内容比较多，可以作为工具书参考。</li><li><strong><a href="https://read.douban.com/ebook/58113975/?dcs=subject-rec&dcm=douban&dct=26767354" target="_blank" rel="noopener">《精通Spring4.x企业应用开发实战》</a></strong> :通过实战讲解，比较适合作为Spring入门书籍来看。</li><li><strong><a href="https://book.douban.com/subject/26652876/" target="_blank" rel="noopener">《Spring入门经典》</a></strong> ：适合入门，也有很多示例！</li><li><strong><a href="https://book.douban.com/subject/34894533/" target="_blank" rel="noopener">《Spring Boot实战派》</a></strong> ：这本书使用的Spring Boot 2.0+的版本，还算比较新。整本书采用“知识点+实例”的形式编写。本书通过“58个基于知识的实例+2个综合性的项目”，深入地讲解Spring Boot的技术原理、知识点和具体应用；把晦涩难懂的理论用实例展现出来，使得读者对知识的理解变得非常容易，同时也立即学会如何使用它。说实话，我还是比较推荐这本书的。</li><li><strong><a href="https://book.douban.com/subject/33390560/" target="_blank" rel="noopener">《Spring Boot编程思想（核心篇）》</a></strong> ：SpringBoot深入书，不适合初学者。书尤其的厚，这本书的缺点是书的很多知识点的讲解过于啰嗦和拖沓，优点是书中对SpringBoot内部原理讲解很清楚。</li></ul><h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><ul><li><strong><a href="https://book.douban.com/subject/30381214/" target="_blank" rel="noopener">《Netty进阶之路：跟着案例学Netty》</a></strong> : 这本书的优点是有不少实际的案例的讲解，通过案例来学习是很不错的！</li><li><strong><a href="https://waylau.gitbooks.io/netty-4-user-guide/content/" target="_blank" rel="noopener">《Netty 4.x 用户指南》</a></strong> ：《Netty 4.x 用户指南》中文翻译（包含了官方文档以及其他文章）。</li><li><strong><a href="https://juejin.im/book/5b4bc28bf265da0f60130116?referrer=59fbb2daf265da4319559f3a" target="_blank" rel="noopener">《Netty 入门与实战：仿写微信 IM 即时通讯系统》</a></strong>   ：基于 Netty 框架实现 IM 核心系统，带你深入学习 Netty 网络编程核心知识</li><li><strong><a href="https://book.douban.com/subject/27038538/" target="_blank" rel="noopener">《Netty 实战》</a></strong> ：可以作为工具书参考！</li></ul><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ul><li><strong><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="noopener">《从 Paxos 到 Zookeeper》</a></strong>：简要介绍几种典型的分布式一致性协议，以及解决分布式一致性问题的思路，其中重点讲解了 Paxos 和 ZAB 协议。同时，本书深入介绍了分布式一致性问题的工业解决方案——ZooKeeper，并着重向读者展示这一分布式协调框架的使用方法、内部实现及运维技巧，旨在帮助读者全面了解 ZooKeeper，并更好地使用和运维 ZooKeeper。</li><li><strong><a href="https://book.douban.com/subject/27591386/" target="_blank" rel="noopener">《RabbitMQ 实战指南》</a></strong>：《RabbitMQ 实战指南》从消息中间件的概念和 RabbitMQ 的历史切入，主要阐述 RabbitMQ 的安装、使用、配置、管理、运维、原理、扩展等方面的细节。如果你想浅尝 RabbitMQ 的使用，这本书是你最好的选择；如果你想深入 RabbitMQ 的原理，这本书也是你最好的选择；总之，如果你想玩转 RabbitMQ，这本书一定是最值得看的书之一</li><li><strong><a href="https://book.douban.com/subject/27025912/" target="_blank" rel="noopener">《Spring Cloud 微服务实战》</a></strong>：从时下流行的微服务架构概念出发，详细介绍了 Spring Cloud 针对微服务架构中几大核心要素的解决方案和基础组件。对于各个组件的介绍，《Spring Cloud 微服务实战》主要以示例与源码结合的方式来帮助读者更好地理解这些组件的使用方法以及运行原理。同时，在介绍的过程中，还包含了作者在实践中所遇到的一些问题和解决思路，可供读者在实践中作为参考。</li></ul><h3 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h3><ul><li><strong><a href="https://book.douban.com/subject/25723064/" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析+李智慧》</a></strong>:这本书我读过，基本不需要你有什么基础啊~读起来特别轻松，但是却可以学到很多东西，非常推荐了。另外我写过这本书的思维导图，关注我的微信公众号：“Java 面试通关手册”回复“大型网站技术架构”即可领取思维导图。</li><li><strong><a href="https://book.douban.com/subject/26999243/" target="_blank" rel="noopener">《亿级流量网站架构核心技术》</a></strong>：一书总结并梳理了亿级流量网站高可用和高并发原则，通过实例详细介绍了如何落地这些原则。本书分为四部分：概述、高可用原则、高并发原则、案例实战。从负载均衡、限流、降级、隔离、超时与重试、回滚机制、压测与预案、缓存、池化、异步化、扩容、队列等多方面详细介绍了亿级流量网站的架构核心技术，让读者看后能快速运用到实践项目中。</li></ul><h3 id="软件底层"><a href="#软件底层" class="headerlink" title="软件底层"></a>软件底层</h3><ul><li><strong><a href="https://book.douban.com/subject/10426640/" target="_blank" rel="noopener">《深入剖析 Tomcat》</a></strong>：本书深入剖析 Tomcat 4 和 Tomcat 5 中的每个组件，并揭示其内部工作原理。通过学习本书，你将可以自行开发 Tomcat 组件，或者扩展已有的组件。 读完这本书，基本可以摆脱背诵面试题的尴尬。</li><li><strong><a href="https://book.douban.com/subject/26745255/" target="_blank" rel="noopener">《深入理解 Nginx（第 2 版）》</a></strong>：作者讲的非常细致，注释都写的都很工整，对于 Nginx 的开发人员非常有帮助。优点是细致，缺点是过于细致，到处都是代码片段，缺少一些抽象。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong><a href="https://book.douban.com/subject/25953851/" target="_blank" rel="noopener">《深入分析 Java Web 技术内幕》</a></strong>：  感觉还行，涉及的东西也蛮多。</li></ul><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul><li><p><strong><a href="https://read.douban.com/ebook/387525/?dcs=subject-rec&dcm=douban&dct=2243615" target="_blank" rel="noopener">《黑客与画家》</a></strong>：这本书是硅谷创业之父，Y Combinator 创始人 Paul Graham 的文集。之所以叫这个名字，是因为作者认为黑客（并非负面的那个意思）与画家有着极大的相似性，他们都是在创造，而不是完成某个任务。</p></li><li><p><strong><a href="https://book.douban.com/subject/26265544/" target="_blank" rel="noopener">《图解密码技术》</a></strong>：本书以<strong>图配文</strong>的形式，第一部分讲述了密码技术的历史沿革、对称密码、分组密码模式（包括ECB、CBC、CFB、OFB、CTR）、公钥、混合密码系统。第二部分重点介绍了认证方面的内容，涉及单向散列函数、消息认证码、数字签名、证书等。第三部分讲述了密钥、随机数、PGP、SSL/TLS 以及密码技术在现实生活中的应用。关键字：JWT 前置知识、区块链密码技术前置知识。属于密码知识入门书籍。</p></li><li><p>《人月神话》 、《程序开发心理学》 、《程序员修炼之道，从小工道专家》、 《高效程序员的45个习惯，敏捷开发修炼之道》 、《高效能程序员的修炼》 、《软技能，代码之外的生存之道》  、《程序员的职业素养》 、《程序员的思维修炼》</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一些摘抄的优美句子~</title>
      <link href="/2020/01/14/good/"/>
      <url>/2020/01/14/good/</url>
      
        <content type="html"><![CDATA[<h5 id="1-有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了。有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了。"><a href="#1-有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了。有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了。" class="headerlink" title="1.有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了。有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了。"></a>1.有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了。有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了。</h5><p>——泰戈尔﻿﻿</p><h5 id="2-我是你路上最后一个过客，最后一个春天，最后一场雪，最后一次求生的战争"><a href="#2-我是你路上最后一个过客，最后一个春天，最后一场雪，最后一次求生的战争" class="headerlink" title="2.我是你路上最后一个过客，最后一个春天，最后一场雪，最后一次求生的战争"></a>2.我是你路上最后一个过客，最后一个春天，最后一场雪，最后一次求生的战争</h5><p>——保尔 艾吕雅﻿﻿</p><h5 id="3-虽然我已经十年没见过他，但我知道我会永远想念他。后来我再也没有交过像十二岁时那帮人一样的好朋友。也许，每个人都是这样"><a href="#3-虽然我已经十年没见过他，但我知道我会永远想念他。后来我再也没有交过像十二岁时那帮人一样的好朋友。也许，每个人都是这样" class="headerlink" title="3.虽然我已经十年没见过他，但我知道我会永远想念他。后来我再也没有交过像十二岁时那帮人一样的好朋友。也许，每个人都是这样"></a>3.虽然我已经十年没见过他，但我知道我会永远想念他。后来我再也没有交过像十二岁时那帮人一样的好朋友。也许，每个人都是这样</h5><p>——罗伯莱纳﻿﻿</p><h5 id="4-在喧闹、混杂的生活中你应该与你的内心和平相处。尽管这世上有很多假冒和欺骗，有很多单调乏味的工作和众多破灭的梦幻，他仍然是一个美好的世界。记住：你应该努力的追求幸福。"><a href="#4-在喧闹、混杂的生活中你应该与你的内心和平相处。尽管这世上有很多假冒和欺骗，有很多单调乏味的工作和众多破灭的梦幻，他仍然是一个美好的世界。记住：你应该努力的追求幸福。" class="headerlink" title="4.在喧闹、混杂的生活中你应该与你的内心和平相处。尽管这世上有很多假冒和欺骗，有很多单调乏味的工作和众多破灭的梦幻，他仍然是一个美好的世界。记住：你应该努力的追求幸福。"></a>4.在喧闹、混杂的生活中你应该与你的内心和平相处。尽管这世上有很多假冒和欺骗，有很多单调乏味的工作和众多破灭的梦幻，他仍然是一个美好的世界。记住：你应该努力的追求幸福。</h5><p>（此文于1692年镌于巴尔的摩圣保罗教堂）﻿﻿</p><h5 id="5-我开始真正爱自己，我不再继续沉溺于过去，也不再为明天而忧虑，现在的我只活在一切在发生的当下，今天我活在此时此地，如此日复一日，这就叫”完美”。"><a href="#5-我开始真正爱自己，我不再继续沉溺于过去，也不再为明天而忧虑，现在的我只活在一切在发生的当下，今天我活在此时此地，如此日复一日，这就叫”完美”。" class="headerlink" title="5.我开始真正爱自己，我不再继续沉溺于过去，也不再为明天而忧虑，现在的我只活在一切在发生的当下，今天我活在此时此地，如此日复一日，这就叫”完美”。"></a>5.我开始真正爱自己，我不再继续沉溺于过去，也不再为明天而忧虑，现在的我只活在一切在发生的当下，今天我活在此时此地，如此日复一日，这就叫”完美”。</h5><p>——《当我开始爱自己》﻿﻿</p><h5 id="6-如果有一天你不再寻找爱情，只是去爱；你不再渴望成功，只是去做；你不再追逐成长，只是去修；一切才真正开始"><a href="#6-如果有一天你不再寻找爱情，只是去爱；你不再渴望成功，只是去做；你不再追逐成长，只是去修；一切才真正开始" class="headerlink" title="6.如果有一天你不再寻找爱情，只是去爱；你不再渴望成功，只是去做；你不再追逐成长，只是去修；一切才真正开始"></a>6.如果有一天你不再寻找爱情，只是去爱；你不再渴望成功，只是去做；你不再追逐成长，只是去修；一切才真正开始</h5><p>——纪伯伦﻿﻿</p><h5 id="7-我原谅了从前的自己，就像谅解了一个野心勃勃的傻逼，体恤了一个笨手笨脚的勇士，释怀了一个难以启齿的秘密。"><a href="#7-我原谅了从前的自己，就像谅解了一个野心勃勃的傻逼，体恤了一个笨手笨脚的勇士，释怀了一个难以启齿的秘密。" class="headerlink" title="7.我原谅了从前的自己，就像谅解了一个野心勃勃的傻逼，体恤了一个笨手笨脚的勇士，释怀了一个难以启齿的秘密。﻿﻿"></a>7.我原谅了从前的自己，就像谅解了一个野心勃勃的傻逼，体恤了一个笨手笨脚的勇士，释怀了一个难以启齿的秘密。﻿﻿</h5><h5 id="8-原来可以这样爱你，什么也可以说，什么也可以不说。让我采一束月光吧！插在今夜我寂寥的窗前。过了今夜，我不会再有力气为你写诗和流泪。"><a href="#8-原来可以这样爱你，什么也可以说，什么也可以不说。让我采一束月光吧！插在今夜我寂寥的窗前。过了今夜，我不会再有力气为你写诗和流泪。" class="headerlink" title="8.原来可以这样爱你，什么也可以说，什么也可以不说。让我采一束月光吧！插在今夜我寂寥的窗前。过了今夜，我不会再有力气为你写诗和流泪。"></a>8.原来可以这样爱你，什么也可以说，什么也可以不说。让我采一束月光吧！插在今夜我寂寥的窗前。过了今夜，我不会再有力气为你写诗和流泪。</h5><p>——海烟﻿﻿</p><h5 id="9-我不知该如何珍藏明里这份温暖，也不知该将她的灵魂带往何处。我清楚地明白，我们无法保证将来能够永远在一起。横亘在我们面前的是那沉重的人生于漫长时间，让人不由得产生一种无力感"><a href="#9-我不知该如何珍藏明里这份温暖，也不知该将她的灵魂带往何处。我清楚地明白，我们无法保证将来能够永远在一起。横亘在我们面前的是那沉重的人生于漫长时间，让人不由得产生一种无力感" class="headerlink" title="9.我不知该如何珍藏明里这份温暖，也不知该将她的灵魂带往何处。我清楚地明白，我们无法保证将来能够永远在一起。横亘在我们面前的是那沉重的人生于漫长时间，让人不由得产生一种无力感"></a>9.我不知该如何珍藏明里这份温暖，也不知该将她的灵魂带往何处。我清楚地明白，我们无法保证将来能够永远在一起。横亘在我们面前的是那沉重的人生于漫长时间，让人不由得产生一种无力感</h5><p>——新海诚﻿﻿</p><h5 id="10-此刻有谁在世上某处哭，无缘无故在世上哭，在哭我。此刻有谁在夜间某处笑，无缘无故的在夜间笑，在笑我。此刻有谁在世上某处走，无缘无故的在世上走，走向我。此刻有谁在世上某处死，无缘无故在世上死，望着我。"><a href="#10-此刻有谁在世上某处哭，无缘无故在世上哭，在哭我。此刻有谁在夜间某处笑，无缘无故的在夜间笑，在笑我。此刻有谁在世上某处走，无缘无故的在世上走，走向我。此刻有谁在世上某处死，无缘无故在世上死，望着我。" class="headerlink" title="10.此刻有谁在世上某处哭，无缘无故在世上哭，在哭我。此刻有谁在夜间某处笑，无缘无故的在夜间笑，在笑我。此刻有谁在世上某处走，无缘无故的在世上走，走向我。此刻有谁在世上某处死，无缘无故在世上死，望着我。"></a>10.此刻有谁在世上某处哭，无缘无故在世上哭，在哭我。此刻有谁在夜间某处笑，无缘无故的在夜间笑，在笑我。此刻有谁在世上某处走，无缘无故的在世上走，走向我。此刻有谁在世上某处死，无缘无故在世上死，望着我。</h5><p>——里尔克﻿﻿</p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-f33e20c34492e783.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="高山森林"></p><h5 id="11-不惋惜，不呼唤，我也不啼哭。一切将逝去。如苹果花丛的薄雾。金黄的落叶堆满心间，我已不再是青春少年"><a href="#11-不惋惜，不呼唤，我也不啼哭。一切将逝去。如苹果花丛的薄雾。金黄的落叶堆满心间，我已不再是青春少年" class="headerlink" title="11.不惋惜，不呼唤，我也不啼哭。一切将逝去。如苹果花丛的薄雾。金黄的落叶堆满心间，我已不再是青春少年"></a>11.不惋惜，不呼唤，我也不啼哭。一切将逝去。如苹果花丛的薄雾。金黄的落叶堆满心间，我已不再是青春少年</h5><p>——叶赛宁﻿﻿</p><h5 id="12-多希望我知道如何放弃你，你什么都没留给我却活在我心里。"><a href="#12-多希望我知道如何放弃你，你什么都没留给我却活在我心里。" class="headerlink" title="12.多希望我知道如何放弃你，你什么都没留给我却活在我心里。﻿﻿"></a>12.多希望我知道如何放弃你，你什么都没留给我却活在我心里。﻿﻿</h5><h5 id="13-最要紧的是，我们首先应该知道善良，其次要诚实，再其次是以后永远不要互相遗忘。"><a href="#13-最要紧的是，我们首先应该知道善良，其次要诚实，再其次是以后永远不要互相遗忘。" class="headerlink" title="13.最要紧的是，我们首先应该知道善良，其次要诚实，再其次是以后永远不要互相遗忘。﻿﻿"></a>13.最要紧的是，我们首先应该知道善良，其次要诚实，再其次是以后永远不要互相遗忘。﻿﻿</h5><h5 id="14-我向旧日的恋人道歉，因为我对新人如同初恋。"><a href="#14-我向旧日的恋人道歉，因为我对新人如同初恋。" class="headerlink" title="14.我向旧日的恋人道歉，因为我对新人如同初恋。"></a>14.我向旧日的恋人道歉，因为我对新人如同初恋。</h5><p>——辛波斯卡﻿﻿</p><h5 id="15-我永恒的灵魂，注视着你的心，纵然黑夜孤寂白昼如焚。"><a href="#15-我永恒的灵魂，注视着你的心，纵然黑夜孤寂白昼如焚。" class="headerlink" title="15.我永恒的灵魂，注视着你的心，纵然黑夜孤寂白昼如焚。"></a>15.我永恒的灵魂，注视着你的心，纵然黑夜孤寂白昼如焚。</h5><p>——兰波﻿﻿</p><h5 id="16-我常想，如果我拍够了足够的照片，我就不会再失去任何人。事实上，我的照片让我看到了我失去了多少"><a href="#16-我常想，如果我拍够了足够的照片，我就不会再失去任何人。事实上，我的照片让我看到了我失去了多少" class="headerlink" title="16.我常想，如果我拍够了足够的照片，我就不会再失去任何人。事实上，我的照片让我看到了我失去了多少"></a>16.我常想，如果我拍够了足够的照片，我就不会再失去任何人。事实上，我的照片让我看到了我失去了多少</h5><p>——南戈尔丁﻿﻿</p><h5 id="17-知识让我们愤世嫉俗，聪明让我们铁石心肠。我们想的太多，同情太少，除了机器我们更需要善良，没有这些品质，生命就没有意义。"><a href="#17-知识让我们愤世嫉俗，聪明让我们铁石心肠。我们想的太多，同情太少，除了机器我们更需要善良，没有这些品质，生命就没有意义。" class="headerlink" title="17.知识让我们愤世嫉俗，聪明让我们铁石心肠。我们想的太多，同情太少，除了机器我们更需要善良，没有这些品质，生命就没有意义。"></a>17.知识让我们愤世嫉俗，聪明让我们铁石心肠。我们想的太多，同情太少，除了机器我们更需要善良，没有这些品质，生命就没有意义。</h5><p>——卓别林﻿﻿</p><h5 id="18-你别赤脚走在这片草地上散步，我怕我的花园到处都是星星的碎片。"><a href="#18-你别赤脚走在这片草地上散步，我怕我的花园到处都是星星的碎片。" class="headerlink" title="18.你别赤脚走在这片草地上散步，我怕我的花园到处都是星星的碎片。"></a>18.你别赤脚走在这片草地上散步，我怕我的花园到处都是星星的碎片。</h5><p>——伊迪斯 索德格朗﻿﻿</p><h5 id="19-身体里的碳可以制成九千支铅笔，赠给诗人。身体里的铁，只够打成一枚铁钉，就钉在爱人的心上。"><a href="#19-身体里的碳可以制成九千支铅笔，赠给诗人。身体里的铁，只够打成一枚铁钉，就钉在爱人的心上。" class="headerlink" title="19.身体里的碳可以制成九千支铅笔，赠给诗人。身体里的铁，只够打成一枚铁钉，就钉在爱人的心上。﻿﻿"></a>19.身体里的碳可以制成九千支铅笔，赠给诗人。身体里的铁，只够打成一枚铁钉，就钉在爱人的心上。﻿﻿</h5><h5 id="20-岁月有加，并非垂老。理想丢弃，方坠暮年。岁月悠悠，衰微只及肌肤。热忱抛却，颓废必致灵魂。"><a href="#20-岁月有加，并非垂老。理想丢弃，方坠暮年。岁月悠悠，衰微只及肌肤。热忱抛却，颓废必致灵魂。" class="headerlink" title="20.岁月有加，并非垂老。理想丢弃，方坠暮年。岁月悠悠，衰微只及肌肤。热忱抛却，颓废必致灵魂。"></a>20.岁月有加，并非垂老。理想丢弃，方坠暮年。岁月悠悠，衰微只及肌肤。热忱抛却，颓废必致灵魂。</h5><p>——塞缪尔 厄尔曼﻿﻿</p><h5 id="21-情不知所起，一往而深"><a href="#21-情不知所起，一往而深" class="headerlink" title="21.情不知所起，一往而深"></a>21.情不知所起，一往而深</h5><p>——汤显祖﻿﻿</p><h5 id="22-渐渐觉得，友谊这个东西已经被世人捧的太高，它跟永恒其实没有太大关系。换了空间时间，总会有人离去。也总会有与当下的你心有相同的同伴不断出现，来陪你走接下来或短或长的人生。所以不要太念念不忘。也不要期待有什么回响。你要从同路者中寻找同伴，而非硬拽着旧人一起上路。"><a href="#22-渐渐觉得，友谊这个东西已经被世人捧的太高，它跟永恒其实没有太大关系。换了空间时间，总会有人离去。也总会有与当下的你心有相同的同伴不断出现，来陪你走接下来或短或长的人生。所以不要太念念不忘。也不要期待有什么回响。你要从同路者中寻找同伴，而非硬拽着旧人一起上路。" class="headerlink" title="22.渐渐觉得，友谊这个东西已经被世人捧的太高，它跟永恒其实没有太大关系。换了空间时间，总会有人离去。也总会有与当下的你心有相同的同伴不断出现，来陪你走接下来或短或长的人生。所以不要太念念不忘。也不要期待有什么回响。你要从同路者中寻找同伴，而非硬拽着旧人一起上路。﻿﻿"></a>22.渐渐觉得，友谊这个东西已经被世人捧的太高，它跟永恒其实没有太大关系。换了空间时间，总会有人离去。也总会有与当下的你心有相同的同伴不断出现，来陪你走接下来或短或长的人生。所以不要太念念不忘。也不要期待有什么回响。你要从同路者中寻找同伴，而非硬拽着旧人一起上路。﻿﻿</h5><h5 id="23-世界上最大的勇气，是压力下的优雅。"><a href="#23-世界上最大的勇气，是压力下的优雅。" class="headerlink" title="23.世界上最大的勇气，是压力下的优雅。"></a>23.世界上最大的勇气，是压力下的优雅。</h5><p>——海明威﻿﻿</p><h5 id="24-为你，千千万万遍"><a href="#24-为你，千千万万遍" class="headerlink" title="24.为你，千千万万遍"></a>24.为你，千千万万遍</h5><p>——卡勒德 胡塞尼﻿﻿</p><h5 id="25-你，一会看我一会看云；你看我时很远，你看云时很近"><a href="#25-你，一会看我一会看云；你看我时很远，你看云时很近" class="headerlink" title="25.你，一会看我一会看云；你看我时很远，你看云时很近"></a>25.你，一会看我一会看云；你看我时很远，你看云时很近</h5><p>——顾城﻿﻿</p><h5 id="26"><a href="#26" class="headerlink" title="26."></a>26.</h5><p>草在结它的种子﻿﻿</p><p>树在摇它的叶子﻿﻿</p><p>我们站着 不说话﻿﻿</p><p>就十分美好﻿﻿</p><p>——顾城《门前》﻿﻿</p><h5 id="27-曾国藩的交友原则，八交九不交："><a href="#27-曾国藩的交友原则，八交九不交：" class="headerlink" title="27.曾国藩的交友原则，八交九不交：﻿﻿"></a>27.曾国藩的交友原则，八交九不交：﻿﻿</h5><p>八交：胜己者；盛德者；趣味者；肯吃亏者；直言者；志趣广大者；惠在当厄者；体人者﻿﻿</p><p>九不交：志不同者；谀人者；恩怨颠倒者；全无性情者；不孝不悌者；迂人者；落井下石者；德薄者；好占便宜者。﻿﻿</p><h5 id="28-那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，我想吃，我还想一瞬间变成天上半明半暗的云。"><a href="#28-那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，我想吃，我还想一瞬间变成天上半明半暗的云。" class="headerlink" title="28.那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，我想吃，我还想一瞬间变成天上半明半暗的云。"></a>28.那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，我想吃，我还想一瞬间变成天上半明半暗的云。</h5><p>——王小波《黄金时代》﻿﻿</p><h5 id="29-从童年起，我便独自一人照顾着历代星辰"><a href="#29-从童年起，我便独自一人照顾着历代星辰" class="headerlink" title="29.从童年起，我便独自一人照顾着历代星辰"></a>29.从童年起，我便独自一人照顾着历代星辰</h5><p>——《孤独》白鹤林﻿﻿</p><h5 id="30-这样看你，用所有的眼睛和所有距离，就像风住了，风又起"><a href="#30-这样看你，用所有的眼睛和所有距离，就像风住了，风又起" class="headerlink" title="30.这样看你，用所有的眼睛和所有距离，就像风住了，风又起"></a>30.这样看你，用所有的眼睛和所有距离，就像风住了，风又起</h5><p>——《沉溺》冯唐﻿﻿<br><img src="https://upload-images.jianshu.io/upload_images/7326374-abdbf1d8c37fcc71.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="蓝天海滩"></p><h5 id="31-人时已尽，人世很长。我在中间应当休息，走过的人说树枝低了，走过的人说树枝在长。"><a href="#31-人时已尽，人世很长。我在中间应当休息，走过的人说树枝低了，走过的人说树枝在长。" class="headerlink" title="31.人时已尽，人世很长。我在中间应当休息，走过的人说树枝低了，走过的人说树枝在长。"></a>31.人时已尽，人世很长。我在中间应当休息，走过的人说树枝低了，走过的人说树枝在长。</h5><p>——《墓床》顾城﻿﻿</p><h5 id="32-万物皆有裂痕，那是光进来的地方。"><a href="#32-万物皆有裂痕，那是光进来的地方。" class="headerlink" title="32.万物皆有裂痕，那是光进来的地方。"></a>32.万物皆有裂痕，那是光进来的地方。</h5><p>——莱昂纳德 科恩﻿﻿</p><h5 id="33-成功只有一种，那就是用自己喜欢的方式度过一生"><a href="#33-成功只有一种，那就是用自己喜欢的方式度过一生" class="headerlink" title="33.成功只有一种，那就是用自己喜欢的方式度过一生"></a>33.成功只有一种，那就是用自己喜欢的方式度过一生</h5><p>——《明朝那些事》原出于美国记者﻿﻿</p><h5 id="34-生活永远不可能像你想象的那么好，但也不会像你想象的那么糟，无论是好的还是糟糕的时候都需要坚强"><a href="#34-生活永远不可能像你想象的那么好，但也不会像你想象的那么糟，无论是好的还是糟糕的时候都需要坚强" class="headerlink" title="34.生活永远不可能像你想象的那么好，但也不会像你想象的那么糟，无论是好的还是糟糕的时候都需要坚强"></a>34.生活永远不可能像你想象的那么好，但也不会像你想象的那么糟，无论是好的还是糟糕的时候都需要坚强</h5><p>——《人生》莫泊桑﻿﻿</p><h5 id="35-谁这时没有房屋，就不必建筑；谁这时孤独，就永远孤独，就醒着，读着，写着长信。在林荫道上来回，不安的游荡，当落叶纷飞。"><a href="#35-谁这时没有房屋，就不必建筑；谁这时孤独，就永远孤独，就醒着，读着，写着长信。在林荫道上来回，不安的游荡，当落叶纷飞。" class="headerlink" title="35.谁这时没有房屋，就不必建筑；谁这时孤独，就永远孤独，就醒着，读着，写着长信。在林荫道上来回，不安的游荡，当落叶纷飞。"></a>35.谁这时没有房屋，就不必建筑；谁这时孤独，就永远孤独，就醒着，读着，写着长信。在林荫道上来回，不安的游荡，当落叶纷飞。</h5><p>——《秋日》里尔克﻿﻿</p><h5 id="36-也许，我太会隐藏自己的悲伤；也许我太会安慰自己的伤；从阴雨走到艳阳，我路过泥泞，路过风"><a href="#36-也许，我太会隐藏自己的悲伤；也许我太会安慰自己的伤；从阴雨走到艳阳，我路过泥泞，路过风" class="headerlink" title="36.也许，我太会隐藏自己的悲伤；也许我太会安慰自己的伤；从阴雨走到艳阳，我路过泥泞，路过风"></a>36.也许，我太会隐藏自己的悲伤；也许我太会安慰自己的伤；从阴雨走到艳阳，我路过泥泞，路过风</h5><p>——《你若懂我 该多好》﻿﻿</p><h5 id="37-我想无论是在塞纳河还是滹沱河边，我们两个人都已经放下彼此，所以我并没有等，她也不会在那个路灯下了，那个灯光下笑盈盈的她和慌张无力却又自大的我，永远属于了二十出头的我们，仅止于此我很满足，毕竟我们都要朝着让自己幸福努力。"><a href="#37-我想无论是在塞纳河还是滹沱河边，我们两个人都已经放下彼此，所以我并没有等，她也不会在那个路灯下了，那个灯光下笑盈盈的她和慌张无力却又自大的我，永远属于了二十出头的我们，仅止于此我很满足，毕竟我们都要朝着让自己幸福努力。" class="headerlink" title="37.我想无论是在塞纳河还是滹沱河边，我们两个人都已经放下彼此，所以我并没有等，她也不会在那个路灯下了，那个灯光下笑盈盈的她和慌张无力却又自大的我，永远属于了二十出头的我们，仅止于此我很满足，毕竟我们都要朝着让自己幸福努力。﻿﻿"></a>37.我想无论是在塞纳河还是滹沱河边，我们两个人都已经放下彼此，所以我并没有等，她也不会在那个路灯下了，那个灯光下笑盈盈的她和慌张无力却又自大的我，永远属于了二十出头的我们，仅止于此我很满足，毕竟我们都要朝着让自己幸福努力。﻿﻿</h5><h5 id="38-一个人有两个我，一个在黑暗中醒着，一个在光明中睡着"><a href="#38-一个人有两个我，一个在黑暗中醒着，一个在光明中睡着" class="headerlink" title="38.一个人有两个我，一个在黑暗中醒着，一个在光明中睡着"></a>38.一个人有两个我，一个在黑暗中醒着，一个在光明中睡着</h5><p>——纪伯伦﻿﻿</p><h5 id="39-若我会见到你，事隔经年，我如何向你招呼，以眼泪，以沉默"><a href="#39-若我会见到你，事隔经年，我如何向你招呼，以眼泪，以沉默" class="headerlink" title="39.若我会见到你，事隔经年，我如何向你招呼，以眼泪，以沉默"></a>39.若我会见到你，事隔经年，我如何向你招呼，以眼泪，以沉默</h5><p>——拜伦﻿﻿</p><h5 id="40-枕上诗书闲处好，门前风景雨来佳"><a href="#40-枕上诗书闲处好，门前风景雨来佳" class="headerlink" title="40.枕上诗书闲处好，门前风景雨来佳"></a>40.枕上诗书闲处好，门前风景雨来佳</h5><p>——李清照﻿﻿<br><img src="https://upload-images.jianshu.io/upload_images/7326374-87ba94de06d5cd74.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="夕阳风雪"></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>也分享一些杂文~</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-0c30c361239e4cca?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 美文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试集锦：25道线程类相关面试题与答案（一）</title>
      <link href="/2019/11/14/interview/java/A-thread01/"/>
      <url>/2019/11/14/interview/java/A-thread01/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7326374-333fa10a973e7519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java面试集锦：25道线程类相关面试题与答案（一）.png"></p><blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><h3 id="1-线程是什么？进程是什么？二者有什么区别和联系？"><a href="#1-线程是什么？进程是什么？二者有什么区别和联系？" class="headerlink" title="1. 线程是什么？进程是什么？二者有什么区别和联系？"></a>1. 线程是什么？进程是什么？二者有什么区别和联系？</h3><p>（1）线程是CPU独立运行和独立调度的基本单位；<br>（2）进程是资源分配的基本单位；是执行着的应用程序<br>两者的联系：进程和线程都是操作系统所运行的程序运行的基本单元。</p><p><strong>区别：</strong><br>（1）进程具有独立的空间地址，一个进程崩溃后，在保护模式下不会对其它进程产生影响。<br>（2）线程只是一个进程的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。</p><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p><h3 id="2-线程和进程各自有什么区别和优劣呢？"><a href="#2-线程和进程各自有什么区别和优劣呢？" class="headerlink" title="2. 线程和进程各自有什么区别和优劣呢？"></a>2. 线程和进程各自有什么区别和优劣呢？</h3><p>进程是资源分配的最小单位，线程是程序执行的最小单位。</p><p>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</p><p>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p><p>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p><p>可参考文章<a href=""></a></p><h3 id="3-创建线程有几种不同的方式？你喜欢哪一种？为什么？"><a href="#3-创建线程有几种不同的方式？你喜欢哪一种？为什么？" class="headerlink" title="3. 创建线程有几种不同的方式？你喜欢哪一种？为什么？"></a>3. 创建线程有几种不同的方式？你喜欢哪一种？为什么？</h3><p>有三种方式可以用来创建线程：</p><p>继承<code>Thread</code>类</p><p>实现<code>Runnable</code>接口</p><p>应用程序可以使用Executor框架来创建线程池</p><p>实现<code>Runnable接口</code>这种方式更受欢迎，因为这不需要继承<code>Thread</code>类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p><h3 id="4-概括的解释下线程的几种可用状态"><a href="#4-概括的解释下线程的几种可用状态" class="headerlink" title="4. 概括的解释下线程的几种可用状态?"></a>4. 概括的解释下线程的几种可用状态?</h3><p>线程在执行过程中，可以处于下面几种状态：</p><p><strong>就绪(Runnable)</strong>:线程准备运行，不一定立马就能开始执行。</p><p><strong>运行中(Running)</strong>：进程正在执行线程的代码。</p><p><strong>等待中(Waiting)</strong>:线程处于阻塞的状态，等待外部的处理结束。</p><p><strong>睡眠中(Sleeping)</strong>：线程被强制睡眠。</p><p><strong>I/O阻塞(Blocked on I/O)</strong>：等待I/O操作完成。</p><p><strong>同步阻塞(Blocked on Synchronization)</strong>：等待获取锁。</p><p><strong>死亡(Dead)</strong>：线程完成了执行。</p><h3 id="5-同步方法和同步代码块的区别是什么？"><a href="#5-同步方法和同步代码块的区别是什么？" class="headerlink" title="5. 同步方法和同步代码块的区别是什么？"></a>5. 同步方法和同步代码块的区别是什么？</h3><p>在Java语言中，每一个对象有一把锁。线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。</p><p>Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p><p>（1）、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</p><p>（2）、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</p><p>（3）、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</p><p>（4）、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</p><p>（5）、以上规则对其它对象锁同样适用。</p><h3 id="6-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#6-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="6. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>6. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h3><p>监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p><h3 id="7-什么是死锁-deadlock-？"><a href="#7-什么是死锁-deadlock-？" class="headerlink" title="7. 什么是死锁(deadlock)？"></a>7. 什么是死锁(deadlock)？</h3><p>两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p><h3 id="8-如何确保N个线程可以访问N个资源同时又不导致死锁？"><a href="#8-如何确保N个线程可以访问N个资源同时又不导致死锁？" class="headerlink" title="8. 如何确保N个线程可以访问N个资源同时又不导致死锁？"></a>8. 如何确保N个线程可以访问N个资源同时又不导致死锁？</h3><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p><h3 id="9-如何避免死锁"><a href="#9-如何避免死锁" class="headerlink" title="9. 如何避免死锁?"></a>9. 如何避免死锁?</h3><p>多线程产生死锁的四个必要条件：<br><strong>互斥条件：</strong> 一个资源每次只能被一个进程使用。<br><strong>保持和请求条件：</strong> 一个进程因请求资源而阻塞时，对已获得资源保持不放。<br><strong>不可剥夺调教：</strong> 进程已获得资源，在未使用完成前，不能被剥夺。<br><strong>循环等待条件：</strong> 若干进程之间形成一种头尾相接的循环等待资源关系。</p><p>只要破坏其中任意一个条件，就可以避免死锁，其中最简单的就是破环循环等待条件。按同一顺序访问对象，加载锁，释放锁。</p><h3 id="10-Thread-类中的start-和-run-方法有什么区别？"><a href="#10-Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="10. Thread 类中的start() 和 run() 方法有什么区别？"></a>10. Thread 类中的start() 和 run() 方法有什么区别？</h3><p>start()方法被用来启动新创建的线程，使该被创建的线程状态变为可运行状态。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，直接运行run（）方法。为了在新的线程中执行我们的代码，必须使用Thread.start()方法。</p><h3 id="11-Java中Runnable和Callable有什么不同？"><a href="#11-Java中Runnable和Callable有什么不同？" class="headerlink" title="11. Java中Runnable和Callable有什么不同？"></a>11. Java中Runnable和Callable有什么不同？</h3><p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。</p><h3 id="12-Java中什么是竞态条件？"><a href="#12-Java中什么是竞态条件？" class="headerlink" title="12. Java中什么是竞态条件？"></a>12. Java中什么是竞态条件？</h3><p>在大多数实际的多线程应用中，两个或两个以上的线程需要共享对同一数据的存取。如果i线程存取相同的对象，并且每一个线程都调用了一个修改该对象状态的方法，将会发生什么呢？可以想象，线程彼此踩了对方的脚。根据线程访问数据的次序，可能会产生讹误的对象。这样的情况通常称为竞争条件。</p><h3 id="13-Java中如何停止一个线程？"><a href="#13-Java中如何停止一个线程？" class="headerlink" title="13. Java中如何停止一个线程？"></a>13. Java中如何停止一个线程？</h3><p><code>Java</code>提供了很丰富的API但没有为停止线程提供API。<br><code>JDK 1.0</code>本来有一些像<code>stop()</code>, <code>suspend()</code> 和 <code>resume()</code>的控制方法，但是由于潜在的死锁威胁。<br>因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。<br>当<code>run()</code>或者 <code>call()</code> 方法执行完的时候线程会自动结束，如果要手动结束一个线程，可以用<code>volatile</code> 布尔变量来退出<code>run()</code>方法的循环或者是取消任务来中断线程。</p><h3 id="14-Java中notify-和-notifyAll有什么区别？"><a href="#14-Java中notify-和-notifyAll有什么区别？" class="headerlink" title="14. Java中notify 和 notifyAll有什么区别？"></a>14. Java中notify 和 notifyAll有什么区别？</h3><p>一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。<br>如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p><h3 id="15-Java中的同步集合与并发集合有什么区别？"><a href="#15-Java中的同步集合与并发集合有什么区别？" class="headerlink" title="15. Java中的同步集合与并发集合有什么区别？"></a>15. Java中的同步集合与并发集合有什么区别？</h3><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。<br>在<code>Java1.5</code>之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像<code>ConcurrentHashMap</code>，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p><h3 id="16-什么是线程池？"><a href="#16-什么是线程池？" class="headerlink" title="16. 什么是线程池？"></a>16. 什么是线程池？</h3><p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。<br>如果每个请求都创建一个线程去处理，那么服务器的资源很快就会被耗尽，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p><h3 id="17-为什么要使用线程池？"><a href="#17-为什么要使用线程池？" class="headerlink" title="17. 为什么要使用线程池？"></a>17. 为什么要使用线程池？</h3><p>创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。（我们可以把创建和销毁的线程的过程去掉）</p><h3 id="18-线程池有什么作用？"><a href="#18-线程池有什么作用？" class="headerlink" title="18. 线程池有什么作用？"></a>18. 线程池有什么作用？</h3><p>线程池作用就是限制系统中执行线程的数量。</p><p>1、提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。</p><p>2、方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。</p><h3 id="19-说说几种常见的线程池及使用场景"><a href="#19-说说几种常见的线程池及使用场景" class="headerlink" title="19. 说说几种常见的线程池及使用场景?"></a>19. 说说几种常见的线程池及使用场景?</h3><p>1、<code>newSingleThreadExecutor</code>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><p>2、<code>newFixedThreadPool</code>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>3、<code>newCachedThreadPool</code>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>4、<code>newScheduledThreadPool</code>创建一个定长线程池，支持定时及周期性任务执行。</p><h3 id="20-线程池中的几种重要的参数"><a href="#20-线程池中的几种重要的参数" class="headerlink" title="20. 线程池中的几种重要的参数?"></a>20. 线程池中的几种重要的参数?</h3><p><code>corePoolSize</code>就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收</p><p><code>maximumPoolSize</code>就是线程池中可以容纳的最大线程的数量</p><p><code>keepAliveTime</code>，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间。<br><code>util</code>，就是计算这个时间的一个单位。</p><p><code>workQueue</code>，就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。</p><p><code>threadFactory</code>，就是创建线程的线程工厂。</p><p><code>handler</code>,是一种拒绝策略，我们可以在任务满了之后，拒绝执行某些任务。</p><h3 id="21-说说线程池的拒绝策略"><a href="#21-说说线程池的拒绝策略" class="headerlink" title="21. 说说线程池的拒绝策略?"></a>21. 说说线程池的拒绝策略?</h3><p>当请求任务不断的过来，而系统此时又处理不过来的时候，我们需要采取的策略是拒绝服务。RejectedExecutionHandler接口提供了拒绝任务处理的自定义方法的机会。在ThreadPoolExecutor中已经包含四种处理策略。</p><ul><li>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。</li></ul><ul><li><p>CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。</p></li><li><p>DiscardOleddestPolicy策略： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</p></li></ul><ul><li>DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。</li></ul><p>除了JDK默认提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，自定义的方式很简单，直接实现<code>RejectedExecutionHandler</code>接口即可。</p><h3 id="22-execute和submit的区别？"><a href="#22-execute和submit的区别？" class="headerlink" title="22. execute和submit的区别？"></a>22. execute和submit的区别？</h3><p>我们执行任务是用的execute方法，除了execute方法，还有一个submit方法也可以执行我们提交的任务。</p><p>这两个方法有什么区别呢？分别适用于在什么场景下呢？<br>我们来做一个简单的分析。</p><ul><li><p>execute适用于不需要关注返回值的场景，只需要将线程丢到线程池中去执行就可以了。</p></li><li><p>submit方法适用于需要关注返回值的场景</p></li></ul><h3 id="23-五种线程池的使用场景"><a href="#23-五种线程池的使用场景" class="headerlink" title="23. 五种线程池的使用场景?"></a>23. 五种线程池的使用场景?</h3><ul><li><p>newSingleThreadExecutor：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。</p></li><li><p>newFixedThreadPool：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。</p></li></ul><ul><li>newCachedThreadPool：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。</li></ul><ul><li>newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</li><li>newWorkStealingPool：一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行。</li></ul><h3 id="24-线程池如何关闭-初始化线程池时线程数的选择？"><a href="#24-线程池如何关闭-初始化线程池时线程数的选择？" class="headerlink" title="24. 线程池如何关闭? 初始化线程池时线程数的选择？"></a>24. 线程池如何关闭? 初始化线程池时线程数的选择？</h3><p>关闭线程池可以调用shutdownNow和shutdown两个方法来实现</p><p>shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表。</p><p>shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。</p><p>如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。</p><p>如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。</p><p>上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。</p><h3 id="25-线程池都有哪几种工作队列？"><a href="#25-线程池都有哪几种工作队列？" class="headerlink" title="25. 线程池都有哪几种工作队列？"></a>25. 线程池都有哪几种工作队列？</h3><p>1、<code>ArrayBlockingQueue</code></p><p>是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p>2、<code>LinkedBlockingQueue</code><br>一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</p><p>3、<code>SynchronousQueue</code></p><p>一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p><p>4、<code>PriorityBlockingQueue</code></p><p>一个具有优先级的无限阻塞队列。</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">大厂笔试内容集合（内有详细解析）</a> 持续更新中….</p><p><a href="https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21" target="_blank" rel="noopener">ProcessOn是一个在线作图工具的聚合平台~</a></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-fdefd65feb040355?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（十七）</title>
      <link href="/2019/10/05/interview/java/B-bishi17/"/>
      <url>/2019/10/05/interview/java/B-bishi17/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-c2efdcc4e8d423eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（十七）"></p><h2 id="1-程序Demo-java编译运行后输出的结果是：-？"><a href="#1-程序Demo-java编译运行后输出的结果是：-？" class="headerlink" title="1. 程序Demo.java编译运行后输出的结果是：( )？"></a>1. 程序Demo.java编译运行后输出的结果是：( )？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Demo&#123;</span><br><span class="line"></span><br><span class="line">    int x&#x3D;1；</span><br><span class="line">    int y；</span><br><span class="line"></span><br><span class="line">    public static void main（String [] args）&#123;</span><br><span class="line"></span><br><span class="line">        int z&#x3D;2;</span><br><span class="line">        Demo t&#x3D;new Demo();</span><br><span class="line">        System.out.println(t.x+t.y+z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.3<br>B.12<br>C.1<br>D.5</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>这题考的是默认初始化问题，但是可以引出另外一个问题：局部变量参与运算前是必须要初始化的，比如下面的代码就会编译出错，提示y必须要初始化。 </p><h2 id="2-HashSet子类依靠-方法区分重复元素。"><a href="#2-HashSet子类依靠-方法区分重复元素。" class="headerlink" title="2.HashSet子类依靠()方法区分重复元素。"></a>2.HashSet子类依靠()方法区分重复元素。</h2><p>A.toString(),equals()<br>B.clone(),equals()<br>C.hashCode(),equals()<br>D.getClass(),clone()</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。</p><h2 id="3-Java-语言中创建一个对象使用的关键字是（）"><a href="#3-Java-语言中创建一个对象使用的关键字是（）" class="headerlink" title="3. Java 语言中创建一个对象使用的关键字是（）"></a>3. Java 语言中创建一个对象使用的关键字是（）</h2><p>A.class<br>B.interface<br>C.new<br>D.create</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>没有对象怎么办，new一个对象 </p><h2 id="4-Java-Application-Java-应用程序-源程序文件编译后的字节码文件的扩展名是-。"><a href="#4-Java-Application-Java-应用程序-源程序文件编译后的字节码文件的扩展名是-。" class="headerlink" title="4.Java Application(Java 应用程序)源程序文件编译后的字节码文件的扩展名是(    )。"></a>4.Java Application(Java 应用程序)源程序文件编译后的字节码文件的扩展名是(    )。</h2><p>A.java<br>B.class<br>C.exe<br>D.jar</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>1， Java文件经过JVM编译成字节码文件，即.class文件，将字节码文件在不同的操作系统中运行时，操作系统再将字节码文件编译成机器码文件。这就是Java跨平台<br>2， JAR 文件就是 Java Archive File，顾名思意，它的应用是与 Java 息息相关的，是 Java 的一种文档格式。JAR 文件非常类似 ZIP 文件——准确的说，它就是 ZIP 文件，所以叫它文件包。JAR 文件与 ZIP 文件唯一的区别就是在 JAR 文件的内容中，包含了一个 META-INF/MANIFEST.MF 文件，这个文件是在生成 JAR 文件的时候自动创建的</p><h2 id="5-以下多线程对int型变量x的操作，哪几个不需要进行同步（-）"><a href="#5-以下多线程对int型变量x的操作，哪几个不需要进行同步（-）" class="headerlink" title="5.以下多线程对int型变量x的操作，哪几个不需要进行同步（  ）?"></a>5.以下多线程对int型变量x的操作，哪几个不需要进行同步（  ）?</h2><p>A.x=y;<br>B.x++;<br>C.++x;<br>D.x=1;</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>原子性：指该操作不能再继续划分为更小的操作。<br>Java中的原子操作包括：<br>    1、除long和double之外的基本类型的赋值操作<br>    2、所有引用reference的赋值操作<br>    3、java.concurrent.Atomic.* 包中所有类的一切操作</p><h2 id="6-有这么一段程序："><a href="#6-有这么一段程序：" class="headerlink" title="6.有这么一段程序："></a>6.有这么一段程序：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test&#123; </span><br><span class="line">    public String name&#x3D;&quot;abc&quot;; </span><br><span class="line">    public static void main(String[] args)&#123; </span><br><span class="line">        Test test&#x3D;new Test(); </span><br><span class="line">        Test testB&#x3D;new Test(); </span><br><span class="line">        System.out.println(test.equals(testB)+&quot;,&quot;+test.name.equals(testB.name)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问以上程序执行的结果是（） ?</p><p>A.true,true<br>B.true,false<br>C.false,true<br>D.false,false</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong></p><h2 id="7-下列描述中，错误的是"><a href="#7-下列描述中，错误的是" class="headerlink" title="7.下列描述中，错误的是"></a>7.下列描述中，错误的是</h2><p>A.SQL语言又称为结构化查询语言<br>B.java中”static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问<br>C.面向对象开发中，引用传递意味着传递的并不是实际的对象，而是对象的引用，因此，外部对引用对象所做的改变不会反映到所引用的对象上<br>D.java是强类型语言，javascript是弱类型语言<br>E.面向对象的三大特性包括：封装，继承，多态</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>值传递，传递的是原来值的副本。<br>引用传递，除了一些特殊的（String，包装类属于不可变类），一般的引用类型在进行传递的时候，一开始形参和实参都是指向同一个地址的，这个时候形参对对象的改变会影响到实参。 </p><h2 id="8-能单独和finally语句一起使用的块是"><a href="#8-能单独和finally语句一起使用的块是" class="headerlink" title="8.能单独和finally语句一起使用的块是(  )"></a>8.能单独和finally语句一起使用的块是(  )</h2><p>A.try<br>B.catch<br>C.throw<br>D.throws</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>处理异常常用的两种方式：<br>1、try…catch(捕获处理机制)；<br>2、throws(冒泡处理机制).<br>注意细节：使用try…catch块捕获时可以没有catch块,但当没用catch块的时候必须得有finally块.故选A）</p><h2 id="9-关于修饰语的使用，以下哪一项是正确的-（）"><a href="#9-关于修饰语的使用，以下哪一项是正确的-（）" class="headerlink" title="9.关于修饰语的使用，以下哪一项是正确的? （）"></a>9.关于修饰语的使用，以下哪一项是正确的? （）</h2><p>A.如果没有为成员声明指定可访问性修饰符（public，protected和private），则该成员只能访问其类的包中的类及其类的子类的任何位置<br>B.您无法指定局部变量的可访问性。它们只能在声明它们的区域内访问<br>C.类的子类必须与它们扩展的类位于同一个包中D)上面提到的都不是</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>没有被public，protected，private修饰的类成员，只有同一个包里的类中可以访问，其余都不行；</p><h2 id="10-代码行float-t-5-1-int-i-t-不正确的是"><a href="#10-代码行float-t-5-1-int-i-t-不正确的是" class="headerlink" title="10.代码行float t=5.1; int i=t; ,不正确的是"></a>10.代码行float t=5.1; int i=t; ,不正确的是</h2><p>A.代码不能编译<br>B.代码编译, i被设置为5<br>C.第二行若改为 int i=(byte)t ，并结合D选项，则可编译<br>D.第一行若改为 float t=5.1f ，并结合C选项，则可编译</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>题目要求是不正确的</p><h2 id="11-以下代码的输出的正确结果是"><a href="#11-以下代码的输出的正确结果是" class="headerlink" title="11.以下代码的输出的正确结果是()"></a>11.以下代码的输出的正确结果是()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">String s &#x3D; &quot;祝你考出好成绩！&quot;;</span><br><span class="line">System.out.println(s.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.24<br>B.16<br>C.15<br>D.8</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>略</p><h2 id="12-与其等价表示是哪一项（）？"><a href="#12-与其等价表示是哪一项（）？" class="headerlink" title="12.与其等价表示是哪一项（）？"></a>12.与其等价表示是哪一项（）？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IService &#123;</span><br><span class="line">String NAME&#x3D;&quot;default&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.public String NAME=”default”;<br>B.public static String NAME=”default”;<br>C.private String NAME=”default”;<br>D.public static final String NAME=”default”;</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>为什么是public：因为接口必然是要被实现的，如果不是public，这个属性就没有意义了；<br>为什么是static：因为如果不是static，那么由于每个类可以继承多个接口，那就会出现重名的情况；<br>为什么是final：这是为了体现java的开闭原则，因为接口是一种模板，既然是模板，那就对修改关闭，对扩展开放。</p><h2 id="13-下列关于包（package）的描述，正确的是（）"><a href="#13-下列关于包（package）的描述，正确的是（）" class="headerlink" title="13.下列关于包（package）的描述，正确的是（）"></a>13.下列关于包（package）的描述，正确的是（）</h2><p>A.包（package）是Java中描述操作系统对多个源代码文件组织的一种方式。<br>B.import语句将所对应的Java源文件拷贝到此处执行。<br>C.包（package）是Eclipse组织Java项目特有的一种方式。<br>D.定义在同一个包（package）内的类可以不经过import而直接相互使用。</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>1、为了更好地组织类，Java提供了包机制。包是类的容器，用于分隔类名空间。如果没有指定包名，所有的示例都属于一个默认的无名包。Java中的包一般均包含相关的类，java是跨平台的，所以java中的包和操作系统没有任何关系，java的包是用来组织文件的一种虚拟文件系统。A错<br>2、import语句并没有将对应的java源文件拷贝到此处仅仅是引入，告诉编译器有使用外部文件，编译的时候要去读取这个外部文件。B错<br>3、Java提供的包机制与IDE没有关系。C错<br>4、定义在同一个包（package）内的类可以不经过import而直接相互使用。</p><h2 id="14-Java中用正则表达式截取字符串中第一个出现的英文左括号之前的字符串。比如：北京市（海淀区）（朝阳区）（西城区），截取结果为：北京市。正则表达式为（）"><a href="#14-Java中用正则表达式截取字符串中第一个出现的英文左括号之前的字符串。比如：北京市（海淀区）（朝阳区）（西城区），截取结果为：北京市。正则表达式为（）" class="headerlink" title="14.Java中用正则表达式截取字符串中第一个出现的英文左括号之前的字符串。比如：北京市（海淀区）（朝阳区）（西城区），截取结果为：北京市。正则表达式为（）"></a>14.Java中用正则表达式截取字符串中第一个出现的英文左括号之前的字符串。比如：北京市（海淀区）（朝阳区）（西城区），截取结果为：北京市。正则表达式为（）</h2><p>A.”.<em>?(?=\()”<br>B.”.</em>?(?=()”<br>C.”.<em>(?=\()”<br>D.”.</em>(?=()”</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>略，个人公众号中有对正则表达式的详细介绍。</p><h2 id="15-以下代码段执行后的输出结果为（）？"><a href="#15-以下代码段执行后的输出结果为（）？" class="headerlink" title="15.以下代码段执行后的输出结果为（）？"></a>15.以下代码段执行后的输出结果为（）？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(test());</span><br><span class="line">    &#125;</span><br><span class="line">    private static int test() &#123;</span><br><span class="line">    int temp &#x3D; 1;</span><br><span class="line">    try &#123;</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">    return ++temp;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">    return ++temp;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    ++temp;</span><br><span class="line">    System.out.println(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>A.1,2,2<br>B.1,2,3<br>C.1,3,3<br>D.1,3,2</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>执行顺序为：<br>输出try里面的初始temp：1；<br>temp=2；<br>保存return里面temp的值：2；<br>执行finally的语句temp：3，输出temp：3；<br>返回try中的return语句，返回存在里面的temp的值：2；<br>输出temp：2</p><h2 id="16-检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。"><a href="#16-检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。" class="headerlink" title="16.检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。"></a>16.检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package algorithms.com.guan.javajicu; </span><br><span class="line">public class Inc &#123; </span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">       Inc inc &#x3D; new Inc(); </span><br><span class="line">       int i &#x3D; 0; </span><br><span class="line">       inc.fermin(i); </span><br><span class="line">       i&#x3D; i ++; </span><br><span class="line">       System.out.println(i);</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">    void fermin(int i)&#123; </span><br><span class="line">       i++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.0<br>B.1<br>C.2<br>D.3</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>这道题两个考点：<br>1.值传递与引用传递的区别<br>2.i++与++i的区别</p><p>关于第一点：<br>int基本类型属于值传递。所以i的值并没有发生改变。i还是为0</p><p>关于第二点：Java使用了中间缓存变量机制：<br>i=i++;等同于：<br>temp=i； (等号右边的i)<br>i=i+1;      (等号右边的i)<br>i=temp;   (等号左边的i)<br>而i=++i;则等同于：<br>i=i+1;<br>temp=i;<br>i=temp;</p><p>如果将代码中的 i= ++i;可以看到打印的结果是1.</p><h2 id="17-下面程序执行的结果为（-）"><a href="#17-下面程序执行的结果为（-）" class="headerlink" title="17.下面程序执行的结果为（  ）"></a>17.下面程序执行的结果为（  ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main( )</span><br><span class="line">&#123;</span><br><span class="line">char ch1,ch2;</span><br><span class="line"></span><br><span class="line">ch1 &#x3D;&#39;D&#39;+&#39;8&#39;－&#39;3&#39;;</span><br><span class="line">ch2 &#x3D;&#39;9&#39;－&#39;1&#39;;</span><br><span class="line"></span><br><span class="line">printf(&quot;%c %d\n&quot;,ch1,ch2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.I ‘8’<br>B.I 8<br>C.G ‘8’<br>D.其他几项都不对</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>c语言的题目，ASCII值的运算，A=65,0=48（以此类推）。ch1=68+56-51=73然后以char类型输出所以是I，ch2=57-49=8以整型输出所以是8 </p><h2 id="18-CMS垃圾回收器在那些阶段是没用用户线程参与的"><a href="#18-CMS垃圾回收器在那些阶段是没用用户线程参与的" class="headerlink" title="18.CMS垃圾回收器在那些阶段是没用用户线程参与的"></a>18.CMS垃圾回收器在那些阶段是没用用户线程参与的</h2><p>A.初始标记<br>B.并发标记<br>C.重新标记<br>D.并发清理</p><p><strong>答案：</strong><br>AC</p><p><strong>解析：</strong><br>用户线程（user-level threads）指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。<br>CMS的GC过程有6个阶段（4个并发，2个暂停其它应用程序）</p><ol><li>初次标记(STW initial mark)</li><li>并发标记(Concurrent marking)</li><li>并发可中断预清理(Concurrent precleaning)</li><li>最终重新标记(STW remark)</li><li>并发清理(Concurrent sweeping)</li><li>并发重置(Concurrent reset)<br>在初次标记，重新标志的时候，要求我们暂停其它应用程序，那么这两个阶段用户线程是不会参与的</li></ol><h2 id="19-下列哪些操作会使线程释放锁资源？"><a href="#19-下列哪些操作会使线程释放锁资源？" class="headerlink" title="19.下列哪些操作会使线程释放锁资源？"></a>19.下列哪些操作会使线程释放锁资源？</h2><p>A.sleep()<br>B.wait()<br>C.join()<br>D.yield()</p><p><strong>答案：</strong><br>B C</p><p><strong>解析：</strong><br><strong>1.sleep()方法</strong><br>在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。<br>sleep()使当前线程进入阻塞状态，在指定时间内不会执行。<br><strong>2.wait()方法</strong><br>在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。<br>当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。<br>唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。<br>waite()和notify()必须在synchronized函数或synchronized　block中进行调用。如果在non-synchronized函数或non-synchronized　block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。<br><strong>3.yield方法 **<br>暂停当前正在执行的线程对象。<br>yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。<br>yield()只能使同优先级或更高优先级的线程有执行的机会。<br>**4.join方法</strong><br>等待该线程终止。<br>等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</p><h2 id="20-Which-statement-declares-a-variable-a-which-is-suitable-for-referring-to-an-array-of-50-string-objects-（Java）"><a href="#20-Which-statement-declares-a-variable-a-which-is-suitable-for-referring-to-an-array-of-50-string-objects-（Java）" class="headerlink" title="20.Which statement declares a variable a which is suitable for referring to an array of 50 string objects?（Java）"></a>20.Which statement declares a variable a which is suitable for referring to an array of 50 string objects?（Java）</h2><p>A.char a[][];<br>B.String a[]<br>C.String[] a;<br>D.Object a[50];<br>E.String a[50];<br>F.Object a[];</p><p><strong>答案：</strong><br>BCF</p><p><strong>解析：</strong></p><p>题目翻译：下面哪个语句声明了一个适合于创建50个字符串对象数组的变量？ </p><p>A：char[][] 定义了二位字符数组。在Java中，使用字符串对char数组赋值，必须使用toCharArray()方法进行转换。所以A错误。<br>B、C：在Java中定义String数组，有两种定义方式：String a[]和String[] a。所以B、C正确。<br>D、E：数组是一个引用类型变量 ，因此使用它定义一个变量时，仅仅定义了一个变量 ，这个引用变量还未指向任何有效的内存 ，因此定义数组不能指定数组的长度。所以D、E错误。<br>F：Object类是所有类的父类。子类其实是一种特殊的父类，因此子类对象可以直接赋值给父类引用变量，无须强制转换，这也被称为向上转型。这体现了多态的思想。所以F正确。</p><p>最后选B、C、F</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">大厂笔试内容集合（内有详细解析）</a> 持续更新中….</p><p><a href="https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21" target="_blank" rel="noopener">ProcessOn是一个在线作图工具的聚合平台~</a></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><p>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-4de06ca864a2d3dd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（十六）</title>
      <link href="/2019/10/04/interview/java/B-bishi16/"/>
      <url>/2019/10/04/interview/java/B-bishi16/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-449fb830889c9a1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（十六）"></p><h2 id="1-所谓静态链表就是一直不发生变化的链表"><a href="#1-所谓静态链表就是一直不发生变化的链表" class="headerlink" title="1.所谓静态链表就是一直不发生变化的链表()"></a>1.所谓静态链表就是一直不发生变化的链表()</h2><p>A.对<br>B.错</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>静态链表，数组描述的链表。也有插入和删除操作</p><h2 id="2-哈希函数越复杂越好-因为这样随机性好-冲突概率小"><a href="#2-哈希函数越复杂越好-因为这样随机性好-冲突概率小" class="headerlink" title="2.哈希函数越复杂越好,因为这样随机性好,冲突概率小()"></a>2.哈希函数越复杂越好,因为这样随机性好,冲突概率小()</h2><p>A.对<br>B.错</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>哈希函数越复杂，则时间就会越多，因此不是哈希函数越复杂越好，还需要考虑下时间方面 </p><h2 id="3-二叉树中每个结点有两棵非空子树或有两棵空子树（）。"><a href="#3-二叉树中每个结点有两棵非空子树或有两棵空子树（）。" class="headerlink" title="3.二叉树中每个结点有两棵非空子树或有两棵空子树（）。"></a>3.二叉树中每个结点有两棵非空子树或有两棵空子树（）。</h2><p>A.对<br>B.错</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>二叉树中每个结点有：①两棵非空子树；②两棵空子树；③一棵子树。</p><h2 id="4-关系模型中，一个关键字是-（-）。"><a href="#4-关系模型中，一个关键字是-（-）。" class="headerlink" title="4.关系模型中，一个关键字是 （  ）。"></a>4.关系模型中，一个关键字是 （  ）。</h2><p>A.可由多个任意属性组成 性组<br>B.至多由一个属性组成<br>C.可由一个或多个其值能惟一标识该关系模式中任何元组的属性组成<br>D.以上都不是</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>数据库关键字可由一个或多个其值能唯一标示该关系模式中任何元组的属性组成 </p><h2 id="5-完全二叉树中编号为-i-的结点存在右孩子，右孩子结点的编号为-。设根结点的编号为-1"><a href="#5-完全二叉树中编号为-i-的结点存在右孩子，右孩子结点的编号为-。设根结点的编号为-1" class="headerlink" title="5.完全二叉树中编号为 i 的结点存在右孩子，右孩子结点的编号为()。设根结点的编号为 1"></a>5.完全二叉树中编号为 i 的结点存在右孩子，右孩子结点的编号为()。设根结点的编号为 1</h2><p>A.2i-1<br>B.2i<br>C.2i+1<br>D.2i+2</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>左孩子2i 右孩子2i+1, C</p><h2 id="6-限制输入到列的值的范围，应使用（-）约束。"><a href="#6-限制输入到列的值的范围，应使用（-）约束。" class="headerlink" title="6.限制输入到列的值的范围，应使用（  ）约束。"></a>6.限制输入到列的值的范围，应使用（  ）约束。</h2><p>A.CHECK<br>B.PRIMARY KEY<br>C.FOREIGN KEY<br>D.UNIQUE</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>数据库的检查约束，可以在插入值的时候检查是否符合设定的取值区域 </p><h2 id="7-深度为k的二叉树至多有几个结点（）"><a href="#7-深度为k的二叉树至多有几个结点（）" class="headerlink" title="7.深度为k的二叉树至多有几个结点（）"></a>7.深度为k的二叉树至多有几个结点（）</h2><p>A.2^k<br>B.2^(k-1)<br>C.2^k-1<br>D.2^k+1</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。<br>这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。<br>具有n个节点的完全二叉树的深度为floor(log2n)+1。<br>深度为k的完全二叉树，至少有2k-1个叶子节点，至多有2k-1个节点。</p><h2 id="8-事务日志的用途是？"><a href="#8-事务日志的用途是？" class="headerlink" title="8.事务日志的用途是？"></a>8.事务日志的用途是？</h2><p>A.事务处理<br>B.完整性约束<br>C.数据恢复<br>D.安全性控制</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>SQL Server使用各数据库的事务日志来恢复事务。<br>事务日志是数据库中已发生的所有修改和执行每次修改的事务的一连串记录。事务日志记录每个事务的开始。它记录了在每个事务期间，对数据的更改及撤消所做更改（以后如有必要）所需的足够信息。<br>主要是恢复时用到数据，所以对日志文件不能轻易删除！</p><h2 id="9-如果一个堆栈的入栈序列是A-B-C-D-E-则堆栈的不可能输出顺序是（）。"><a href="#9-如果一个堆栈的入栈序列是A-B-C-D-E-则堆栈的不可能输出顺序是（）。" class="headerlink" title="9.如果一个堆栈的入栈序列是A,B,C,D,E,则堆栈的不可能输出顺序是（）。"></a>9.如果一个堆栈的入栈序列是A,B,C,D,E,则堆栈的不可能输出顺序是（）。</h2><p>A.EDCBA<br>B.DECBA<br>C.DCEAB<br>D.ABCDE</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>A 可行，ABCDE依次入栈，然后再依次出栈<br>B 可行，A入栈，B入栈，C入栈，D入栈，D出栈，E入栈，E出栈，CBA依次出栈<br>C 不可行，A入栈，B入栈，C入栈，D入栈，D出栈，C出栈，E入栈，E出栈，此时只能B先出栈，得不到AB<br>D 可行，A入栈，A出栈，B入栈，B出栈，C入栈，C出栈，D入栈，D出栈，E入栈，E出栈</p><h2 id="10-根据关系数据库规范范理论，关系数据库中的关系要满足第一范式，在部门关系中，因哪个属性而使它不满足第一范式？（）"><a href="#10-根据关系数据库规范范理论，关系数据库中的关系要满足第一范式，在部门关系中，因哪个属性而使它不满足第一范式？（）" class="headerlink" title="10.根据关系数据库规范范理论，关系数据库中的关系要满足第一范式，在部门关系中，因哪个属性而使它不满足第一范式？（）"></a>10.根据关系数据库规范范理论，关系数据库中的关系要满足第一范式，在部门关系中，因哪个属性而使它不满足第一范式？（）</h2><p>A.部门号<br>B.部门名<br>C.部门总经理<br>D.部门成员</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>针对数据库范式的理解，可以关注我的公众号<strong>Coder编程</strong>，其中就有文章详细介绍了数据库的三范式。</p><h2 id="11-把对关系SC的属性GRADE的修改权授予用户ZHAO的T-SQL语句是（）"><a href="#11-把对关系SC的属性GRADE的修改权授予用户ZHAO的T-SQL语句是（）" class="headerlink" title="11.把对关系SC的属性GRADE的修改权授予用户ZHAO的T-SQL语句是（）"></a>11.把对关系SC的属性GRADE的修改权授予用户ZHAO的T-SQL语句是（）</h2><p>A.GRANT GRADE ON SC TO ZHAO<br>B.GRANT UPDATE ON SC TO ZHAO<br>C.GRANT UPDATE (GRADE) ON SC TO ZHAO<br>D.GRANT UPDATE ON SC (GRADE) TO ZHAO</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>GRANT UPDATE (COLUMN_NAME) ON TABLE_NAME TO USER_NAME </p><h2 id="12-由计算机、操作系统、-DBMS-、数据库、应用程序及用户等组成的一个整体叫做-。"><a href="#12-由计算机、操作系统、-DBMS-、数据库、应用程序及用户等组成的一个整体叫做-。" class="headerlink" title="12. 由计算机、操作系统、 DBMS 、数据库、应用程序及用户等组成的一个整体叫做 ( ) 。"></a>12. 由计算机、操作系统、 DBMS 、数据库、应用程序及用户等组成的一个整体叫做 ( ) 。</h2><p>A.文件系统<br>B.数据库系统<br>C.软件系统<br>D.数据库管理系统</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>数据库系统：数据库、数据库管理系统、硬件、操作人员的合在一起的总称。<br>数据库管理系统：用来管理数据及数据库的系统。<br>数据库系统包含数据库管理系统、数据库及数据库开发工具所开发的软件（数据库应用系统）</p><h2 id="13-以下正确定义一维数组的选项是"><a href="#13-以下正确定义一维数组的选项是" class="headerlink" title="13.以下正确定义一维数组的选项是(   )"></a>13.以下正确定义一维数组的选项是(   )</h2><p>A.int a[5] = {0, 1, 2, 3, 4, 5};<br>B.char a[] = {0, 1, 2, 3, 4, 5};<br>C.char a = {‘A’, ‘B’, ‘C’};<br>D.int a[5] = “0123”;</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>【A】数组越界。所以错误。 【B】声明char类型，传入了数值数组，而数值会以char类型的ASCII编码写入。所以正确。<br>【C】数组声没明显不符合规范，左侧声明名后应加上[]。所以错误。 【D】这种声名只能用字符型char等。所以错误。 </p><h2 id="14-具有-n-个结点的连通图至少有（）条边？"><a href="#14-具有-n-个结点的连通图至少有（）条边？" class="headerlink" title="14. 具有 n 个结点的连通图至少有（）条边？"></a>14. 具有 n 个结点的连通图至少有（）条边？</h2><p>A.n-1<br>B.n<br>C.n(n-1)/2<br>D.2n</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>具有 n 个结点的无向连通图至少有 n-1 条边<br>具有 n 个结点的有向连通图至少有 n 条边。</p><h2 id="15-MYSQL实现主从复制的日志是哪种？"><a href="#15-MYSQL实现主从复制的日志是哪种？" class="headerlink" title="15.MYSQL实现主从复制的日志是哪种？"></a>15.MYSQL实现主从复制的日志是哪种？</h2><p>A.READ LOG<br>B.UNDO LOG<br>C.BINLOG<br>D.GENERAL LOG</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>MySQL5.6开始主从复制有两种方式：基于日志（binlog）；基于GTID（全局事务标示符）</p><h2 id="16-给出数据表-score-stu-id-name-math-english-Chinese-下列语句正确的是（-）"><a href="#16-给出数据表-score-stu-id-name-math-english-Chinese-下列语句正确的是（-）" class="headerlink" title="16. 给出数据表 score(stu-id,name,math,english,Chinese), 下列语句正确的是（ ）"></a>16. 给出数据表 score(stu-id,name,math,english,Chinese), 下列语句正确的是（ ）</h2><p>A.Select sum(math),avg(chinese) from score<br>B.Select *,sum(english) from score<br>C.Select stu-id, sum(math) from score<br>D.Delete * from score</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>B中对英语成绩求和，无法再与id 名字 其他成绩进行一一对应，因此无法这样选择<br>C中同样对数学成绩求和后无法与id一一对应不能这样选择<br>D删除整个表可以用delete table score，无该用法 </p><h2 id="17-已知二叉树后序遍历序列是dabec，中序遍历序列是debac，它的前序遍历序列是（）"><a href="#17-已知二叉树后序遍历序列是dabec，中序遍历序列是debac，它的前序遍历序列是（）" class="headerlink" title="17.已知二叉树后序遍历序列是dabec，中序遍历序列是debac，它的前序遍历序列是（）"></a>17.已知二叉树后序遍历序列是dabec，中序遍历序列是debac，它的前序遍历序列是（）</h2><p>A.cedba<br>B.cedab<br>C.cebad<br>D.cebda</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>可以关注我的公众号<strong>Coder编程</strong>，里面有前中后遍历序列的相关文章。</p><h2 id="18-The-initial-insert-of-new-data-into-the-table-will-leave-most-of-its-large-columns-NULL-to-be-filled-in-later-by-subsequent-updates-记录重未更新-PCTFREE-和-PCTUSED取值多少合适？"><a href="#18-The-initial-insert-of-new-data-into-the-table-will-leave-most-of-its-large-columns-NULL-to-be-filled-in-later-by-subsequent-updates-记录重未更新-PCTFREE-和-PCTUSED取值多少合适？" class="headerlink" title="18.The initial insert of new data into the table will leave most of its large columns NULL, to be filled in later by subsequent updates.记录重未更新. PCTFREE 和 PCTUSED取值多少合适？"></a>18.The initial insert of new data into the table will leave most of its large columns NULL, to be filled in later by subsequent updates.记录重未更新. PCTFREE 和 PCTUSED取值多少合适？</h2><p>A.PCTUSED = 99， PCTFREE = 1<br>B.PCTUSED = 40， PCTFREE = 30<br>C.PCTUSED = 40， PCTFREE = 10<br>D.PCTUSED = 80， PCTFREE = 10</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>（1）PCTFREE：为一个块保留的空间百分比，表示数据块在什么情况下可以被insert。<br>（2）PCTUSED：是指当块里的数据低于多少百分比时，又可以重新被insert。<br>形象举例说明：<br>假如：一个杯子一共可装10分水:<br>PCTFREE = 10,说明杯子装到9分水，就不能再装了，即:不能进行insert操作，但可以进行update操作。<br>PCTUSED = 40，说明杯子中的水喝到4分一下，就可以往里面装水，即：进行insert操作。<br>可是为什么是40和30？ pctfree这个参数定义了一个块保留空间的百分比，保留空间是为了将来可能发生的更新操作，因为更新可能增大被更新行占用的空间，如果此时该块没有可利用空间，那么只有发生row migrate了，从而会降低I/O性能。换句话说，就是当一个块的利用率达到1-pctfree的时候，oracle就将该块从freelist中移除，不再向该块插入数据。所以说pctfree是控制什么时候将块从freelist中移除的。 pctused这个参数控制一个块什么时候被重新启用来插入数据，例如当一个块达到1-pctfree利用率的时候，oracle停止向该块插入数据，同时从freelist移除该块，但是后来发生一些删除操作，使得该块的利用率下降，当该块的利用率降到pctused以下的时候该块就被重新启用来插入数据了，也即是将该块重新加入到freelist列表中，所以说pctused是控制什么时候将一个块重新加入freelist的。 举个例子：比如一个块的pctfree定为10%，pctused定为40%（oracle默认设置）。那么一个块的使用率达到90%（即1-10%）的时候，oracle将该块从freelist中移除，停止使用该块来插入数据（但可更新）。后来该块上发生了一些删除操作，使得该块的利用率下降，当使用率下降到40%以下的时候，oracle重新将该块加入freelist，可用于新的插入。 </p><h2 id="19-java8中，下面哪个类用到了解决哈希冲突的开放定址法"><a href="#19-java8中，下面哪个类用到了解决哈希冲突的开放定址法" class="headerlink" title="19.java8中，下面哪个类用到了解决哈希冲突的开放定址法"></a>19.java8中，下面哪个类用到了解决哈希冲突的开放定址法</h2><p>A.LinkedHashSet<br>B.HashMap<br>C.ThreadLocal<br>D.TreeMap</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。之所以采用不同的方式主要是因为：在ThreadLocalMap中的散列值分散得十分均匀，很少会出现冲突。并且ThreadLocalMap经常需要清除无用的对象，使用纯数组更加方便。</p><h2 id="20-关于链表，正确的是（）"><a href="#20-关于链表，正确的是（）" class="headerlink" title="20.关于链表，正确的是（）"></a>20.关于链表，正确的是（）</h2><p>A.无需实现估计空间<br>B.支持随机访问<br>C.增删不必挪动元素<br>D.所需空间与线性表长度成正比，并且地址连续<br>E.插入一个元素所需挪动元素的平均个数为n/2</p><p><strong>答案：</strong><br>A C</p><p><strong>解析：</strong><br>链表是一种物理存储单元上非连续、非顺序的存储结构。每一个节点里会存到下一个节点的指针。 </p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">笔试内容集合</a> 持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><p>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-d657acba3b732c0a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（十五）</title>
      <link href="/2019/10/03/interview/java/B-bishi15/"/>
      <url>/2019/10/03/interview/java/B-bishi15/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-add3077dc420af1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（十五）"></p><h2 id="1-有以下代码片段-请问输出的结果是"><a href="#1-有以下代码片段-请问输出的结果是" class="headerlink" title="1. 有以下代码片段,请问输出的结果是()?"></a>1. 有以下代码片段,请问输出的结果是()?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1&#x3D;&quot;hello&quot;;</span><br><span class="line">String str2&#x3D;&quot;he&quot;+ new String(&quot;llo&quot;);</span><br><span class="line">System.out.println(str1&#x3D;&#x3D;str2);</span><br></pre></td></tr></table></figure><p>A.true<br>B.都不对<br>C.null<br>D.false</p><p><strong>答案：</strong><br>D   </p><p><strong>解析：</strong><br>String str1=”hello”;    这样创建字符串是存在于常量池中<br>String str2=new String(“hello”);    str2存在于堆中，<br>==是验证两个对象是否是一个（内存地址是否相同）<br>用+拼接字符串时会创建一个新对象再返回。 </p><h2 id="2-在如下所示的类Test中，共有（）个构造方法。"><a href="#2-在如下所示的类Test中，共有（）个构造方法。" class="headerlink" title="2.在如下所示的类Test中，共有（）个构造方法。"></a>2.在如下所示的类Test中，共有（）个构造方法。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    private int x;</span><br><span class="line">    public Test()&#123;</span><br><span class="line">        x &#x3D; 35;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Test(double f)&#123;</span><br><span class="line">        this.x &#x3D; (int)f;</span><br><span class="line">    &#125;</span><br><span class="line">    public Test(double f)&#123;</span><br><span class="line">        this.x &#x3D; (int)f;</span><br><span class="line">    &#125;</span><br><span class="line">    public Test(String s) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.0<br>B.1<br>C.2<br>D.3</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>构造方法形式:<br>类名([形式参数表])<br>构造方法没有返回值，不能添加void，构造方法可以被重载 </p><h2 id="3-一个以”-java”为后缀的源文件"><a href="#3-一个以”-java”为后缀的源文件" class="headerlink" title="3.一个以”.java”为后缀的源文件"></a>3.一个以”.java”为后缀的源文件</h2><p>A.只能包含一个类，类名必须与文件名相同<br>B.只能包含与文件名相同的类以及其中的内部类<br>C.只能有一个与文件名相同的类，可以包含其他类<br>D.可以包含任意类</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>略，前面都做过的- -!</p><h2 id="4-下面哪些不是Thread类的方法"><a href="#4-下面哪些不是Thread类的方法" class="headerlink" title="4.下面哪些不是Thread类的方法"></a>4.下面哪些不是Thread类的方法</h2><p>A.start()<br>B.run()<br>C.exit()<br>D.getPriority()</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>线程常用方法：<br>start()： 使该线程开始执行；Java 虚拟机调用该线程的run方法。<br>run()：如果该线程是使用独立的Runnable运行对象构造的，则调用该Runnable对象的run方法；否则，该方法不执行任何操作并返回。<br>join()：等待该线程终止。<br>getPriority()：返回线程的优先级。<br>yield()：暂停当前正在执行的线程对象，并执行其他线程</p><h2 id="5-关于-JAVA-堆-下面说法错误的是"><a href="#5-关于-JAVA-堆-下面说法错误的是" class="headerlink" title="5.关于 JAVA 堆,下面说法错误的是()"></a>5.关于 JAVA 堆,下面说法错误的是()</h2><p>A.所有类的实例和数组都是在堆上分配内存的<br>B.对象所占的堆内存是由自动内存管理系统回收<br>C.堆内存由存活和死亡的对象,空闲碎片区组成<br>D.数组是分配在栈中的</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong></p><ol><li>对象存储在堆区。</li><li>数组是一种对象。</li></ol><h2 id="6-一个文件中的字符要写到另一个文件中，首先需要（-）。"><a href="#6-一个文件中的字符要写到另一个文件中，首先需要（-）。" class="headerlink" title="6.一个文件中的字符要写到另一个文件中，首先需要（ ）。"></a>6.一个文件中的字符要写到另一个文件中，首先需要（ ）。</h2><p>A.使用标准输出流System.out.println()。<br>B.建立文件字符输出流。<br>C.建立文件字符输入流。<br>D.标准输入流System.in.read()。</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>一个文件中的字符要写到另一个文件中，首先需要读取这个文件,所以要先建立输入流,然后写到另一个文件,这时再建立输出流.所以要先建立输入流,再建立输出流.</p><h2 id="7-尝试编译以下程序会产生怎么样的结果？（）"><a href="#7-尝试编译以下程序会产生怎么样的结果？（）" class="headerlink" title="7.尝试编译以下程序会产生怎么样的结果？（）"></a>7.尝试编译以下程序会产生怎么样的结果？（）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">    long var;</span><br><span class="line">    public void MyClass(long param) &#123; var &#x3D; param; &#125;&#x2F;&#x2F;(1)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyClass a, b;</span><br><span class="line">        a &#x3D;new MyClass();&#x2F;&#x2F;(2)</span><br><span class="line">        b &#x3D;new MyClass(5);&#x2F;&#x2F;(3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.编译错误将发生在（1），因为构造函数不能指定返回值<br>B.编译错误将发生在（2），因为该类没有默认构造函数<br>C.编译错误将在（3）处发生，因为该类没有构造函数，该构造函数接受一个int类型的参数<br>D.该程序将正确编译和执行</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>构造方法就是：public 类名， 没有方法修饰符,所以 (1)  处就是一个普通方法,所以该类没有带参数构造方法 ，编译报错</p><h2 id="8-下面叙述那个是正确的？（）"><a href="#8-下面叙述那个是正确的？（）" class="headerlink" title="8.下面叙述那个是正确的？（）"></a>8.下面叙述那个是正确的？（）</h2><p>A.java中的集合类（如Vector）可以用来存储任何类型的对象，且大小可以自动调整。但需要事先知道所存储对象的类型，才能正常使用。<br>B.在java中，我们可以用违例（Exception）来抛出一些并非错误的消息，但这样比直接从函数返回一个结果要更大的系统开销。<br>C.java接口包含函数声明和变量声明。<br>D.java中，子类不可以访问父类的私有成员和受保护的成员。</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>A.vector是线程安全的ArrayList，在内存中占用连续的空间。初始时有一个初始大小，当数据条数大于这个初始大小后会重写分配一个更大的连续空间。如果Vector定义为保存Object则可以存放任意类型。<br>B.try{}catch{}会增加额外的开销<br>C.接口中声明的’变量’必须为public final static,所以为常量<br>D.子类可以访问父类受保护的成员</p><h2 id="9-下面代码的运行结果是（）"><a href="#9-下面代码的运行结果是（）" class="headerlink" title="9.下面代码的运行结果是（）?"></a>9.下面代码的运行结果是（）?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    String s;</span><br><span class="line">    System.out.println(&quot;s&#x3D;&quot;+s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.代码编程成功，并输出”s=”<br>B.代码编译成功，并输出”s=null”<br>C.由于String s没有初始化，代码不能编译通过。<br>D.代码编译成功，但捕获到NullPointException异常</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>局部变量没有默认值 </p><h2 id="10-代码-的运行结果是（）"><a href="#10-代码-的运行结果是（）" class="headerlink" title="10. 代码 的运行结果是（）?"></a>10. 代码 的运行结果是（）?</h2><p>A.在控制台打印hello sunline！<br>B.报异常java.lang.NullPoninterException<br>C.编译报错<br>D.报异常java.lang.RuntimeExcception</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>1、Java 中单实现通过 implements 关键字，多实现通过 extends 关键字<br>2、Java 中单继承通过 extends 关键字，没有多继承<br>3、如果同时出现继承和实现，则必须先继承（extends）再实现（implements）</p><h2 id="11-由3-个“1”和-5-个“0”组成的-8-位二进制补码，能表示的最小整数（）"><a href="#11-由3-个“1”和-5-个“0”组成的-8-位二进制补码，能表示的最小整数（）" class="headerlink" title="11.由3 个“1”和 5 个“0”组成的 8 位二进制补码，能表示的最小整数（）"></a>11.由3 个“1”和 5 个“0”组成的 8 位二进制补码，能表示的最小整数（）</h2><p>A.-126<br>B.-125<br>C.-32<br>D.-3</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>既然求最小整数，那肯定先想到负数，则最高位（符号位）一定为1，原码中肯定是1所在的位数越高，值越小，而补码是由原码取反加1得到的，则在补码中1所在的位数一定要越低，即补码为1000 0011；由补码求得原码：1111 1101=-(64+32+16+8+4+1)=-125; </p><h2 id="12-运行代码，结果正确的是："><a href="#12-运行代码，结果正确的是：" class="headerlink" title="12.运行代码，结果正确的是：()?"></a>12.运行代码，结果正确的是：()?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Boolean flag &#x3D; false;</span><br><span class="line">if(flag &#x3D; true)&#123;</span><br><span class="line">System.out.println(&quot;true&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;false&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.编译错误<br>B.TRUE<br>C.FALSE<br>D.什么也没有输出</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>if(flag = true)的时候flag已经是true了，所以输出true；<br>要是为if(flag == true)输出才为false </p><h2 id="13-下列哪个选项是合法的标识符？（）"><a href="#13-下列哪个选项是合法的标识符？（）" class="headerlink" title="13.下列哪个选项是合法的标识符？（）"></a>13.下列哪个选项是合法的标识符？（）</h2><p>A.123<br>B._name<br>C.class<br>D.first</p><p><strong>答案：</strong><br>B D</p><p><strong>解析：</strong><br>Java标识符由 数字、字母、下划线(_)、美元符号($) 组成，首位不能是数字 。并且Java关键字不能作为标识符 。 </p><h2 id="14-Why-would-a-responsible-Java-programmer-want-to-use-a-nested-class"><a href="#14-Why-would-a-responsible-Java-programmer-want-to-use-a-nested-class" class="headerlink" title="14.Why would a responsible Java programmer want to use a nested class?"></a>14.Why would a responsible Java programmer want to use a nested class?</h2><p>A.To keep the code for a very specialized class in close association with the class it works with.<br>B.To support a new user interface that generates custom events.<br>C.To impress the boss with his/her knowledge of Java by using nested classes all over the place.</p><p><strong>答案：</strong><br>A B</p><p><strong>解析：</strong><br>使用嵌套类，其中有几个令人信服的理由：<br>加强封装—考虑两个顶级类，A和B，如果B需要访问A的private成员，通过在A类隐藏B类，那么即使A的成员声明为private，那么B也可以访问它们。更多的是，B本身也可以隐藏于外部。跟可读性，可维护性的代码—在顶级类里嵌套小类，让代码更靠近使用的地方。 </p><h2 id="15-下面有关Java的说法正确的是（-）"><a href="#15-下面有关Java的说法正确的是（-）" class="headerlink" title="15.下面有关Java的说法正确的是（  ）"></a>15.下面有关Java的说法正确的是（  ）</h2><p>A.一个类可以实现多个接口<br>B.抽象类必须有抽象方法<br>C.protected成员在子类可见性可以修改<br>D.通过super可以调用父类构造函数<br>E.final的成员方法实现中只能读取类的成员变量<br>F.String是不可修改的，且java运行环境中对string对象有一个对象池保存</p><p><strong>答案：</strong><br>A C D F</p><p><strong>解析：</strong><br>A对：java类单继承，多实现<br>B错：被abstract修饰的类就是抽象类，有没有抽象方法无所谓<br>C错：这道题应该是要考察子类继承父类，并重写父类的protected成员方法，该方法的可见性可以修改，这是对的，因为子类继承父类的方法，访问权限可以相同或往大了改<br>D对。<br>E错：final修饰的方法只是不能重写，static修饰的方法只能访问类的成员变量<br>F对。</p><h2 id="16-下列描述正确的是（-）？"><a href="#16-下列描述正确的是（-）？" class="headerlink" title="16.下列描述正确的是（ ）？"></a>16.下列描述正确的是（ ）？</h2><p>A.类不可以多继承而接口可以多实现<br>B.抽象类自身可以定义成员而接口不可以<br>C.抽象类和接口都不能被实例化<br>D.一个类可以有多个基类和多个基接口</p><p><strong>答案：</strong><br>A C</p><p><strong>解析：</strong><br>1.java支持单继承，却可以实现多个接口。a对d错<br>2.接口没有构造方法，所以不能实例化，抽象类有构造方法，但是不是用来实例化的，是用来初始化的。c对<br>3.抽象类可以定义普通成员变量而接口不可以，但是抽象类和接口都可以定义静态成员变量，只是接口的静态成员变量要用static final public 来修饰。b错</p><h2 id="17-关于下面这段Java程序，哪些描述是正确的：（-）"><a href="#17-关于下面这段Java程序，哪些描述是正确的：（-）" class="headerlink" title="17.关于下面这段Java程序，哪些描述是正确的：（ ）"></a>17.关于下面这段Java程序，哪些描述是正确的：（ ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadTest extends Thread &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;In run&quot;);</span><br><span class="line">yield();</span><br><span class="line">System.out.println(&quot;Leaving run&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String []argv) &#123;</span><br><span class="line">(new ThreadTest()).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.程序运行输出只有In run<br>B.程序运行输出只有Leaving run<br>C.程序运行输出先有In run后有Leaving run<br>D.程序运行输出先有Leaving run后有In run<br>E.程序没有任何输出就退出了<br>F.程序将被挂起，只能强制退出</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。</p><h2 id="18-哪个是不正确的字符常量？"><a href="#18-哪个是不正确的字符常量？" class="headerlink" title="18.哪个是不正确的字符常量？"></a>18.哪个是不正确的字符常量？</h2><p>A.”\n”<br>B.”1”<br>C.”a”<br>D.”\101”</p><p><strong>答案：</strong><br>A B C D</p><p><strong>解析：</strong><br>四个答案都采用的是双引号关闭，所以是字符串常量而不是字符常量。<br>忽略这个错误，那么这题就没有答案，因为无论是采用特殊字符的转移序列’\n’还是采用八进制转义’\101’，都是满足Java语言规范中规定的字符常量格式。 </p><h2 id="19-JDK提供的用于并发编程的同步器有哪些？"><a href="#19-JDK提供的用于并发编程的同步器有哪些？" class="headerlink" title="19.JDK提供的用于并发编程的同步器有哪些？"></a>19.JDK提供的用于并发编程的同步器有哪些？</h2><p>A.Semaphore<br>B.CyclicBarrier<br>C.CountDownLatch<br>D.Counter</p><p><strong>答案：</strong><br> A B C</p><p><strong>解析：</strong><br>A，Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。<br>B，CyclicBarrier 主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。<br>C，直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。<br>D，Counter不是并发编程的同步器</p><h2 id="20-下面关于面向对象的一些理解哪些是错误的-？"><a href="#20-下面关于面向对象的一些理解哪些是错误的-？" class="headerlink" title="20.下面关于面向对象的一些理解哪些是错误的( )？"></a>20.下面关于面向对象的一些理解哪些是错误的( )？</h2><p>A.面向对象的最重要的特性是支持继承、封装和多态<br>B.系统设计应该遵循开闭原则，系统应该稳定不不可修改，但应支持通过继承、组合等方式进行扩展<br>C.函数式的语言必然是面向对象的语言<br>D.面向对象设计时，每个类的职责应该单一，不要再一个类中引入过多的接口<br>E.过程式语言和面向对象的语言各有其优势，过程式语言更加灵活，面向对象语言更加强调抽象和封装<br>F.Java和C++都是静态类型的面向对象编程语言</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。 </p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">笔试内容集合</a> 持续更新中….</p><p><a href="https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21" target="_blank" rel="noopener">ProcessOn是一个在线作图工具的聚合平台~</a></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-66a3884124c8b804?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（十四）</title>
      <link href="/2019/10/02/interview/java/B-bishi14/"/>
      <url>/2019/10/02/interview/java/B-bishi14/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-31086e6d4976788c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（十四）"></p><h2 id="1-Java-语言中，负责并发管理的机制是（-）"><a href="#1-Java-语言中，负责并发管理的机制是（-）" class="headerlink" title="1. Java 语言中，负责并发管理的机制是（ ）"></a>1. Java 语言中，负责并发管理的机制是（ ）</h2><p>A.垃圾回收<br>B.虚拟机<br>C.代码安全<br>D.多线程</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>选项A，Java语言中，垃圾回收机制对系统中不使用的内存进行回收，从而使程序员从繁忙的内存管理中解放出来。<br>选项B，Java编写好的程序首先由编译器转换为标准字节代码，然后由虚拟机执行。虚拟机把字节代码程序与各操作系统和硬件分开，使Java程序独立于平台。<br>选项C，Java的代码安全检测体现在多个层次上，在编译层、解释层、平台层分别作不同的安全检查。<br>选项D，多线程是Java程序的并发机制，它能同步共享数、处理不同的事件。</p><h2 id="2-下列不属于访问控制符的是（）"><a href="#2-下列不属于访问控制符的是（）" class="headerlink" title="2.下列不属于访问控制符的是（）"></a>2.下列不属于访问控制符的是（）</h2><p>A.public<br>B.private<br>C.protected<br>D.static</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>public 公有 private私有 protected受保护<br>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块。   </p><h2 id="3-以下的变量定义语句中，合法的是（）"><a href="#3-以下的变量定义语句中，合法的是（）" class="headerlink" title="3.以下的变量定义语句中，合法的是（）"></a>3.以下的变量定义语句中，合法的是（）</h2><p>A.byte=128<br>B.boolean=null<br>C.long a=123L<br>D.double=0.9239d</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>略</p><h2 id="4-以下哪个不是Collection的子接口？"><a href="#4-以下哪个不是Collection的子接口？" class="headerlink" title="4.以下哪个不是Collection的子接口？"></a>4.以下哪个不是Collection的子接口？</h2><p>A.List<br>B.Set<br>C.SortedSet<br>D.Map</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br><img src="" alt="集合框架图"></p><h2 id="5-在使用super和this关键字时，以下描述正确的是（）"><a href="#5-在使用super和this关键字时，以下描述正确的是（）" class="headerlink" title="5.在使用super和this关键字时，以下描述正确的是（）"></a>5.在使用super和this关键字时，以下描述正确的是（）</h2><p>A.在子类构造方法中使用super（）显示调用父类的构造方法，super（）必须写在子类构造方法的第一行，否则编译不通过<br>B.super（）和this（）不一定要放在构造方法内第一行<br>C.this（）和super（）可以同时出现在一个构造函数中<br>D.this（）和super（）可以在static环境中使用，包括static方法和static语句块</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>使用super()或者this()方法是必须放在构造函数的第一行<br>由于this函数指向的构造函数默认有super()方法，所以规定this()和super()不能同时出现在一个构造函数中。<br>因为staic方法或者语句块没有实例时可以使用，而此时不需要构造实例，所以不能用this()和super() </p><h2 id="6-不考虑反射，String类型变量所指向内存空间中的内容是不能被改变的（-）"><a href="#6-不考虑反射，String类型变量所指向内存空间中的内容是不能被改变的（-）" class="headerlink" title="6. 不考虑反射，String类型变量所指向内存空间中的内容是不能被改变的（ ）"></a>6. 不考虑反射，String类型变量所指向内存空间中的内容是不能被改变的（ ）</h2><p>A.正确<br>B.错误</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>略</p><h2 id="7-如果一个接口Glass有个方法setColor-，有个类BlueGlass实现接口Glass，则在类BlueGlass中正确的是？"><a href="#7-如果一个接口Glass有个方法setColor-，有个类BlueGlass实现接口Glass，则在类BlueGlass中正确的是？" class="headerlink" title="7. 如果一个接口Glass有个方法setColor()，有个类BlueGlass实现接口Glass，则在类BlueGlass中正确的是？  ( )"></a>7. 如果一个接口Glass有个方法setColor()，有个类BlueGlass实现接口Glass，则在类BlueGlass中正确的是？  ( )</h2><p>A.protected void setColor() { …}<br>B.void setColor() { …}<br>C.public void setColor() { …}<br>D.以上语句都可以用在类BlueGlass中</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>JAVA 子类重写继承的方法时,不可以降低方法的访问权限，子类继承父类的访问修饰符要比父类的更大，也就是更加开放，假如我父类是protected修饰的，其子类只能是protected或者public，绝对不能是friendly(默认的访问范围)或者private，当然使用private就不是继承了。还要注意的是，继承当中子类抛出的异常必须是父类抛出的异常的子异常，或者子类抛出的异常要比父类抛出的异常要少。</p><h2 id="8-下列命令中，用来运行-Java-程序的是（）"><a href="#8-下列命令中，用来运行-Java-程序的是（）" class="headerlink" title="8.下列命令中，用来运行 Java 程序的是（）"></a>8.下列命令中，用来运行 Java 程序的是（）</h2><p>A.java<br>B.javadoc<br>C.jar<br>D.javac</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>A.java用来运行一个.class文件<br>B.javadoc用来生成api文档<br>C.jar用来生成jar包<br>D.javac用来把.java文件编译为.class文件</p><h2 id="9-java-语言使用的字符码集是"><a href="#9-java-语言使用的字符码集是" class="headerlink" title="9. java 语言使用的字符码集是"></a>9. java 语言使用的字符码集是</h2><p>A.ASCII<br>B.BCD<br>C.DCB<br>D.Unicode</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>Java语言使用的是Unicode字符集。而ASCII是国际上使用最广泛的字符编码；BCD是一种数字压缩存储编码方法。</p><h2 id="10-如果要建立一个java-scut-computer的包，叙述正确的是？"><a href="#10-如果要建立一个java-scut-computer的包，叙述正确的是？" class="headerlink" title="10. 如果要建立一个java.scut.computer的包，叙述正确的是？( )"></a>10. 如果要建立一个java.scut.computer的包，叙述正确的是？( )</h2><p>A.只需在代码中加入“package java.scut.computer;”一个语句，并且必须放在代码的第一行<br>B.只需在代码中加入“package java.scut;”一个语句<br>C.必须在代码中加入“package java.scut;”和“package java.scut.computer;”两个语句<br>D.在代码中，不一定是第一句，只要是类定义前，加入package语句即可</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>实际上在Java语言规范中，不允许package name以“java”开头，不然会报一个java.lang.SecurityException 的错误。因为假如我们允许包名以java开头，那么我们完全可以编写和jdk标准包下一模一样的类，如Java.lang.Integer。因此在虚拟机进行类或接口解析时可能会发生冲突。一句话总结就是:假如允许包名以java开头，可能会导致命名空间污染的问题。</p><h2 id="11-如下代码的-结果是什么"><a href="#11-如下代码的-结果是什么" class="headerlink" title="11. 如下代码的 结果是什么 ?"></a>11. 如下代码的 结果是什么 ?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">    Base() &#123;</span><br><span class="line">    System.out.print(&quot;Base&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Alpha extends Base &#123;</span><br><span class="line">    public static void main( String[] args ) &#123;</span><br><span class="line">        new Alpha();</span><br><span class="line">        &#x2F;&#x2F;调用父类无参的构造方法</span><br><span class="line">        new Base();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.Base<br>B.BaseBase<br>C.编译失败<br>D.代码运行但没有输出<br>E.运行时抛出异常</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>略</p><h2 id="12-假设有以下代码-下列选项中返回false的语句是："><a href="#12-假设有以下代码-下列选项中返回false的语句是：" class="headerlink" title="12.假设有以下代码,下列选项中返回false的语句是：()?"></a>12.假设有以下代码,下列选项中返回false的语句是：()?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s&#x3D;”hello”;</span><br><span class="line">String t&#x3D;”hello”;</span><br><span class="line">char c[] &#x3D;&#123;‘h’,’e’,’l’,’l’,’o’&#125;;</span><br></pre></td></tr></table></figure><p>A.s.equals(t);<br>B.t.equals(c);<br>C.s==t;<br>D.t.equals(new String(“hello”));</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong></p><p>String s=”hello”;//首先会在字符串缓冲区找找有没有hello，结果没有找到，就创建了一个hello，然后引用是s<br>String t=”hello”;//会在字符串缓冲区找hello，结果找到了，就返回了引用，也就是s；所以这句话等同于t=s；所以两个引用一样；所以t==s是true<br>Char c[] ={‘h’,’e’,’l’,’l’,o’’};//这就是一个数组,而且数组在堆上<br>equlse函数可以看源码！比较值相等之前会先比较类型是不是一样；如果类型一样才会比较值；如果类型不一致就直接return false；<br>所以综上所述：ACD返回true Bfalse</p><h2 id="13-下列哪个说法是正确的（）"><a href="#13-下列哪个说法是正确的（）" class="headerlink" title="13.下列哪个说法是正确的（）"></a>13.下列哪个说法是正确的（）</h2><p>A.ConcurrentHashMap使用synchronized关键字保证线程安全<br>B.HashMap实现了Collection接口<br>C.Array.asList方法返回java.util.ArrayList对象<br>D.SimpleDateFormat是线程不安全的</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong></p><p>A、ConcurrentHashMap实际上时 HashTable的升级版，使用segment来分段和管理锁，并不是synchronized;<br>B、HashMap实现的接口有：Serializable, Cloneable, Map&lt;K,V&gt; ,没有实现Collection<br>C、Arrays.asList()方法返回的列表是Arrays.ArrayList类型的，并不是java.util.ArrayList；<br>D、正确</p><h2 id="14-假定Base-b-new-Derived（）-调用执行b-methodOne（）后，输出结果是什么？"><a href="#14-假定Base-b-new-Derived（）-调用执行b-methodOne（）后，输出结果是什么？" class="headerlink" title="14. 假定Base b = new Derived（）; 调用执行b.methodOne（）后，输出结果是什么？"></a>14. 假定Base b = new Derived（）; 调用执行b.methodOne（）后，输出结果是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Base&#123;</span><br><span class="line">public void methodOne()&#123;</span><br><span class="line">System.out.print(&quot;A&quot;);</span><br><span class="line">methodTwo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void methodTwo()&#123;</span><br><span class="line">System.out.print(&quot;B&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Derived extends Base&#123;</span><br><span class="line">public void methodOne()&#123;</span><br><span class="line">super.methodOne();</span><br><span class="line">System.out.print(&quot;C&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void methodTwo()&#123;</span><br><span class="line">System.out.print(&quot;D&quot;);</span><br><span class="line">super.methodTwo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.ABDC<br>B.AB<br>C.ABCD<br>D.ABC</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong></p><p>程序开始执行，Base b = new Derived（）；new了一个子类<br>调用执行b.methodOne（）后，<br>第一步：因为子类重写了methodOne()方法，故调用的方法是子类的methodOne()方法<br>第二步：进入methodOne()方法后，执行super.methodOne()；调用父类methodOne()方法  输出：A<br>第三步：继续执行父类methodOne()方法中的methodTwo()方法<br>第四步：因为子类重写了methodOne()方法，故调用的方法是子类的methodTwo()方法<br>第五步：调用子类methodTwo()方法，执行super.methodTwo()；回到父类methodTwo()方法中  输出B<br>第六步：输出B后，执行子类methodTwo()中的System.out.print(“D”)；  输出D<br>第七步：回到子类methodOne()，继续往下执行，System.out.print(“C”);   输出C<br>所以结果为：ABDC</p><h2 id="15-对于子类的构造函数说明，下列叙述中错误的是（-）。"><a href="#15-对于子类的构造函数说明，下列叙述中错误的是（-）。" class="headerlink" title="15.对于子类的构造函数说明，下列叙述中错误的是（ ）。"></a>15.对于子类的构造函数说明，下列叙述中错误的是（ ）。</h2><p>A.子类不能继承父类的无参构造函数。<br>B.子类可以在自己的构造函数中使用super关键字来调用父类的含参数构造函数，但这个调用语句必须是子类构造函数的第一个可执行语句。<br>C.在创建子类的对象时，若不含带参构造函数，将先执行父类的无参构造函数，然后再执行自己的无参构造函数。<br>D.子类不但可以继承父类的无参构造函数，也可以继承父类的有参构造函数。</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>构造函数不能被继承，构造方法只能被显式或隐式的调用。 如果说有参构造可以被继承，那么在子类中有参构造就可以被重写；那么就无法通过父类的有参构造创建对象了；所以有参构造不能被继承。</p><h2 id="16-下面有关JSP内置对象的描述，说法错误的是？"><a href="#16-下面有关JSP内置对象的描述，说法错误的是？" class="headerlink" title="16.下面有关JSP内置对象的描述，说法错误的是？"></a>16.下面有关JSP内置对象的描述，说法错误的是？</h2><p>A.session对象：session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止<br>B.request对象：客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应<br>C.application对象：多个application对象实现了用户间数据的共享，可存放全局变量<br>D.response对象：response对象包含了响应客户请求的有关信息</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br> application对象是共享的，多个用户共享一个，以此实现数据共享和通信<br>JSP内置对象和属性列举如下：<br>1.request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>2.response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>3.session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>4.out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>5.page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>6.application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>7.exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>8.pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>9.config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p><h2 id="17-表达式-short-10-10-2-2运算后结果是什么类型？"><a href="#17-表达式-short-10-10-2-2运算后结果是什么类型？" class="headerlink" title="17.表达式(short)10/10.2*2运算后结果是什么类型？"></a>17.表达式(short)10/10.2*2运算后结果是什么类型？</h2><p>A.short<br>B.int<br>C.double<br>D.float</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>强制类型转换的优先级高于+ - * /<br>java 黙认浮点类型为double<br>float数据类型有一个后缀为” f “或” F “。<br>long类型有一个后缀，为” l “ 或者” L “。</p><h2 id="18-下列代码执行结果为（）"><a href="#18-下列代码执行结果为（）" class="headerlink" title="18.下列代码执行结果为（）"></a>18.下列代码执行结果为（）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[])throws InterruptedException&#123;</span><br><span class="line">Thread t&#x3D;new Thread(new Runnable() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(2000);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t.start();</span><br><span class="line"> </span><br><span class="line">t.join();</span><br><span class="line">System.out.print(&quot;1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.21<br>B.12<br>C.可能为12，也可能为21<br>D.以上答案都不对</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。<br>t.join();      //使调用线程 t 在此之前执行完毕。<br>t.join(1000);  //等待 t 线程，等待时间是1000毫秒</p><h2 id="19-以下哪个I-O类可以附加或更新文件"><a href="#19-以下哪个I-O类可以附加或更新文件" class="headerlink" title="19.以下哪个I / O类可以附加或更新文件"></a>19.以下哪个I / O类可以附加或更新文件</h2><p>A.RandomAccessFile()<br>B.OutputStream()<br>C.DataOutputStream()<br>D.None of the above</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>RandomAccessFile直接继承于Java. Lang. Object类，实现了DataInput和DataOutput接口，它既可以作为一个输入流，又可以作为一个输出流 </p><h2 id="20-Java语言中，下面哪个语句是创建数组的正确语句？"><a href="#20-Java语言中，下面哪个语句是创建数组的正确语句？" class="headerlink" title="20.Java语言中，下面哪个语句是创建数组的正确语句？()"></a>20.Java语言中，下面哪个语句是创建数组的正确语句？()</h2><p>A.float f[][] = new float[6][6];<br>B.float []f[] = new float[6][6];<br>C.float f[][] = new float[][6];<br>D.float [][]f = new float[6][6];<br>E.float [][]f = new float[6][];</p><p><strong>答案：</strong><br>A B D E</p><p><strong>解析：</strong><br>略</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">笔试内容集合</a> 持续更新中….</p><p><a href="https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21" target="_blank" rel="noopener">ProcessOn是一个在线作图工具的聚合平台</a></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-7c55905a20b9fafa?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（十三）</title>
      <link href="/2019/09/30/interview/java/B-bishi13/"/>
      <url>/2019/09/30/interview/java/B-bishi13/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-6c58ee55f59676fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（十三）"></p><h2 id="1-类Person里面有个方法sleep-，如果直接用Person-sleep-，则方法sleep前面必须用的关键词是？"><a href="#1-类Person里面有个方法sleep-，如果直接用Person-sleep-，则方法sleep前面必须用的关键词是？" class="headerlink" title="1. 类Person里面有个方法sleep()，如果直接用Person.sleep()，则方法sleep前面必须用的关键词是？  (    )"></a>1. 类Person里面有个方法sleep()，如果直接用Person.sleep()，则方法sleep前面必须用的关键词是？  (    )</h2><p>A.class<br>B.static<br>C.public<br>D.final</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>static关键字：针对多个对象共有的成员变量值时所提出的。<br>特点：1、随着类的加载而加载；2、优先于对象存在；3、被类的所有对象共享；4、可以通过类名直接调用。<br>注意事项：1.在静态方法中是没有this关键字的；        2.静态方法只能访问静态的成员变量和静态的成员方法。</p><h2 id="2-下列关于Java类中方法的定义，正确的是（）"><a href="#2-下列关于Java类中方法的定义，正确的是（）" class="headerlink" title="2.下列关于Java类中方法的定义，正确的是（）"></a>2.下列关于Java类中方法的定义，正确的是（）</h2><p>A.若代码执行到return语句，则将当前值返回，而且继续执行return语句后面的语句。<br>B.只需要对使用基本数据类型定义的属性使用getter和setter，体现类的封装性。<br>C.方法的返回值只能是基本数据类型。<br>D.在同一个类中定义的方法，允许方法名称相同而形参列表不同。</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>A、一旦执行到return，就不再执行后续的代码。<br>B、类的封装性可不是这么体现的，数据域和方法都可以被封装。数据域可以是基本数据类型也可以是引用类型。<br>C、方法的返回值可以是引用类型。<br>D、重载，判定方法只有方法名一致，形参列表不同。 </p><h2 id="3-J2EE中，当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的（-）方法"><a href="#3-J2EE中，当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的（-）方法" class="headerlink" title="3.J2EE中，当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的（    ）方法"></a>3.J2EE中，当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的（    ）方法</h2><p>A.service<br>B.doget<br>C.dopost<br>D.init</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>HttpServlet容器响应Web客户请求流程如下：<br>1）Web客户向Servlet容器发出Http请求；<br>2）Servlet容器解析Web客户的Http请求；<br>3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；<br>4）Servlet容器创建一个HttpResponse对象；<br>5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；<br>6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；<br>7）HttpServlet调用HttpResponse的有关方法，生成响应数据；<br>8）Servlet容器把HttpServlet的响应结果传给Web客户。<br>doGet() 或 doPost() 是创建HttpServlet时需要覆盖的方法.</p><h2 id="4-以下不是修饰符final的作用的是-。"><a href="#4-以下不是修饰符final的作用的是-。" class="headerlink" title="4.以下不是修饰符final的作用的是( )。"></a>4.以下不是修饰符final的作用的是( )。</h2><p>A.修饰常量<br>B.修饰不可被继承的类<br>C.修饰不可变类<br>D.修饰不可覆盖的方法</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>final的作用：</p><ol><li>修饰变量，变量的引用地址不可变，但是地址中的内容可以变。</li><li>修饰方法，方法不可被重写，但是还是可以重载</li><li>修饰类，类不可继承。</li></ol><h2 id="5-下面有关java的一些细节问题，描述错误的是？"><a href="#5-下面有关java的一些细节问题，描述错误的是？" class="headerlink" title="5.下面有关java的一些细节问题，描述错误的是？"></a>5.下面有关java的一些细节问题，描述错误的是？</h2><p>A.构造方法不需要同步化<br>B.一个子类不可以覆盖掉父类的同步方法<br>C.定义在接口中的方法默认是public的<br>D.容器保存的是对象的引用</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>B选项中，子类应该是可以置换掉父类的同步方法的。</p><h2 id="6-关于依赖注入，下列选项中说法错误的是（）"><a href="#6-关于依赖注入，下列选项中说法错误的是（）" class="headerlink" title="6.关于依赖注入，下列选项中说法错误的是（）"></a>6.关于依赖注入，下列选项中说法错误的是（）</h2><p>A.依赖注入能够独立开发各组件，然后根据组件间关系进行组装<br>B.依赖注入使组件之间相互依赖，相互制约<br>C.依赖注入提供使用接口编程<br>D.依赖注入指对象在使用时动态注入</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>依赖注入的动机就是减少组件之间的耦合度，使开发更为简洁</p><h2 id="7-下面有关java基本类型的默认值和取值范围，说法错误的是？"><a href="#7-下面有关java基本类型的默认值和取值范围，说法错误的是？" class="headerlink" title="7.下面有关java基本类型的默认值和取值范围，说法错误的是？"></a>7.下面有关java基本类型的默认值和取值范围，说法错误的是？</h2><p>A.字节型的类型默认值是0，取值范围是-2^7—2^7-1<br>B.boolean类型默认值是false，取值范围是true\false<br>C.字符型类型默认是0，取值范围是-2^15 —2^15-1<br>D.long类型默认是0，取值范围是-2^63—2^63-1</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>默认值         取值范围 示例<br>字节型 ： 0 -2^7—-2^7-1 byte b=10;<br>字符型 ： ‘ \u0000′ 0—-2^16-1   char c=’c’ ;<br>short : 0 -2^15—-2^15-1 short s=10;<br>int : 0 -2^31—-2^31-1 int i=10;<br>long : 0 -2^63—-2^63-1     long o=10L;<br>float : 0.0f -2^31—-2^31-1 float f=10.0F<br>double : 0.0d -2^63—-2^63-1 double d=10.0;<br>boolean: false true\false boolean flag=true; </p><h2 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>A.<br>B.<br>C.<br>D.</p><p><strong>答案：</strong></p><p><strong>解析：</strong></p><h2 id="9-以下对选择语句描述错误的是-）"><a href="#9-以下对选择语句描述错误的是-）" class="headerlink" title="9.以下对选择语句描述错误的是(）"></a>9.以下对选择语句描述错误的是(）</h2><p>A.根据某一条件重复执行一部分代码直到满足终止条件为止<br>B.可以根据条件控制程序流程，改变程序执行的顺序<br>C.选择语句可以嵌套使用<br>D.当条件满足时就会执行相应的语句</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>流程控制语句分类：<br>顺序结构<br>选择结构:if语句、switch语句<br>循环结构:while语句、for语句</p><h2 id="10-java中将ISO8859-1字符串转成GB2312编码，语句为-？"><a href="#10-java中将ISO8859-1字符串转成GB2312编码，语句为-？" class="headerlink" title="10.java中将ISO8859-1字符串转成GB2312编码，语句为 ？"></a>10.java中将ISO8859-1字符串转成GB2312编码，语句为 ？</h2><p>A.new String(“ISO8859-1”.getBytes(“ISO8859-1”),”GB2312”)<br>B.new String(String.getBytes(“GB2312”）, ISO8859-1)<br>C.new String(String.getBytes(“ISO8859-1”))<br>D.new String(String.getBytes(“GB2312”))</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>答案：A<br>注意这里”ISO8859-1”是一个普通字符串，不要被迷惑了<br>String.getBytes(“ISO8859-1”）表示获取这个字符串的byte数组，<br>然后new String(String.getBytes(“ISO8859-1”），GB2312)是上面的字符数组按照GB2312编码成新的字符串</p><h2 id="11-以下代码正确返回结果"><a href="#11-以下代码正确返回结果" class="headerlink" title="11.以下代码正确返回结果()?"></a>11.以下代码正确返回结果()?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a &#x3D; 1;</span><br><span class="line">Integer b &#x3D; 1;</span><br><span class="line">Integer c &#x3D; 500;</span><br><span class="line">Integer d &#x3D; 500;</span><br><span class="line">System.out.print(a &#x3D;&#x3D; b);</span><br><span class="line">System.out.print(c &#x3D;&#x3D; d);</span><br></pre></td></tr></table></figure><p>A.true、true<br>B.true、false<br>C.false、true<br>D.false、false</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>nterger的范围时[-128,127]，在这个范围内比较大小，相等为true，超过范围为false </p><h2 id="12-jdbc的事务必须在一个数据库连接上完成。编程时必须去掉数据库的自动提交功能。当成功后调用commit，当失败后调用rollback。判断这句话正确与否"><a href="#12-jdbc的事务必须在一个数据库连接上完成。编程时必须去掉数据库的自动提交功能。当成功后调用commit，当失败后调用rollback。判断这句话正确与否" class="headerlink" title="12.jdbc的事务必须在一个数据库连接上完成。编程时必须去掉数据库的自动提交功能。当成功后调用commit，当失败后调用rollback。判断这句话正确与否"></a>12.jdbc的事务必须在一个数据库连接上完成。编程时必须去掉数据库的自动提交功能。当成功后调用commit，当失败后调用rollback。判断这句话正确与否</h2><p>A.正确<br>B.错误</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>在JDBC编程模式中，一个数据库连接建立时，就处于一个自动提交模式，每一个SQL语句被执行完成后就会被自动提交，反映到数据库中。当需要把几条逻辑上相关的SQL组成的一个事务执行时，就需要关闭事务自动提交模式。如下面的语句所示： con.setAutoCommit(false); // 关闭自动提交模式 一旦关闭了事务自动提交模式，不会有任何SQL语句被提交至数据库系统执行，除非显式的调用提交方法。 </p><h2 id="13-关于下面的程序Test-java说法正确的是-。"><a href="#13-关于下面的程序Test-java说法正确的是-。" class="headerlink" title="13.关于下面的程序Test.java说法正确的是(    )。"></a>13.关于下面的程序Test.java说法正确的是(    )。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    static String x&#x3D;&quot;1&quot;;</span><br><span class="line">    static int y&#x3D;1;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        static int z&#x3D;2;</span><br><span class="line">        System.out.println(x+y+z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.3<br>B.112<br>C.13<br>D.程序有编译错误</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>被static修饰的变量称为静态变量，静态变量属于整个类，而局部变量属于方法，只在该方法内有效，所以static不能修饰局部变量 </p><h2 id="14-抽象类方法的访问权限默认都是public。（-）"><a href="#14-抽象类方法的访问权限默认都是public。（-）" class="headerlink" title="14.抽象类方法的访问权限默认都是public。（  ）"></a>14.抽象类方法的访问权限默认都是public。（  ）</h2><p>A.正确<br>B.错误</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>关于抽象类<br>JDK 1.8以前，抽象类的方法默认访问权限为protected<br>JDK 1.8时，抽象类的方法默认访问权限变为default</p><p>关于接口<br>JDK 1.8以前，接口中的方法必须是public的<br>JDK 1.8时，接口中的方法可以是public的，也可以是default的<br>JDK 1.9时，接口中的方法可以是private的</p><h2 id="15-下面程序段的时间复杂度是（）"><a href="#15-下面程序段的时间复杂度是（）" class="headerlink" title="15.下面程序段的时间复杂度是（）"></a>15.下面程序段的时间复杂度是（）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i &#x3D; k &#x3D; 0;</span><br><span class="line">while( k &lt; n )&#123;</span><br><span class="line">   i ++ ;</span><br><span class="line">k +&#x3D; i ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.O(n)<br>B.O(n^1/2)<br>C.O(n*i)<br>D.O(n+i)</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>设循环次数为 q， 时间复杂度为T(n), 也就是说，每次给定一个n的时候，根据 T(n)可以算出来时间复杂度， 那么时间复杂度就是 q， 因为其他操作都是常数时间的操作，所以决定时间复杂度的就应该是循环次数。  观察代码，在while循环中，每次 i 会自加1，循环次数 q 也得加 1 ， 也就可以看成每次都是 s 每次都加上 q , 在 s &gt; = n 的时候结束，那么 n  和 q 的关系就是 k=0   k + 1 + 2 + +3 + … + q &lt;= n(q 是循环的次数 )， 那就是 0 + 1 + 2 + +3 + … + q &lt;= n ，根据等差公式算一算就可以得到 T( n ) = n^0.5了   主要就是借着 q 算出来 n 和 T( n) 的关系。 </p><h2 id="16-以下代码最后输出什么？"><a href="#16-以下代码最后输出什么？" class="headerlink" title="16.以下代码最后输出什么？"></a>16.以下代码最后输出什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void test() &#123;</span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">System.out.println(a++ + a--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.19<br>B.20<br>C.21<br>D.22</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>a++ 先把10赋值给a 再+1 所以左边是10 但此时a=11。右边a– 也是先赋值 a=11，再-1。10+11=21 此时a=10。</p><h2 id="17-下列关于容器集合类的说法正确的是？"><a href="#17-下列关于容器集合类的说法正确的是？" class="headerlink" title="17.下列关于容器集合类的说法正确的是？"></a>17.下列关于容器集合类的说法正确的是？</h2><p>A.LinkedList继承自List<br>B.AbstractSet继承自Set<br>C.HashSet继承自AbstractSet<br>D.WeakMap继承自HashMap</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>a选项linkedlist类是实现了List接口，而不是继承<br>b选项AbstractSet类实现Set接口<br>c选项HashSet继承 AbstractSet类，同时也实现set<br>d选项WeakMap是js里面的</p><h2 id="18-以下哪些类是线程安全的（）"><a href="#18-以下哪些类是线程安全的（）" class="headerlink" title="18.以下哪些类是线程安全的（）"></a>18.以下哪些类是线程安全的（）</h2><p>A.Vector<br>B.HashMap<br>C.ArrayList<br>D.StringBuffer<br>E.Properties</p><p><strong>答案：</strong><br>ADE</p><p><strong>解析：</strong><br>A，Vector相当于一个线程安全的List<br>B，HashMap是非线程安全的，其对应的线程安全类是HashTable<br>C，Arraylist是非线程安全的，其对应的线程安全类是Vector<br>D，StringBuffer是线程安全的，相当于一个线程安全的StringBuilder<br>E，Properties实现了Map接口，是线程安全的 </p><h2 id="19-关于struts项目中的类与MVC模式的对应关系，说法错误的是"><a href="#19-关于struts项目中的类与MVC模式的对应关系，说法错误的是" class="headerlink" title="19.关于struts项目中的类与MVC模式的对应关系，说法错误的是"></a>19.关于struts项目中的类与MVC模式的对应关系，说法错误的是</h2><p>A.Jsp文件实现视图View的功能<br>B.ActionServlet这一个类是整个struts项目的控制器<br>C.ActionForm、Action都属于Model部分<br>D.一个struts项目只能有一个Servlet</p><p><strong>答案：</strong><br>C D </p><p><strong>解析：</strong><br><img src="https://upload-images.jianshu.io/upload_images/7326374-7f3955920a99e790.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工作流程"></p><h2 id="20-Hashtable-和-HashMap-的区别是：-（）？"><a href="#20-Hashtable-和-HashMap-的区别是：-（）？" class="headerlink" title="20. Hashtable 和 HashMap 的区别是： （）？"></a>20. Hashtable 和 HashMap 的区别是： （）？</h2><p>A.Hashtable 是一个哈希表，该类继承了 AbstractMap，实现了 Map 接口<br>B.HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口<br>C.Hashtable 线程安全的，而 HashMap 是线程不安全的<br>D.Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类<br>E.HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</p><p><strong>答案：</strong><br>B C D E</p><p><strong>解析：</strong><br>Hashtable：<br>（1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。<br>（2）Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。<br>（3）HashTable直接使用对象的hashCode。<br>HashMap：<br>（1）由数组+链表组成的，基于哈希表的Map实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。<br>（2）不是线程安全的，HashMap可以接受为null的键(key)和值(value)。<br>（3）HashMap重新计算hash值</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">笔试内容集合</a> 持续更新中….<br><a href="https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21" target="_blank" rel="noopener">ProcessOn是一个在线作图工具的聚合平台~</a></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-9d966dc5c0e1321a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（十二）</title>
      <link href="/2019/09/27/interview/java/B-bishi12/"/>
      <url>/2019/09/27/interview/java/B-bishi12/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-20ec48686d0a836e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（十二）"></p><h2 id="1-（C-、JAVA）扩展方法能访问被扩展对象的public成员"><a href="#1-（C-、JAVA）扩展方法能访问被扩展对象的public成员" class="headerlink" title="1.（C#、JAVA）扩展方法能访问被扩展对象的public成员"></a>1.（C#、JAVA）扩展方法能访问被扩展对象的public成员</h2><p>A.能<br>B.不能</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>翻译一下，子类方法是否能够访问父类中的public成员。</p><h2 id="2-如果子类要调用父类的构造函数，则通过super（）调用来实现。"><a href="#2-如果子类要调用父类的构造函数，则通过super（）调用来实现。" class="headerlink" title="2.如果子类要调用父类的构造函数，则通过super（）调用来实现。"></a>2.如果子类要调用父类的构造函数，则通过super（）调用来实现。</h2><p>A.正确<br>B.错误</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>super关键字在子类内部使用，代表父类对象。 访问父类的属性 super.属性名 访问父类的方法 super.方法名() 子类构造方法需要调用父类的构造方法时，在子类的构造方法体里最前面的位置：super() </p><h2 id="3-下列关于Java语言中String和char的说法，正确的是（）"><a href="#3-下列关于Java语言中String和char的说法，正确的是（）" class="headerlink" title="3.下列关于Java语言中String和char的说法，正确的是（）"></a>3.下列关于Java语言中String和char的说法，正确的是（）</h2><p>A.String是Java定义的一种基本数据类型。<br>B.String是以“\0”结尾的char类型的数组char[]。<br>C.使用equals()方法比较两个String是否内容一样（即字符串中的各个字符都一样）。<br>D.Char类型在Java语言里面存储的是ASCII码。</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>A 基本数据类型包括byte，short，int，long，float，double，char，boolean，所以A错。<br>B,C语言当中是这样，java不是， String内部是用char[]数组实现的，不过结尾不用\0。<br>C 对，字符串内容比较用equals方法。<br>D char存储的unicode码，不进可以存储ascII码，汉字也可以。</p><h2 id="4-关于JAVA堆，下面说法错误的是（）？"><a href="#4-关于JAVA堆，下面说法错误的是（）？" class="headerlink" title="4.关于JAVA堆，下面说法错误的是（）？"></a>4.关于JAVA堆，下面说法错误的是（）？</h2><p>A.所有类的实例和数组都是在堆上分配内存的<br>B.堆内存由存活和死亡的对象，空闲碎片区组成<br>C.数组是分配在栈中的<br>D.对象所占的堆内存是由自动内存管理系统回收</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>C应该改为，数组的引用存在栈内存中，而数组对象保存在堆里面。 </p><h2 id="5-java-接口的修饰符可以为（）"><a href="#5-java-接口的修饰符可以为（）" class="headerlink" title="5. java 接口的修饰符可以为（）"></a>5. java 接口的修饰符可以为（）</h2><p>A.private<br>B.protected<br>C.final<br>D.abstract</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>接口是通用的，用来描述方法是干什么用的，方法的默认修饰符为public abstract.不可以为final 是因为方法要被重写， 描述符如果为private或者protected，那么子类重写的方法的描述符也可以为private或者protected，这样就是有了访问显示，不符合接口所要达到的的任何人都可以使用了 </p><h2 id="6-指出下来程序运行的结果是"><a href="#6-指出下来程序运行的结果是" class="headerlink" title="6.指出下来程序运行的结果是"></a>6.指出下来程序运行的结果是</h2><p><img src="https://upload-images.jianshu.io/upload_images/7326374-2d24a42d10bb6bd8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码"></p><p>A.good and abc<br>B.good and gbc<br>C.test ok and abc<br>D.test ok and gbc</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>实参和形参的问题。”ex.change(ex.str, ex.ch)”语句调用”change”方法时，将ex.str变量（实参）的值赋给了”change”方法中的str变量（形参），而将ex.ch（实参）的地址赋给了”change”方法中的ch（形参）。”change”方法运行时，第一条语句改变的是方法中形参的值，对实参没影响，第二条语句由于是直接改变的ch所指地址的值，所以把实参也进行了改变。 </p><h2 id="7-A-是抽象父类或接口，-B-，-C-派生自-A-，或实现-A-，现在-Java-源代码中有如下声明：-问以下哪个说法是正确的？（-）"><a href="#7-A-是抽象父类或接口，-B-，-C-派生自-A-，或实现-A-，现在-Java-源代码中有如下声明：-问以下哪个说法是正确的？（-）" class="headerlink" title="7. A 是抽象父类或接口， B ， C 派生自 A ，或实现 A ，现在 Java 源代码中有如下声明： 问以下哪个说法是正确的？（ ）"></a>7. A 是抽象父类或接口， B ， C 派生自 A ，或实现 A ，现在 Java 源代码中有如下声明： 问以下哪个说法是正确的？（ ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. A  a0&#x3D;new  A();</span><br><span class="line">2. A  a1 &#x3D;new  B();</span><br><span class="line">3. A  a2&#x3D;new  C();</span><br></pre></td></tr></table></figure><p>A.第1行不能通过编译<br>B.第1、2行能通过编译，但第3行编译出错<br>C.第1、2、3行能通过编译，但第2、3行运行时出错<br>D.第1行、第2行和第3行的声明都是正确的</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>抽象类和接口不能实例化</p><h2 id="8-try块后必须有catch块。（）"><a href="#8-try块后必须有catch块。（）" class="headerlink" title="8.try块后必须有catch块。（）"></a>8.try块后必须有catch块。（）</h2><p>A.正确<br>B.错误</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>catch可以省略，try的形式有三种：<br>try-catch<br>try-finally<br>try-catch-finally<br>但catch和finally语句不能同时省略！ </p><h2 id="9-以下-不是-Object-类的方法"><a href="#9-以下-不是-Object-类的方法" class="headerlink" title="9. 以下 _____ 不是 Object 类的方法"></a>9. 以下 _____ 不是 Object 类的方法</h2><p>A.clone（）<br>B.finalize()<br>C.toString()<br>D.hasNext()</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>略</p><h2 id="10-指出下列程序运行的结果："><a href="#10-指出下列程序运行的结果：" class="headerlink" title="10.指出下列程序运行的结果："></a>10.指出下列程序运行的结果：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Example&#123;</span><br><span class="line">    String str&#x3D;new String(&quot;tarena&quot;);</span><br><span class="line">    char[]ch&#x3D;&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        Example ex&#x3D;new Example();</span><br><span class="line">        ex.change(ex.str,ex.ch);</span><br><span class="line">        System.out.print(ex.str+&quot; and &quot;);</span><br><span class="line">        System.out.print(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line">    public void change(String str,char ch[])&#123;</span><br><span class="line">   &#x2F;&#x2F;引用类型变量，传递的是地址，属于引用传递。</span><br><span class="line">        str&#x3D;&quot;test ok&quot;;</span><br><span class="line">        ch[0]&#x3D;&#39;g&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.tarena and abc<br>B.tarena and gbc<br>C.test ok and abc<br>D.test ok and gbc</p><p><strong>答案：</strong><br>B </p><p><strong>解析：</strong><br>与第六题类似。</p><h2 id="11-以下代码段执行后的输出结果为"><a href="#11-以下代码段执行后的输出结果为" class="headerlink" title="11.以下代码段执行后的输出结果为"></a>11.以下代码段执行后的输出结果为</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">int x &#x3D; -5;</span><br><span class="line">int y &#x3D; -12;</span><br><span class="line">System.out.println(y % x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.-1<br>B.2<br>C.1<br>D.-2</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>取模运算，余数的符号跟被除数符号相同 </p><h2 id="12-下面有关webservice的描述，错误的是？"><a href="#12-下面有关webservice的描述，错误的是？" class="headerlink" title="12.下面有关webservice的描述，错误的是？"></a>12.下面有关webservice的描述，错误的是？</h2><p>A.Webservice是跨平台，跨语言的远程调用技术<br>B.Webservice通信机制实质就是json数据交换<br>C.Webservice采用了soap协议（简单对象协议）进行通信<br>D.WSDL是用于描述 Web Services 以及如何对它们进行访问</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>Webservice是跨平台，跨语言的远程调用技术;它的通信机制实质就是xml数据交换;它采用了soap协议（简单对象协议）进行通信</p><h2 id="13-关于ASCII码和ANSI码，以下说法不正确的是（）？"><a href="#13-关于ASCII码和ANSI码，以下说法不正确的是（）？" class="headerlink" title="13.关于ASCII码和ANSI码，以下说法不正确的是（）？"></a>13.关于ASCII码和ANSI码，以下说法不正确的是（）？</h2><p>A.标准ASCII只使用7个bit<br>B.在简体中文的Windows系统中，ANSI就是GB2312<br>C.ASCII码是ANSI码的子集<br>D.ASCII码都是可打印字符</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>A、标准ASCII只使用7个bit，扩展的ASCII使用8个bit。<br>B、ANSI通常使用 0x00<del>0x7f 范围的1 个字节来表示 1 个英文字符。超出此范围的使用0x80</del>0xFFFF来编码，即扩展的ASCII编码。不同 ANSI 编码之间互不兼容。在简体中文Windows操作系统中，ANSI 编码代表 GBK 编码；在繁体中文Windows操作系统中，ANSI编码代表Big5；在日文Windows操作系统中，ANSI 编码代表 Shift_JIS 编码。<br>C、ANSI通常使用 0x00~0x7f 范围的1 个字节来表示 1 个英文字符，即ASCII码<br>D、ASCII码包含一些特殊空字符 </p><h2 id="14-Test-main-函数执行后的输出是（）"><a href="#14-Test-main-函数执行后的输出是（）" class="headerlink" title="14. Test.main() 函数执行后的输出是（）"></a>14. Test.main() 函数执行后的输出是（）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String [] args)&#123;  </span><br><span class="line">        System.out.println(new B().getValue());  </span><br><span class="line">    &#125;  </span><br><span class="line">    static class A&#123;  </span><br><span class="line">        protected int value;  </span><br><span class="line">        public A(int v) &#123;  </span><br><span class="line">            setValue(v);  </span><br><span class="line">        &#125;  </span><br><span class="line">        public void setValue(int value)&#123;  </span><br><span class="line">            this.value &#x3D; value;  </span><br><span class="line">        &#125;  </span><br><span class="line">        public int getValue()&#123;  </span><br><span class="line">            try&#123;  </span><br><span class="line">                value++;  </span><br><span class="line">                return value;  </span><br><span class="line">            &#125; catch(Exception e)&#123;  </span><br><span class="line">                System.out.println(e.toString());  </span><br><span class="line">            &#125; finally &#123;  </span><br><span class="line">                this.setValue(value);  </span><br><span class="line">                System.out.println(value);  </span><br><span class="line">            &#125;  </span><br><span class="line">            return value;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    static class B extends A&#123;  </span><br><span class="line">        public B() &#123;  </span><br><span class="line">            super(5);  </span><br><span class="line">            setValue(getValue() - 3);  </span><br><span class="line">        &#125;  </span><br><span class="line">        public void setValue(int value)&#123;  </span><br><span class="line">            super.setValue(2 * value);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.11 17 34<br>B.22 74 74<br>C.6 7 7<br>D.22 34 17</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>略</p><h2 id="15-final、finally和finalize的区别中，下述说法正确的有？"><a href="#15-final、finally和finalize的区别中，下述说法正确的有？" class="headerlink" title="15.final、finally和finalize的区别中，下述说法正确的有？"></a>15.final、finally和finalize的区别中，下述说法正确的有？</h2><p>A.final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。<br>B.finally是异常处理语句结构的一部分，表示总是执行。<br>C.finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源的回收，例如关闭文件等。<br>D.引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的。</p><p><strong>答案：</strong><br>A B</p><p><strong>解析：</strong><br>A，D考的一个知识点，final修饰变量，变量的引用（也就是指向的地址）不可变，但是引用的内容可以变（地址中的内容可变）。<br>B，finally表示总是执行。但是其实finally也有不执行的时候，但是这个题不要扣字眼。</p><ol><li>在try中调用System.exit(0)，强制退出了程序，finally块不执行。</li><li>在进入try块前，出现了异常，finally块不执行。<br>C，finalize方法，这个选项错就错在，这个方法一个对象只能执行一次，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。<br>放一张图吧<br><img src="https://upload-images.jianshu.io/upload_images/7326374-771ace235e3c2b15?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15"></li></ol><h2 id="16-关于equals和hashCode描述正确的是"><a href="#16-关于equals和hashCode描述正确的是" class="headerlink" title="16.关于equals和hashCode描述正确的是()"></a>16.关于equals和hashCode描述正确的是()</h2><p>A.两个obj，如果equals()相等，hashCode()一定相等（符合代码规范的情况下）<br>B.两个obj，如果hashCode()相等，equals()不一定相等<br>C.两个不同的obj， hashCode()可能相等<br>D.其他都不对</p><p><strong>答案：</strong><br>A B C</p><p><strong>解析：</strong><br>地址比较是通过计算对象的哈希值来比较的，hashcode属于Object的本地方法，对象相等（地址相等），hashcode相等，对象不相等，hashcode()可能相等，哈希冲突 </p><h2 id="17-下面有关java类加载器，说法正确的是？"><a href="#17-下面有关java类加载器，说法正确的是？" class="headerlink" title="17.下面有关java类加载器，说法正确的是？"></a>17.下面有关java类加载器，说法正确的是？</h2><p>A.引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的<br>B.扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。<br>C.系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类<br>D.tomcat为每个App创建一个Loader，里面保存着此WebApp的ClassLoader。需要加载WebApp下的类时，就取出ClassLoader来使用</p><p><strong>答案：</strong><br>ABCD</p><p><strong>解析：</strong><br> jvm classLoader architecture :</p><p>a、Bootstrap ClassLoader/启动类加载器<br>主要负责jdk_home/lib目录下的核心 api 或 -Xbootclasspath 选项指定的jar包装入工作.</p><p>B、Extension ClassLoader/扩展类加载器<br>主要负责jdk_home/lib/ext目录下的jar包或 -Djava.ext.dirs 指定目录下的jar包装入工作</p><p>C、System ClassLoader/系统类加载器<br>主要负责java -classpath/-Djava.class.path所指的目录下的类与jar包装入工作.</p><p>B、 User Custom ClassLoader/用户自定义类加载器(java.lang.ClassLoader的子类)<br>在程序运行期间, 通过java.lang.ClassLoader的子类动态加载class文件, 体现java动态实时类装入特性. </p><h2 id="18-下面哪项技术可以用在WEB开发中实现会话跟踪实现？"><a href="#18-下面哪项技术可以用在WEB开发中实现会话跟踪实现？" class="headerlink" title="18.下面哪项技术可以用在WEB开发中实现会话跟踪实现？"></a>18.下面哪项技术可以用在WEB开发中实现会话跟踪实现？</h2><p>A.session<br>B.Cookie<br>C.地址重写<br>D.隐藏域</p><p><strong>答案：</strong><br>ABCD</p><p><strong>解析：</strong><br>会话跟踪是一种灵活、轻便的机制，它使Web上的状态编程变为可能。<br>HTTP是一种无状态协议，每当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。<br>有四种方法可以实现会话跟踪技术：URL重写、隐藏表单域、Cookie、Session。<br>1）.隐藏表单域：<input type="hidden">，非常适合步需要大量数据存储的会话应用。<br>2）.URL 重写:URL 可以在后面附加参数，和服务器的请求一起发送，这些参数为名字/值对。<br>3）.Cookie:一个 Cookie 是一个小的，已命名数据元素。服务器使用 SET-Cookie 头标将它作为 HTTP<br>响应的一部分传送到客户端，客户端被请求保存 Cookie 值，在对同一服务器的后续请求使用一个<br>Cookie 头标将之返回到服务器。与其它技术比较，Cookie 的一个优点是在浏览器会话结束后，甚至<br>在客户端计算机重启后它仍可以保留其值<br>4）.Session：使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话</p><h2 id="19-下面有关forward和redirect的描述，正确的是-？"><a href="#19-下面有关forward和redirect的描述，正确的是-？" class="headerlink" title="19.下面有关forward和redirect的描述，正确的是() ？"></a>19.下面有关forward和redirect的描述，正确的是() ？</h2><p>A.forward是服务器将控制权转交给另外一个内部服务器对象，由新的对象来全权负责响应用户的请求<br>B.执行forward时，浏览器不知道服务器发送的内容是从何处来，浏览器地址栏中还是原来的地址<br>C.执行redirect时，服务器端告诉浏览器重新去请求地址<br>D.forward是内部重定向，redirect是外部重定向<br>E.redirect默认将产生301 Permanently moved的HTTP响应</p><p><strong>答案：</strong><br>B C D</p><p><strong>解析：</strong></p><p>1.从地址栏显示来说<br>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.<br>redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p><p>2.从数据共享来说<br>forward:转发页面和转发到的页面可以共享request里面的数据.<br>redirect:不能共享数据.</p><p>3.从运用地方来说<br>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.</p><p>4.从效率来说<br>forward:高.<br>redirect:低.</p><h2 id="20-下面关于volatile的功能说法正确的是哪个"><a href="#20-下面关于volatile的功能说法正确的是哪个" class="headerlink" title="20.下面关于volatile的功能说法正确的是哪个"></a>20.下面关于volatile的功能说法正确的是哪个</h2><p>A.原子性<br>B.有序性<br>C.可见性<br>D.持久性</p><p><strong>答案：</strong><br>B C</p><p><strong>解析：</strong><br>synchronized保证三大性，原子性，有序性，可见性，volatile保证有序性，可见性，不能保证原子性 </p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">笔试内容集合</a> 持续更新中….<br><a href="https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21" target="_blank" rel="noopener">ProcessOn是一个在线作图工具的聚合平台~</a></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-9d966dc5c0e1321a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（十一）</title>
      <link href="/2019/09/26/interview/java/B-bishi11/"/>
      <url>/2019/09/26/interview/java/B-bishi11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-dd73f2cd96177d28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（十一）"></p><h2 id="1-下面的方法，当输入为2的时候返回值是多少？"><a href="#1-下面的方法，当输入为2的时候返回值是多少？" class="headerlink" title="1.下面的方法，当输入为2的时候返回值是多少？"></a>1.下面的方法，当输入为2的时候返回值是多少？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static int getValue(int i) &#123;</span><br><span class="line">int result &#x3D; 0;</span><br><span class="line">switch (i) &#123;</span><br><span class="line">case 1:</span><br><span class="line">result &#x3D; result + i;</span><br><span class="line">case 2:</span><br><span class="line">result &#x3D; result + i * 2;</span><br><span class="line">case 3:</span><br><span class="line">result &#x3D; result + i * 3;</span><br><span class="line">&#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.0<br>B.2<br>C.4<br>D.10</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>没有break，发生case穿透现象，程序会继续向下执行，直到遇到break或者结束switch语句的大括号为止。 </p><h2 id="2-Java是从（）语言改进重新设计"><a href="#2-Java是从（）语言改进重新设计" class="headerlink" title="2.Java是从（）语言改进重新设计"></a>2.Java是从（）语言改进重新设计</h2><p>A.Ada<br>B.C++<br>C.Pascal<br>D.BASIC</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>ava是类C语言，从C++改进而来 去掉了指针和多继承，采用自动垃圾回收等 </p><h2 id="3-一个以”-java”为后缀的源文件，哪些说法是正确的？"><a href="#3-一个以”-java”为后缀的源文件，哪些说法是正确的？" class="headerlink" title="3.一个以”. java”为后缀的源文件，哪些说法是正确的？"></a>3.一个以”. java”为后缀的源文件，哪些说法是正确的？</h2><p>A.只能包含一个类，类名必须与文件名相同<br>B.只能包含与文件名相同的类，以及其中的内部类<br>C.只能有一个与文件名相同的类，可以包含其他类<br>D.可以包含任意类</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>C。一个与文件名相同的public的类敏感词类可随意多个。</p><h2 id="4-在JAVA中，下面关于String类和StringBuffer类的描述正确的是那一个？"><a href="#4-在JAVA中，下面关于String类和StringBuffer类的描述正确的是那一个？" class="headerlink" title="4.在JAVA中，下面关于String类和StringBuffer类的描述正确的是那一个？"></a>4.在JAVA中，下面关于String类和StringBuffer类的描述正确的是那一个？</h2><p>A.StringBuffer类的对象调用toString（）方法将返回String类型的结果<br>B.两个类都有append（）方法<br>C.可以直接将字符串“test”赋值给声明的String类和StringBuffer类的变量<br>D.两个类的实例的值都能够被改变</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>A. StringBuffer类调用toString（）方法后将转换为String类型   正确<br>B. String类型中没有append（）方法，要追加字符串”+“即可，也没有必要 append<br>C. 可以直接将字符串“test”复制给声明的Stirng类的变量，而StringBuffer类的不行<br>D. String 实例 是不可变的<br>String 对象/实例 是不可以被改变的。</p><p>当new一个String对象时，JVM会在内存中创建一个String对象，当另外一个String对象值与它一样时，会将该对象直接指向对应的地址。 </p><h2 id="5-下列关于构造方法不正确的是：（-）"><a href="#5-下列关于构造方法不正确的是：（-）" class="headerlink" title="5. 下列关于构造方法不正确的是：（ ）"></a>5. 下列关于构造方法不正确的是：（ ）</h2><p>A.类的构造方法和类同名<br>B.一个类可以有多个构造方法<br>C.在实例化对象时必须调用类的构造方法<br>D.构造方法可以和该类其他方法一样被该类对象调用</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>1.构造方法也是类的方法，可以在创建对象时为成员变量赋值<br>2.构造方法可以进行重载，但是参数列表必须不相同，不以返回值和访问级别进行区分<br>3.构造方法没有返回值<br>4.构造方法一定要与定义为public的类同名<br>5.构造方法不能被对象调用，只会创建对象，使用new关键字 </p><h2 id="6-根据下面的程序代码，哪些选项的值返回true？"><a href="#6-根据下面的程序代码，哪些选项的值返回true？" class="headerlink" title="6.根据下面的程序代码，哪些选项的值返回true？"></a>6.根据下面的程序代码，哪些选项的值返回true？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Square &#123;  </span><br><span class="line">    long width;  </span><br><span class="line">    public Square(long l) &#123;   </span><br><span class="line">        width &#x3D; l;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public static void main(String arg[]) &#123;   </span><br><span class="line">        Square a, b, c;  </span><br><span class="line">        a &#x3D; new Square(42L);   </span><br><span class="line">        b &#x3D; new Square(42L);   </span><br><span class="line">        c &#x3D; b;   </span><br><span class="line">        long s &#x3D; 42L;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.a == b<br>B.s == a<br>C.b == c<br>D.a.equals(s)</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; new Square(42L);   </span><br><span class="line">b &#x3D; new Square(42L);</span><br></pre></td></tr></table></figure><p>这里new了两个对象，所以a,b不是同一个引用a!=b ,s的类型跟a,b不同类型，所以s!=a,s!=b<br>c = b; 这里b，c是同一个对象的引用，所以b==c是true</p><h2 id="7-根据以下代码段-执行new-Child-“John”-10-要使数据域data得到10，则子类空白处应该填写-。"><a href="#7-根据以下代码段-执行new-Child-“John”-10-要使数据域data得到10，则子类空白处应该填写-。" class="headerlink" title="7.根据以下代码段,执行new Child(“John”, 10); 要使数据域data得到10，则子类空白处应该填写(    )。"></a>7.根据以下代码段,执行new Child(“John”, 10); 要使数据域data得到10，则子类空白处应该填写(    )。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> class Parent &#123;</span><br><span class="line">    private int data;</span><br><span class="line">    public Parent(int d)&#123; data &#x3D; d; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent&#123;</span><br><span class="line">    String name;</span><br><span class="line">    public Child(String s, int d)&#123;</span><br><span class="line">        ___________________</span><br><span class="line">        name &#x3D; s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.data = d;<br>B.super.data = d;<br>C.Parent(d);<br>D.super(d);</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>1.子父类存在同名成员时，子类中默认访问子类的成员，可通过super指定访问父类的成员，格式：super.xx  (注：xx是成员名)；<br>2.创建子类对象时，默认会调用父类的无参构造方法，可通过super指定调用父类其他构造方法，格式：s uper(yy) (注：yy是父类构造方法需要传递的参数) </p><h2 id="8-Given-the-following-code-What-is-the-result"><a href="#8-Given-the-following-code-What-is-the-result" class="headerlink" title="8.Given the following code:() What is the result?"></a>8.Given the following code:() What is the result?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private static int j &#x3D; 0;</span><br><span class="line">    private static Boolean methodB(int k) &#123;</span><br><span class="line">        j +&#x3D; k;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void methodA(int i) &#123;</span><br><span class="line">        boolean b;</span><br><span class="line">        b &#x3D; i &lt; 10 | methodB(4);</span><br><span class="line">        b &#x3D; i &lt; 10 || methodB(8);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        methodA(0);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.The program prints”0”<br>B.The program prints”4”<br>C.The program prints”8”<br>D.The program prints”12”<br>E.The code does not complete.</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>选 B<br>在main函数中先调用methodA（0）<br>在methodA中，第二行<br>b = i &lt; 10 | methodB(4); //中间为与计算符，执行完methodB(4)后，j = 4<br>methodA中，第三行<br>b = i &lt; 10 || methodB(8);//中间为或计算符，因为i &lt; 10 已成立，不需要后续计算<br>所以最后结果输出为4</p><h2 id="9-一个文件中的字符要写到另一个文件中，首先需要（-）？"><a href="#9-一个文件中的字符要写到另一个文件中，首先需要（-）？" class="headerlink" title="9.一个文件中的字符要写到另一个文件中，首先需要（ ）？"></a>9.一个文件中的字符要写到另一个文件中，首先需要（ ）？</h2><p>A.System.out.print (buffer[i]);<br>B.FileOutputStream fout = new FileOutputStream(this.filename);<br>C.FileInputStream fin = new FileInputStream(this.filename);<br>D.System.in.read(buffer)</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>程序的逻辑很简单。程序必须打开两个文件，以可读的方式打开一个已有文件和以可写的方式打开一个新文件，后将已有文件中的内容，暂时存放在内存中，再写入新的文件，后关闭所有文件，程序结束。<br>根据题意，首先需要读入一个文件中的字符，需要FileInputStream fin = new FileInputStream(this.filename);</p><h2 id="10-阅读以下-foo-函数，请问它的时间复杂度是："><a href="#10-阅读以下-foo-函数，请问它的时间复杂度是：" class="headerlink" title="10. 阅读以下 foo 函数，请问它的时间复杂度是："></a>10. 阅读以下 foo 函数，请问它的时间复杂度是：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int foo(intarray[], int n, int key)&#123;</span><br><span class="line">int n1&#x3D;0,n2&#x3D;n-1,m;</span><br><span class="line">while(n1&lt;&#x3D;n2)&#123;</span><br><span class="line">m&#x3D;(n1+n2)&#x2F;2;</span><br><span class="line">if(array[m]&#x3D;&#x3D;key)</span><br><span class="line">return m;</span><br><span class="line">if(array[m]&gt;key)</span><br><span class="line">n2&#x3D;m-1;</span><br><span class="line">else</span><br><span class="line">n1&#x3D;m+1;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.O(n2)<br>B.O(n3)<br>C.O(log(n))<br>D.O(n)</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>二分查找时间复杂度为O（logn） ，关注我的微信公众号，里面有关于时间复杂度和空间复杂度介绍的文章。</p><h2 id="11-下列关于管道（Pipe）通信的叙述中，正确的是（）？"><a href="#11-下列关于管道（Pipe）通信的叙述中，正确的是（）？" class="headerlink" title="11.下列关于管道（Pipe）通信的叙述中，正确的是（）？"></a>11.下列关于管道（Pipe）通信的叙述中，正确的是（）？</h2><p>A.进程对管道进行读操作和写操作都可能被阻塞<br>B.一个管道只能有一个进程或一个写进程对其操作<br>C.一个管道可实现双向数据传输<br>D.管道的容量仅受磁盘容量大小限制</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>A.正确，因为管道为空，读操作会被阻塞；管道满了，写操作会被阻塞<br>B.可以有多个进程对其读；也可以有多个进程写，只不过不能同时写。并且题目没有说“同时”，B不对<br>C.匿名管道只能单向；命名管道可以双向；所以C过于绝对<br>D.管道是内存中的，所以D不对</p><h2 id="12-要导入java-awt-event下面的所有类，叙述正确的是？"><a href="#12-要导入java-awt-event下面的所有类，叙述正确的是？" class="headerlink" title="12.要导入java/awt/event下面的所有类，叙述正确的是？()"></a>12.要导入java/awt/event下面的所有类，叙述正确的是？()</h2><p>A.import java.awt.<em>和import java.awt.event.*都可以<br>B.只能是import java.awt.</em><br>C.只能是import java.awt.event.*<br>D.import java.awt.<em>和import java.awt.event.</em>都不可以</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>导包只可以导到当前层，不可以再导入包里面的包中的类 </p><h2 id="13-对于JVM内存配置参数："><a href="#13-对于JVM内存配置参数：" class="headerlink" title="13.对于JVM内存配置参数："></a>13.对于JVM内存配置参数：</h2><blockquote><p>-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3<br>,其最小内存值和Survivor区总大小分别是（） </p></blockquote><p>A.5120m，1024m<br>B.5120m，2048m<br>C.10240m，1024m<br>D.10240m，2048m</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>-Xmx：最大堆大小<br>-Xms：初始堆大小<br>-Xmn: 年轻代大小<br>-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值<br>年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。<br>-Xms初始堆大小即最小内存值为10240m </p><h2 id="14-URL-u-new-URL-“http-www-123-com-quot-。如果www-123-com不存在，则返回-。"><a href="#14-URL-u-new-URL-“http-www-123-com-quot-。如果www-123-com不存在，则返回-。" class="headerlink" title="14.URL u =new URL(“http://www.123.com&quot;);。如果www.123.com不存在，则返回______。"></a>14.URL u =new URL(“<a href="http://www.123.com&quot;);。如果www.123.com不存在，则返回______。" target="_blank" rel="noopener">http://www.123.com&quot;);。如果www.123.com不存在，则返回______。</a></h2><p>A.<a href="http://www.123.com" target="_blank" rel="noopener">http://www.123.com</a><br>B.””<br>C.null<br>D.抛出异常</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>new URL()时必须捕获检查异常，但这个异常是由于字符串格式和URL不符导致的，与网址是否存在无关。URL的toString方法返回字符串，无论网址是否存在</p><h2 id="15-存根（Stub）与以下哪种技术有关"><a href="#15-存根（Stub）与以下哪种技术有关" class="headerlink" title="15.存根（Stub）与以下哪种技术有关"></a>15.存根（Stub）与以下哪种技术有关</h2><p>A.交换<br>B.动态链接<br>C.动态加载<br>D.磁盘调度</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>理解为适配器模式，继承该类则不需要实现一个接口全部方法。</p><h2 id="16-Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述正确的是（）"><a href="#16-Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述正确的是（）" class="headerlink" title="16.Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述正确的是（）"></a>16.Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述正确的是（）</h2><p>A.ArrayList和LinkedList均实现了List接口<br>B.ArrayList的访问速度比LinkedList快<br>C.添加和删除元素时，ArrayList的表现更佳<br>D.HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值</p><p><strong>答案：</strong><br>A B D</p><p><strong>解析：</strong><br>关于D,值对象可以允许null</p><h2 id="17-下列说法正确的是（）？"><a href="#17-下列说法正确的是（）？" class="headerlink" title="17.下列说法正确的是（）？"></a>17.下列说法正确的是（）？</h2><p>A.我们直接调用Thread对象的run方法会报异常，所以我们应该使用start方法来开启一个线程<br>B.一个进程是一个独立的运行环境，可以被看做一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源<br>C.synchronized可以解决可见性问题，volatile可以解决原子性问题<br>D.ThreadLocal用于创建线程的本地变量，该变量是线程之间不共享的</p><p><strong>答案：</strong><br>B D</p><p><strong>解析：</strong><br>volatile与synchronized的区别：<br>volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.<br>volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.<br>volatile仅能实现变量的修改可见性,但不具备原子特性,而synchronized则可以保证变量的修改可见性和原子性.<br>volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.<br>volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化.</p><h2 id="18-对于构造方法，下列叙述正确的是（-）。"><a href="#18-对于构造方法，下列叙述正确的是（-）。" class="headerlink" title="18.对于构造方法，下列叙述正确的是（ ）。"></a>18.对于构造方法，下列叙述正确的是（ ）。</h2><p>A.构造方法的优先级一般比代码块低。<br>B.构造方法的返回类型只能是void型。<br>C.构造方法的主要作用是完成对类的对象的初始化工作。<br>D.一般在创建新对象时，系统会自动调用构造方法。</p><p><strong>答案：</strong><br>A C D</p><p><strong>解析：</strong><br>A：静态成员变量或静态代码块&gt;main方法&gt;非静态成员变量或非静态代码块&gt;构造方法<br>B：think in java中提到构造器本身并没有任何返回值。<br>C: 构造方法的主要作用是完成对类的对象的初始化工作。<br>D: 一般在创建(new)新对象时，系统会自动调用构造方法。</p><h2 id="19-下列有关JAVA异常处理的叙述中正确的是（）"><a href="#19-下列有关JAVA异常处理的叙述中正确的是（）" class="headerlink" title="19.下列有关JAVA异常处理的叙述中正确的是（）"></a>19.下列有关JAVA异常处理的叙述中正确的是（）</h2><p>A.finally是为确保一段代码不管是否捕获异常都会被执行的一段代码<br>B.throws是用来声明一个成员方法可能抛出的各种非运行异常情况<br>C.final用于可以声明属性和方法，分别表示属性的不可变及方法的不可继承<br>D.throw是用来明确地抛出一个异常情况</p><p><strong>答案：</strong><br>A B D</p><p><strong>解析：</strong><br>C根本就跟异常处理没有关系，所以不选。</p><h2 id="20-character流和byte流的区别不包括（）"><a href="#20-character流和byte流的区别不包括（）" class="headerlink" title="20.character流和byte流的区别不包括（）"></a>20.character流和byte流的区别不包括（）</h2><p>A.每次读入的字节数不同<br>B.前者带有缓冲，后者没有。<br>C.前者是字符读入，后者是字节读入。<br>D.二者没有区别，可以互换。</p><p><strong>答案：</strong><br>A B D</p><p><strong>解析：</strong><br>字符流和字节流每次读入的字节数是不确定的，可能相同也可能不相同<br>例FileInputStream 的read() 方法每次读入一个字节，read(byte b[]) 每次读入b.length个字节<br>FileReader   的read()方法每次读入一个字符，read(char cbuf[], int offset, int length)每次读入length个字符<br>另外，字符流和字节流读入一个ASCII字符，字节数是相同的<br>例UTF-8字符编码中一个汉字占三个字节，数字1占一个字节，用字符流读入的数字1长度为一个字节，用字节流读入的数字1长度也为一个字节</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">Java笔试内容集合</a> 持续更新中….</p><p><a href="https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21" target="_blank" rel="noopener">ProcessOn是一个在线作图工具的聚合平台~</a></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-09cb22532754dd6f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（十）</title>
      <link href="/2019/09/25/interview/java/B-bishi10/"/>
      <url>/2019/09/25/interview/java/B-bishi10/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-07912ac8e1ca35de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（十）"></p><h2 id="1-Java中所有类的父类是（-）"><a href="#1-Java中所有类的父类是（-）" class="headerlink" title="1.Java中所有类的父类是（ ）?"></a>1.Java中所有类的父类是（ ）?</h2><p>A.Father<br>B.Dang<br>C.Exception<br>D.Object</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>D，java中Object是所有类的父亲,所有类的对象都是Class的实例。</p><h2 id="2-在-main-方法中给出数组buffer和下标i，如果将此下标中的元素显示到控制台上，需要使用（-）。"><a href="#2-在-main-方法中给出数组buffer和下标i，如果将此下标中的元素显示到控制台上，需要使用（-）。" class="headerlink" title="2.在 main() 方法中给出数组buffer和下标i，如果将此下标中的元素显示到控制台上，需要使用（ ）。"></a>2.在 main() 方法中给出数组buffer和下标i，如果将此下标中的元素显示到控制台上，需要使用（ ）。</h2><p>A.System.out.print (buffer[i]);<br>B.FileOutputStream fout = new FileOutputStream(this.filename);<br>C.FileInputStream fin = new FileInputStream(this.filename);<br>D.System.in.read(buffer)。</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>在main中已经给出字节数组，直接System.out.print();输出即可。BC都是文件输出输入流，D是标准输入流，所以不符合题意。</p><h2 id="3-“先进先出”的容器是："><a href="#3-“先进先出”的容器是：" class="headerlink" title="3. “先进先出”的容器是：( )"></a>3. “先进先出”的容器是：( )</h2><p>A.堆栈(Stack)<br>B.队列（Queue）<br>C.字符串(String)<br>D.迭代器(Iterator)</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>堆栈(Stack) ： 如子弹入弹夹一样  先进后出<br>队列（Queue）：如排队过隧道 先进先出</p><h2 id="4-下面关于静态方法说明正确的是？"><a href="#4-下面关于静态方法说明正确的是？" class="headerlink" title="4.下面关于静态方法说明正确的是？"></a>4.下面关于静态方法说明正确的是？</h2><p>A.在静态方法中可用this来调用本类的类方法<br>B.在静态方法中调用本类的静态方法时可直接调用<br>C.在静态方法中只能调用本类中的静态方法<br>D.在静态方法中绝对不能调用实例方法</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>解释一下D.可以通过在静态方法中创建对象，通过对象.调用非静态方法 </p><h2 id="5-以下定义一维数组的语句中，正确的是：（）？"><a href="#5-以下定义一维数组的语句中，正确的是：（）？" class="headerlink" title="5.以下定义一维数组的语句中，正确的是：（）？"></a>5.以下定义一维数组的语句中，正确的是：（）？</h2><p>A.int a [10]<br>B.int a []=new [10]<br>C.int  a[]  int a []=new int [10]<br>D.int a []={1,2,3,4,5}</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>1.int a[10]是错误的,声明的时候不能初始化容量,只有new的时候才可以<br>2.正确的是int a[]=new int[10];<br>3.不能两个声明连在一起<br>4.是正确的</p><h2 id="6-有如下代码：请写出程序的输出结果。"><a href="#6-有如下代码：请写出程序的输出结果。" class="headerlink" title="6.有如下代码：请写出程序的输出结果。"></a>6.有如下代码：请写出程序的输出结果。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        int x &#x3D; 0;</span><br><span class="line">        int y &#x3D; 0;</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line">        for (int z &#x3D; 0; z &lt; 5; z++) &#123;</span><br><span class="line">            if ((++x &gt; 2) &amp;&amp; (++y &gt; 2) &amp;&amp; (k++ &gt; 2))</span><br><span class="line">            &#123;</span><br><span class="line">                x++;</span><br><span class="line">                ++y;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x + ”” +y + ”” +k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.432<br>B.531<br>C.421<br>D.523</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>每次循环z,x,y,k对应数值为：<br>0,1,0,0<br>1,2,0,0<br>2,3,1,0<br>3,4,2,0<br>4,5,3,1<br>执行完这次以后，z++为5，不再进入for循环。</p><h2 id="7-BufferedReader的父类是以下哪个？"><a href="#7-BufferedReader的父类是以下哪个？" class="headerlink" title="7.BufferedReader的父类是以下哪个？"></a>7.BufferedReader的父类是以下哪个？</h2><p>A.FilterReader<br>B.InputStreamReader<br>C.PipedReader<br>D.Reader</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br><img src="https://upload-images.jianshu.io/upload_images/7326374-0a1c1b515ea1133b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="io流"></p><h2 id="8-以下代码在编译和运行过程中会出现什么情况"><a href="#8-以下代码在编译和运行过程中会出现什么情况" class="headerlink" title="8.以下代码在编译和运行过程中会出现什么情况 ?"></a>8.以下代码在编译和运行过程中会出现什么情况 ?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TestDemo&#123;</span><br><span class="line">    private int count;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestDemo test&#x3D;new TestDemo(88);</span><br><span class="line">        System.out.println(test.count);</span><br><span class="line">    &#125;</span><br><span class="line">     TestDemo(int a) &#123;</span><br><span class="line">         count&#x3D;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.编译运行通过，输出结果是88<br>B.编译时错误，count变量定义的是私有变量<br>C.编译时错误，System.out.println方法被调用时test没有被初始化<br>D.编译和执行时没有输出结果</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>private是私有变量，只能用于当前类中，题目中的main方法也位于当前类，所以可以正确输出 </p><h2 id="9-类方法中可以直接调用对象变量。（-）"><a href="#9-类方法中可以直接调用对象变量。（-）" class="headerlink" title="9.类方法中可以直接调用对象变量。（ ）"></a>9.类方法中可以直接调用对象变量。（ ）</h2><p>A.正确<br>B.错误</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>静态方法中不能调用对象的变量，因为静态方法在类加载时就初始化，对象变量需要在新建对象后才能使用</p><h2 id="10-内部类（也叫成员内部类）可以有4种访问权限。（-）？"><a href="#10-内部类（也叫成员内部类）可以有4种访问权限。（-）？" class="headerlink" title="10.内部类（也叫成员内部类）可以有4种访问权限。（  ）？"></a>10.内部类（也叫成员内部类）可以有4种访问权限。（  ）？</h2><p>A.正确<br>B.错误</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>把内部类理解成类的成员，成员有4种访问权限吧，内部类也是！分别为private、protected、public以及默认的访问权限</p><h2 id="11-关于以下application-说法正确是什么？"><a href="#11-关于以下application-说法正确是什么？" class="headerlink" title="11.关于以下application,说法正确是什么？"></a>11.关于以下application,说法正确是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    static int x&#x3D;10;</span><br><span class="line">    static &#123;x+&#x3D;5;&#125;</span><br><span class="line">    public static void main(String[] args) &#x2F;&#x2F;4</span><br><span class="line">        &#123;</span><br><span class="line">        System.out.println(&quot;x&#x3D;&quot;+x);</span><br><span class="line">    &#125;</span><br><span class="line">    static&#123;x&#x2F;&#x3D;3;&#125;;</span><br><span class="line">&#125;&#x2F;&#x2F;9</span><br></pre></td></tr></table></figure><p>A.4行与9行不能通过编译，因为缺少方法名和返回类型<br>B.编译通过，执行结果是：x=5<br>C.编译通过，执行结果是：x=3<br>D.9行不能通过编译，因为只能有一个静态初始化器</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>父类静态代码块–&gt;子类静态代码块–&gt;父类普通代码块–&gt;父类构造方法–&gt;子类代码块–&gt;子类构造方法；</p><h2 id="12-java程序内存泄露的最直接表现是（-）"><a href="#12-java程序内存泄露的最直接表现是（-）" class="headerlink" title="12.java程序内存泄露的最直接表现是（ ）"></a>12.java程序内存泄露的最直接表现是（ ）</h2><p>A.频繁FullGc<br>B.jvm崩溃<br>C.程序抛内存控制的Exception<br>D.java进程异常消失</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>首先理解一下内存泄漏的概念，内存泄漏就是对象引用消失了，对象内存却没有被回收。<br>A答案：FullGC 是老年代内存空间不足的时候，才会触发的，老年代一般是生命周期较长的对象或者大对象，频繁的 FullGC 不会可能会影响程序性能（因为内存回收需要消耗CPU等资源），但是并不会直接导致内存泄漏。<br>B 答案：JVM奔溃的可能是内存溢出引起的，也可能是其他导致 JVM崩溃的操作，例如设置了错误的JVM参数等。<br>C 答案：内存异常，最常见的 就是 StackOverFlow 了把，内存溢出，其实内存泄漏的最终结果就是内存溢出。所以，基本上C是对的答案。<br>D 答案：Java 进程异常消失，这个明显不对的。 </p><h2 id="13-以下程序运行后的输出结果是（）"><a href="#13-以下程序运行后的输出结果是（）" class="headerlink" title="13.以下程序运行后的输出结果是（）?"></a>13.以下程序运行后的输出结果是（）?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a&#x3D;1,b&#x3D;2,m&#x3D;0,n&#x3D;0,k;</span><br><span class="line"> </span><br><span class="line">k&#x3D;(n&#x3D;b&lt;a)&amp;&amp;(m&#x3D;a) ;</span><br><span class="line">printf(&quot;%d,%d\n&quot;,k,m);</span><br><span class="line"> </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.0,0<br>B.0,1<br>C.1,0<br>D.1,1</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong></p><h2 id="14-下面这条语句一共创建了多少个对象：String-s-”welcome”-”to”-360"><a href="#14-下面这条语句一共创建了多少个对象：String-s-”welcome”-”to”-360" class="headerlink" title="14.下面这条语句一共创建了多少个对象：String s=”welcome”+”to”+360;"></a>14.下面这条语句一共创建了多少个对象：String s=”welcome”+”to”+360;</h2><p>A.1<br>B.2<br>C.3<br>D.4</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>略，可以参考我的其他文字关于对String的介绍.</p><h2 id="15-下面这段程序的输出结果是（）"><a href="#15-下面这段程序的输出结果是（）" class="headerlink" title="15.下面这段程序的输出结果是（）"></a>15.下面这段程序的输出结果是（）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        split(12);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int split(int number) &#123;</span><br><span class="line">        if (number &gt; 1) &#123;</span><br><span class="line">            if (number % 2 !&#x3D; 0) System.out.print(split((number + 1) &#x2F; 2));</span><br><span class="line">                System.out.print(split(number &#x2F; 2));</span><br><span class="line">            &#125;</span><br><span class="line">        return number;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.12136<br>B.63121<br>C.61213<br>D.11236</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>考察方法进栈与出栈的顺序。先进后出 </p><h2 id="16-关于Java以下描述正确的有-？"><a href="#16-关于Java以下描述正确的有-？" class="headerlink" title="16.关于Java以下描述正确的有(  )？"></a>16.关于Java以下描述正确的有(  )？</h2><p>A.Class类是Object类的超类<br>B.Object类是一个final类<br>C.String类是一个final类<br>D.Class类可以装载其它类</p><p><strong>答案：</strong><br>C D</p><p><strong>解析：</strong><br>A.class类是Object的派生类<br>B.每个类都使用Object类作为超类，而final修饰的类不能被继承 </p><h2 id="17-以下哪几种是java的基本数据类型。"><a href="#17-以下哪几种是java的基本数据类型。" class="headerlink" title="17.以下哪几种是java的基本数据类型。"></a>17.以下哪几种是java的基本数据类型。</h2><p>A.String<br>B.int<br>C.boolean<br>D.Double</p><p><strong>答案：</strong><br>BC</p><p><strong>解析：</strong><br>Double在java.lang包，是double的一个包装类，不是基本数据类型 </p><h2 id="18-Java程序的种类有（-）"><a href="#18-Java程序的种类有（-）" class="headerlink" title="18. Java程序的种类有（ ）"></a>18. Java程序的种类有（ ）</h2><p>A.类（Class）<br>B.Applet<br>C.Application<br>D.Servlet</p><p><strong>答案：</strong><br>BCD</p><p><strong>解析：</strong><br>Java程序的种类有：<br>（a）内嵌于Web文件中，由浏览器来观看的_Applet<br>（b）可独立运行的 Application<br>（c）服务器端的 Servlets </p><h2 id="19-关于java中的数组，下面的一些描述，哪些描述是准确的：（）"><a href="#19-关于java中的数组，下面的一些描述，哪些描述是准确的：（）" class="headerlink" title="19.关于java中的数组，下面的一些描述，哪些描述是准确的：（）?"></a>19.关于java中的数组，下面的一些描述，哪些描述是准确的：（）?</h2><p>A.数组是一个对象，不同类型的数组具有不同的类<br>B.数组长度是可以动态调整的<br>C.数组是一个连续的存储结构<br>D.一个固定长度的数组可类似这样定义：int array[100]<br>E.两个数组用equals方法比较时，会逐个便利其中的元素，对每个元素进行比较<br>F.可以二维数组，且可以有多维数组，都是在java中合法的。</p><p><strong>答案：</strong><br>A C F</p><p><strong>解析：</strong><br>1.数组其实也是一个对象<br>2.定义一个一维数组的方式是：type[] arrayname或者type arrayname[];<br>3.一维数组的初始化：<br>（1）静态初始化<br>    1）int[] arr = new int[]{1, 2, 3}<br>    2）int[] arr = {1, 2, 3}<br>（2）动态初始化<br>  int[] arr = new int[3];<br>4.可以定义多维数组</p><h2 id="20-假如某个JAVA进程的JVM参数配置如下："><a href="#20-假如某个JAVA进程的JVM参数配置如下：" class="headerlink" title="20.假如某个JAVA进程的JVM参数配置如下："></a>20.假如某个JAVA进程的JVM参数配置如下：</h2><p>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,<br>请问eden区最终分配的大小是多少？</p><p>A.64M<br>B.500M<br>C.300M<br>D.100M</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>java -Xmx2G -Xms1G -Xmn500M -Xss128k<br>-Xmx2G：设置JVM最大可用内存为2G。<br>-Xms1G：设置JVM初始内存为1G。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。<br>-Xmn500M：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。<br>-XX:SurvivorRatio=3:新生代中又会划分为 Eden 区，from Survivor、to Survivor 区。<br>其中 Eden 和 Survivor 区的比例默认是 8:1:1，当然也支持参数调整 -XX:SurvivorRatio=3的话就是3:1:1。<br>故该题为500*（3/5）=300M. </p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">笔试内容集合</a> 持续更新中….</p><p><a href="https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21" target="_blank" rel="noopener">ProcessOn是一个在线作图工具的聚合平台</a></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-9c440377561b7c61?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（九）</title>
      <link href="/2019/09/23/interview/java/B-bishi09/"/>
      <url>/2019/09/23/interview/java/B-bishi09/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-92d511358b5b6b29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（九）"></p><h2 id="1-下面所示的java代码，运行时，会产生（）类型的异常-？"><a href="#1-下面所示的java代码，运行时，会产生（）类型的异常-？" class="headerlink" title="1.下面所示的java代码，运行时，会产生（）类型的异常 ？"></a>1.下面所示的java代码，运行时，会产生（）类型的异常 ？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int Arry_a[] &#x3D; new int[10];</span><br><span class="line">System.out.println(Arry_a[10]);</span><br></pre></td></tr></table></figure><p>A.ArithmeticException<br>B.NullPointException<br>C.IOException<br>D.ArrayIndexOutOfBoundsException</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>定义的数组长度为10，角标即为0-9,访问数组角标10会出现数组角标越界异常 </p><h2 id="2-下面关于继承的描述正确的是"><a href="#2-下面关于继承的描述正确的是" class="headerlink" title="2.下面关于继承的描述正确的是?"></a>2.下面关于继承的描述正确的是?</h2><p>A.在Java中只允许单一继承<br>B.在Java中一个类只能实现一个接口<br>C.在Java中一个类不能同时继承一个类和实现一个接口<br>D.Java的单一继承使代码不可靠</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>略</p><h2 id="3-Java-源程序文件的扩展名为（）"><a href="#3-Java-源程序文件的扩展名为（）" class="headerlink" title="3. Java 源程序文件的扩展名为（）"></a>3. Java 源程序文件的扩展名为（）</h2><p>A..java<br>B..class<br>C..exe<br>D..jar</p><p><strong>答案：</strong><br>A </p><p><strong>解析：</strong><br>略</p><h2 id="4-Java-语言用以下哪个类来把基本类型数据封装为对象（）"><a href="#4-Java-语言用以下哪个类来把基本类型数据封装为对象（）" class="headerlink" title="4.Java 语言用以下哪个类来把基本类型数据封装为对象（）"></a>4.Java 语言用以下哪个类来把基本类型数据封装为对象（）</h2><p>A.包装类<br>B.Class<br>C.Math<br>D.Object</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>略</p><h2 id="5-下列代码的执行结果是（）"><a href="#5-下列代码的执行结果是（）" class="headerlink" title="5. 下列代码的执行结果是（）"></a>5. 下列代码的执行结果是（）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> public class Test &#123;</span><br><span class="line">    public static int a &#x3D; 1;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a &#x3D; 10;</span><br><span class="line">        a++; Test.a++;</span><br><span class="line">        Test t&#x3D;new Test();</span><br><span class="line">        System.out.println(&quot;a&#x3D;&quot; + a + &quot; t.a&#x3D;&quot; + t.a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.a=10 t.a=3<br>B.a=11 t.a=2<br>C.a=12 t.a=1<br>D.a=11 t.a=1</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>值为1的a属于类变量也叫作成员变量，值为10的a是局部变量 首先a＋＋时就近原则，用局部变量10来加，Text.a直接用类名调用成员变量的情况，只能是static 修饰的成员变量1来加，然后又实例化了对象，在输出中第一个a＝ 用就近原则输出11，第二个t.a 对象只能调用类变量输出2 </p><h2 id="6-下面有关java-classloader说法错误的是"><a href="#6-下面有关java-classloader说法错误的是" class="headerlink" title="6.下面有关java classloader说法错误的是?"></a>6.下面有关java classloader说法错误的是?</h2><p>A.Java默认提供的三个ClassLoader是BootStrap ClassLoader，Extension ClassLoader，App ClassLoader<br>B.ClassLoader使用的是双亲委托模型来搜索类的<br>C.JVM在判定两个class是否相同时，只用判断类名相同即可，和类加载器无关<br>D.ClassLoader就是用来动态加载class文件到内存当中用的</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。</p><h2 id="7-以下那个数据结构是适用于”数据必须以相反的顺序存储然后检索”-（）"><a href="#7-以下那个数据结构是适用于”数据必须以相反的顺序存储然后检索”-（）" class="headerlink" title="7.以下那个数据结构是适用于”数据必须以相反的顺序存储然后检索” ? （）"></a>7.以下那个数据结构是适用于”数据必须以相反的顺序存储然后检索” ? （）</h2><p>A.Stack<br>B.Queue<br>C.List<br>D.Link List</p><p><strong>答案：</strong><br> A</p><p><strong>解析：</strong><br>栈-先进后出(比喻:坐电梯) 队列-先进先出(水管) list-链表(怎么存就怎么取) </p><h2 id="8-在-main-方法中给出的整型数组，如果将其写到一个文件中，需要（-）。"><a href="#8-在-main-方法中给出的整型数组，如果将其写到一个文件中，需要（-）。" class="headerlink" title="8. 在 main() 方法中给出的整型数组，如果将其写到一个文件中，需要（ ）。"></a>8. 在 main() 方法中给出的整型数组，如果将其写到一个文件中，需要（ ）。</h2><p>A.System.out.print (buffer[i]);<br>B.DataOutputStream dout = new DataOutputStream(new FileOutputStream(this.filename));<br>C.DataInputStream din = new DataInputStream(new FileInputStream(this.filename));。<br>D.System.in.read(buffer)。</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>input和output指的是对于程序而言。input是从文件读取进来，output是输出到文件。</p><h2 id="9-Please-write-the-output-result-。"><a href="#9-Please-write-the-output-result-。" class="headerlink" title="9.Please write the output result 。"></a>9.Please write the output result 。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">     public static void changeStr(String str)</span><br><span class="line">     &#123;</span><br><span class="line">         str &#x3D; &quot;welcome&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">     public static void main(String[] args)</span><br><span class="line">     &#123;</span><br><span class="line">         String str &#x3D; &quot;1234&quot;;</span><br><span class="line">         changeStr(str);</span><br><span class="line">         System.out.println(str);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.1234<br>B.welcome<br>C.空<br>D.不确定</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>string的值是不可改变的，所有试图更改String的行为都会创建一个新的String. </p><h2 id="10-关于String，StringBuilder以及StringBuffer，描述错误的是（）"><a href="#10-关于String，StringBuilder以及StringBuffer，描述错误的是（）" class="headerlink" title="10.关于String，StringBuilder以及StringBuffer，描述错误的是（）"></a>10.关于String，StringBuilder以及StringBuffer，描述错误的是（）</h2><p>A.对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象<br>B.StringBuffer是线程安全<br>C.StringBuilder是线程安全<br>D.可以修改StringBuilder和StringBuffer的内容</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>A，java中的字符串存储在字符串常量区，不会改变，发生改变是会新创建一个对象<br>B，StringBuffer是线程安全的StringBuilder<br>C，StringBuilder跟StringBuffer功能相同，区别是StringBuilder不是线程安全的<br>D，StringBuilder和StringBuffer底层都是以字符数组存放的，可以修改内容 </p><h2 id="11-以下哪个不属于JVM堆内存中的区域（）？"><a href="#11-以下哪个不属于JVM堆内存中的区域（）？" class="headerlink" title="11.以下哪个不属于JVM堆内存中的区域（）？"></a>11.以下哪个不属于JVM堆内存中的区域（）？</h2><p>A.survivor区<br>B.常量池<br>C.eden区<br>D.old区</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>jvm堆分为：新生代（一般是一个Eden区，两个Survivor区），老年代（old区）。<br>常量池属于 PermGen（方法区） </p><h2 id="12-运行下面代码，输出的结果是"><a href="#12-运行下面代码，输出的结果是" class="headerlink" title="12.运行下面代码，输出的结果是"></a>12.运行下面代码，输出的结果是</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public A() &#123;</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot;class A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">System.out.println(&quot;I&#39;m A class&quot;); &#125;</span><br><span class="line">    static &#123;</span><br><span class="line">System.out.println(&quot;class A static&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class B extends A &#123;</span><br><span class="line">    public B() &#123;</span><br><span class="line">        </span><br><span class="line">System.out.println(&quot;class B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">System.out.println(&quot;I&#39;m B class&quot;); &#125;</span><br><span class="line">    static &#123;</span><br><span class="line">System.out.println(&quot;class B static&quot;); &#125;</span><br><span class="line">    </span><br><span class="line">    public static</span><br><span class="line">void main(String[] args) &#123;</span><br><span class="line">new B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A static </span><br><span class="line">class B static    I&#39;m A class     </span><br><span class="line">class A    I&#39;m B class  </span><br><span class="line">class B</span><br></pre></td></tr></table></figure><p>B.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A static  I&#39;m A class   </span><br><span class="line">class A    class B static </span><br><span class="line">I&#39;m B class  class B</span><br></pre></td></tr></table></figure><p>C.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A static    class B static </span><br><span class="line">class A    I&#39;m A class      class B      </span><br><span class="line">I&#39;m B class</span><br></pre></td></tr></table></figure><p>D.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A static   class A  I&#39;m A</span><br><span class="line">class    class B static     </span><br><span class="line">class B I&#39;m B class</span><br></pre></td></tr></table></figure><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>①父类静态变量和静态代码块(按照声明顺序)；<br>②子类静态变量和静态代码块(按照声明顺序)；<br>③父类成员变量和代码块(按照声明顺序)；<br>④父类构造器；<br>⑤子类成员变量和代码块(按照声明顺序)；<br>⑥子类构造器。</p><h2 id="13-下列语句正确的是：？"><a href="#13-下列语句正确的是：？" class="headerlink" title="13.下列语句正确的是：？"></a>13.下列语句正确的是：？</h2><p>A.形式参数可被字段修饰符修饰<br>B.形式参数不可以是对象<br>C.形式参数为方法被调用时真正被传递的参数<br>D.形式参数可被视为local variable</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong></p><h2 id="14-以下程序输出结果是？"><a href="#14-以下程序输出结果是？" class="headerlink" title="14.以下程序输出结果是？"></a>14.以下程序输出结果是？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str &#x3D;</span><br><span class="line">&quot;&quot;;</span><br><span class="line">System.out.print(str.split(&quot;,&quot;).length);</span><br></pre></td></tr></table></figure><p>A.0<br>B.1<br>C.出现异常</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>略</p><h2 id="15-public-class-contained-in-a-Java-program-file-must-have-the-same-name-as-the-file-except-for-the-extension-“-java”"><a href="#15-public-class-contained-in-a-Java-program-file-must-have-the-same-name-as-the-file-except-for-the-extension-“-java”" class="headerlink" title="15.public class contained in a Java program file must have the same name as the file, except for the extension “.java”."></a>15.public class contained in a Java program file must have the same name as the file, except for the extension “.java”.</h2><p>A.FALSE<br>B.TRUE</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>题目的意思是：除去扩展名.java的部分，包含在java文件里的Java里的公共类必须与文件的名字相同。<br>但是公共的内部类是不需要和文件的名字相同的。 </p><h2 id="16-其中”c-getDeclaredMethods”的作用是"><a href="#16-其中”c-getDeclaredMethods”的作用是" class="headerlink" title="16.其中”c.getDeclaredMethods”的作用是:"></a>16.其中”c.getDeclaredMethods”的作用是:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line">public class DumpMethods&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Class c&#x3D;Class.forName(args[0]);</span><br><span class="line">Method m[]&#x3D;c.getDeclaredMethods();</span><br><span class="line">for (int i &#x3D; 0; i &lt; m.length; i++) &#123;</span><br><span class="line">System.out.println(m[i].toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">System.err.println(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.取得类的公有方法对象<br>B.取得类的所有公有方法名称<br>C.取得类的所有方法对象<br>D.选项都不正确</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>public Method[] getMethods()返回某个类的所有公用（public）方法包括其继承类的公用方法，包括它所实现接口的方法。<br>public Method[] getDeclaredMethods()对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。包括它所实现接口的方法。 </p><h2 id="17-运行代码，输出的结果是（）"><a href="#17-运行代码，输出的结果是（）" class="headerlink" title="17.运行代码，输出的结果是（）"></a>17.运行代码，输出的结果是（）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class P &#123;</span><br><span class="line">public static int abc &#x3D; 123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;P is init&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class S extends P &#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;S is init&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(S.abc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.P is init 123<br>B.S is init P is init 123<br>C.P is init S is init 123<br>D.S is init 123</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>属于被动引用不会出发子类初始化<br>1.子类引用父类的静态字段，只会触发子类的加载、父类的初始化，不会导致子类初始化<br>2.通过数组定义来引用类，不会触发此类的初始化<br>3.常量在编译阶段会进行常量优化，将常量存入调用类的常量池中， 本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p><h2 id="18-java中Hashtable-Vector-TreeSet-LinkedList哪些线程是安全的？"><a href="#18-java中Hashtable-Vector-TreeSet-LinkedList哪些线程是安全的？" class="headerlink" title="18.java中Hashtable, Vector, TreeSet, LinkedList哪些线程是安全的？"></a>18.java中Hashtable, Vector, TreeSet, LinkedList哪些线程是安全的？</h2><p>A.Hashtable<br>B.Vector<br>C.TreeSet<br>D.LinkedList</p><p><strong>答案：</strong><br>AB</p><p><strong>解析：</strong><br>HashMap是线程安全的HashMap<br>Vector是线程安全的ArrayList<br>TreeSet和LinkedList都不是线程安全的 </p><h2 id="19-下面哪些赋值语句是正确的（）"><a href="#19-下面哪些赋值语句是正确的（）" class="headerlink" title="19.下面哪些赋值语句是正确的（）"></a>19.下面哪些赋值语句是正确的（）</h2><p>A.long test=012<br>B.float f=-412<br>C.int other =(int)true<br>D.double d=0x12345678<br>E.byte b=128</p><p><strong>答案：</strong><br>A B D</p><p><strong>解析：</strong><br>A和B中long和float，正常定义需要加l和f，但是long和float属于基本类型，会进行转化，所以不会报出异常。AB正确<br>boolean类型不能和任何类型进行转换，会报出类型异常错误。所以C错。<br>D选项可以这样定义，D正确。<br>E选项中，byte的取值范围是-128—127。报出异常： cannot convert from int to byte.所以E选项错误。 </p><h2 id="20-Thread-sleep-是否会抛出checked-exception"><a href="#20-Thread-sleep-是否会抛出checked-exception" class="headerlink" title="20.Thread. sleep()是否会抛出checked exception?"></a>20.Thread. sleep()是否会抛出checked exception?</h2><p>A.会<br>B.不会</p><p><strong>答案：</strong><br>A  </p><p><strong>解析：</strong><br>Thread.sleep() 和 Object.wait(),都可以抛出 InterruptedException。这个异常是不能忽略的,因为它是一个检查异常(checked exception)</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">Java笔试内容集合</a> 持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-ccc493a58a1ff4ac?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（八）</title>
      <link href="/2019/09/22/interview/java/B-bishi08/"/>
      <url>/2019/09/22/interview/java/B-bishi08/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-c509a2ee3c9e5b10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（八）"></p><h2 id="1-以下关于构造函数的描述错误的是-（-）"><a href="#1-以下关于构造函数的描述错误的是-（-）" class="headerlink" title="1. 以下关于构造函数的描述错误的是 （ ）"></a>1. 以下关于构造函数的描述错误的是 （ ）</h2><p>A.每个类有且只能有一个构造函数。<br>B.构造函数是类的一种特殊函数，它的方法名必须与类名相同<br>C.构造函数的主要作用是完成对类的对象的初始化工作<br>D.一般在创建新对象时，系统会自动调用构造函数</p><p><strong>答案：</strong>   A</p><p><strong>解析：</strong><br>类除了无参构造方法，还有有参构造方法，有参构造方法还可以通过重载写出多参的构造方法（2参，3参，4参）<br>方法重载：同一个类中方法名称相同，而参数的类型或个数不同</p><h2 id="2-在面向对象编程里，经常使用is-a来说明对象之间的继承关系，下列对象中不具备继承关系的是？"><a href="#2-在面向对象编程里，经常使用is-a来说明对象之间的继承关系，下列对象中不具备继承关系的是？" class="headerlink" title="2.在面向对象编程里，经常使用is-a来说明对象之间的继承关系，下列对象中不具备继承关系的是？"></a>2.在面向对象编程里，经常使用is-a来说明对象之间的继承关系，下列对象中不具备继承关系的是？</h2><p>A.手机与小米手机<br>B.企业家与雷军<br>C.编程语言与Java<br>D.中国与北京</p><p><strong>答案：</strong>   D<br><strong>解析：</strong><br>小米手机是一个手机/雷军是一个企业家/java是一个编程语言/北京是一个中国吗？</p><h2 id="3-以下程序运行后的输出结果是（）"><a href="#3-以下程序运行后的输出结果是（）" class="headerlink" title="3.以下程序运行后的输出结果是（）?"></a>3.以下程序运行后的输出结果是（）?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;  </span><br><span class="line">int m&#x3D;12,n&#x3D;34;</span><br><span class="line">     </span><br><span class="line">printf(&quot;%d%d&quot;,m++,++n);</span><br><span class="line">     </span><br><span class="line">printf(&quot;%d%d\n&quot;,n++,++m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.12353514<br>B.12353513<br>C.12343514<br>D.12343513</p><p><strong>答案：</strong>   A<br><strong>解析：</strong>    &gt;m++ 先输出在自加，++m 先自加在输出 </p><h2 id="4-下列关于功能性注释不正确的说法是"><a href="#4-下列关于功能性注释不正确的说法是" class="headerlink" title="4.下列关于功能性注释不正确的说法是()?"></a>4.下列关于功能性注释不正确的说法是()?</h2><p>A.功能性注释嵌在源程序中，用于说明程序段或语句的功能以及数据的状态<br>B.注释用来说明程序段，需要在每一行都要加注释<br>C.可使用空行或缩进，以便很容易区分注释和程序<br>D.修改程序也应修改注释</p><p><strong>答案：</strong>   B<br><strong>解析：</strong>    略</p><h2 id="5-下面有关java和c-的描述，错误的是？"><a href="#5-下面有关java和c-的描述，错误的是？" class="headerlink" title="5.下面有关java和c++的描述，错误的是？"></a>5.下面有关java和c++的描述，错误的是？</h2><p>A.java是一次编写多处运行，c++是一次编写多处编译<br>B.c++和java支持多继承<br>C.Java不支持操作符重载，操作符重载被认为是c++的突出特征<br>D.java没有函数指针机制，c++支持函数指针</p><p><strong>答案：</strong>   B<br><strong>解析：</strong><br>JAVA没有指针的概念，被封装起来了，而C++有;JAVA不支持类的多继承，但支持接口多继承，C++支持类的多继承;C++支持操作符重载，JAVA不支持;JAVA的内存管理比C++方便，而且错误处理也比较好;C++的速度比JAVA快。<br>C++更适用于有运行效率要求的情况，JAVA适用于效率要求不高，但维护性要好的情况。</p><h2 id="6-应用程序的main方法中有以下语句，则输出的结果"><a href="#6-应用程序的main方法中有以下语句，则输出的结果" class="headerlink" title="6.应用程序的main方法中有以下语句，则输出的结果( )"></a>6.应用程序的main方法中有以下语句，则输出的结果( )</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1&#x3D;new String（ ” xyz ” ）;</span><br><span class="line">String s2&#x3D;new String（ ” xyz ” ）;</span><br><span class="line">Boolean b1&#x3D;s1.equals(s2);</span><br><span class="line">Boolean b2&#x3D;(s1&#x3D;&#x3D;s2);</span><br><span class="line">System .out.print(b1+ ” ” +b2);</span><br></pre></td></tr></table></figure><p>A.true false<br>B.false  true<br>C.true true<br>D.false  false</p><p><strong>答案：</strong>   A<br><strong>解析：</strong>    &gt;<br>String s1=new String（ ” xyz ” ）;            //创建了String类型的内容为xyz的s1对象<br>String s2=new String（ ” xyz ” ）;            //创建了String类型的内容为xyz的s2对象<br>Boolean b1=s1.equals(s2);                    //比较s1对象和s2对象的内容相等，返回true。<br>Boolean b2=(s1==s2);                        //比较s1和s2两个对象的存储地址是否相等，明显两者分别存储在不同的地址，所以返回：false。<br>故答案为：true  false</p><h2 id="7-执行如下程序，输出结果是（-）"><a href="#7-执行如下程序，输出结果是（-）" class="headerlink" title="7.执行如下程序，输出结果是（ ）?"></a>7.执行如下程序，输出结果是（ ）?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">     private int data;</span><br><span class="line">     int result &#x3D; 0;</span><br><span class="line">     public void m()</span><br><span class="line">     &#123;</span><br><span class="line">         result +&#x3D; 2;</span><br><span class="line">         data +&#x3D; 2;</span><br><span class="line">         System.out.print(result + &quot;  &quot; + data);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> class ThreadExample extends Thread</span><br><span class="line"> &#123;</span><br><span class="line">     private Test mv;</span><br><span class="line">     public ThreadExample(Test mv)</span><br><span class="line">     &#123;</span><br><span class="line">         this.mv &#x3D; mv;</span><br><span class="line">     &#125;</span><br><span class="line">     public void run()</span><br><span class="line">     &#123;</span><br><span class="line">         synchronized(mv)</span><br><span class="line">         &#123;</span><br><span class="line">             mv.m();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> class ThreadTest</span><br><span class="line"> &#123;</span><br><span class="line">     public static void main(String args[])</span><br><span class="line">     &#123;</span><br><span class="line">         Test mv &#x3D; new Test();</span><br><span class="line">         Thread t1 &#x3D; new ThreadExample(mv);</span><br><span class="line">         Thread t2 &#x3D; new ThreadExample(mv);</span><br><span class="line">         Thread t3 &#x3D; new ThreadExample(mv);</span><br><span class="line">         t1.start();</span><br><span class="line">         t2.start();</span><br><span class="line">         t3.start();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>A.0 22 44 6<br>B.2 42 42 4<br>C.2 24 46 6<br>D.4 44 46 6</p><p><strong>答案：</strong>   C<br><strong>解析：</strong>    </p><p>Test mv =newTest()声明并初始化对data赋默认值<br>使用synchronized关键字加同步锁线程依次操作m()<br>t1.start();使得result=2,data=2,输出即为2 2<br>t2.start();使得result=4,data=4,输出即为4 4<br>t3.start();使得result=6,data=6,输出即为6 6<br>System.out.print(result +” “+ data);是print()方法不会换行,输出结果为2 24 46 6</p><h2 id="8-在-main-方法中给出的字节数组，如果将其显示到控制台上，需要（-）。"><a href="#8-在-main-方法中给出的字节数组，如果将其显示到控制台上，需要（-）。" class="headerlink" title="8. 在 main() 方法中给出的字节数组，如果将其显示到控制台上，需要（ ）。"></a>8. 在 main() 方法中给出的字节数组，如果将其显示到控制台上，需要（ ）。</h2><p>A.标准输出流System.out.println()。<br>B.建立字节输出流。<br>C.建立字节输入流。<br>D.标准输入流System.in.read()。</p><p><strong>答案：</strong>   A<br><strong>解析：</strong>    略</p><h2 id="9-假设num已经被创建为一个ArrayList对象，并且最初包含以下整数值：-0，0，4，2，5，0，3，0-。-执行下面的方法numQuest-最终的输出结果是什么？"><a href="#9-假设num已经被创建为一个ArrayList对象，并且最初包含以下整数值：-0，0，4，2，5，0，3，0-。-执行下面的方法numQuest-最终的输出结果是什么？" class="headerlink" title="9.假设num已经被创建为一个ArrayList对象，并且最初包含以下整数值：[0，0，4，2，5，0，3，0]。 执行下面的方法numQuest(),最终的输出结果是什么？"></a>9.假设num已经被创建为一个ArrayList对象，并且最初包含以下整数值：[0，0，4，2，5，0，3，0]。 执行下面的方法numQuest(),最终的输出结果是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;Integer&gt; nums;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;precondition: nums.size() &gt; 0</span><br><span class="line">&#x2F;&#x2F;nums contains Integer objects</span><br><span class="line">public void numQuest() &#123;</span><br><span class="line">int k &#x3D; 0;</span><br><span class="line">Integer zero &#x3D; new Integer(0);</span><br><span class="line">while (k &lt; nums.size()) &#123;</span><br><span class="line">if (nums.get(k).equals(zero))</span><br><span class="line">nums.remove(k);</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.[3, 5, 2, 4, 0, 0, 0, 0]<br>B.[0, 0, 0, 0, 4, 2, 5, 3]<br>C.[0, 0, 4, 2, 5, 0, 3, 0]<br>D.[0, 4, 2, 5, 3]</p><p><strong>答案：</strong>   D<br><strong>解析：</strong>    略，一步一步来就能算出</p><h2 id="10-以下哪一个正则表达式不能与字符串“https-www-tensorflow-org-”（不含引号）匹配？（）"><a href="#10-以下哪一个正则表达式不能与字符串“https-www-tensorflow-org-”（不含引号）匹配？（）" class="headerlink" title="10.以下哪一个正则表达式不能与字符串“https://www.tensorflow.org/”（不含引号）匹配？（）"></a>10.以下哪一个正则表达式不能与字符串“<a href="https://www.tensorflow.org/”（不含引号）匹配？（）" target="_blank" rel="noopener">https://www.tensorflow.org/”（不含引号）匹配？（）</a></h2><p>A.[a-z]+://[a-z.]+/<br>B.https[://]www[.]tensorflow[.]org[/]<br>C.[htps]+://<a href="http://www.tensorflow.org/" target="_blank" rel="noopener">www.tensorflow.org/</a><br>D.[a-zA-Z.:/]+</p><p><strong>答案：</strong>   B<br><strong>解析：</strong>    &gt;<br>[://],这是个很明显的陷阱。[ ] 里面是不重复的，所以等价于[:/]<br>如果[ ]后面没有带+号的话，是不会贪婪匹配的，就只能匹配到://中的其中一个 </p><h2 id="11-关于sleep和wait-以下描述错误的是？"><a href="#11-关于sleep和wait-以下描述错误的是？" class="headerlink" title="11.关于sleep和wait,以下描述错误的是？"></a>11.关于sleep和wait,以下描述错误的是？</h2><p>A.sleep是线程类的方法，wait是object的方法<br>B.sleep不释放对象锁，wait放弃对象锁<br>C.sleep暂停线程，但监控状态依然保持，结束后会自动恢复<br>D.wait进入等待锁定池，只有针对此对象发出notify方法获得对象锁进入运行状态</p><p><strong>答案：</strong>   D<br><strong>解析：</strong><br>D选项最终是进入就绪状态，而不是运行状态。</p><h2 id="12-以下描述正确的是"><a href="#12-以下描述正确的是" class="headerlink" title="12.以下描述正确的是"></a>12.以下描述正确的是</h2><p>A.CallableStatement是PreparedStatement的父接口<br>B.PreparedStatement是CallableStatement的父接口<br>C.CallableStatement是Statement的父接口<br>D.PreparedStatement是Statement的父接口</p><p><strong>答案：</strong>   B<br><strong>解析：</strong><br>CallableStatement继承自PreparedSatement，PreparedStatement继承自Statement</p><h2 id="13-volatile关键字的说法错误的是"><a href="#13-volatile关键字的说法错误的是" class="headerlink" title="13.volatile关键字的说法错误的是"></a>13.volatile关键字的说法错误的是</h2><p>A.能保证线程安全<br>B.volatile关键字用在多线程同步中，可保证读取的可见性<br>C.JVM保证从主内存加载到线程工作内存的值是最新的<br>D.volatile能禁止进行指令重排序</p><p><strong>答案：</strong>   A<br><strong>解析：</strong><br>出于运行速率的考虑，java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全。 </p><h2 id="14-以下表达式中，正确的是（）"><a href="#14-以下表达式中，正确的是（）" class="headerlink" title="14.以下表达式中，正确的是（）"></a>14.以下表达式中，正确的是（）</h2><p>A.byte i=128<br>B.boolean i=null<br>C.long i=0xfffL<br>D.double i=0.9239d</p><p><strong>答案：</strong>   C D<br><strong>解析：</strong>    null表示没有地址；null可以赋值给引用变量，不能将null赋给基本类型变量，例如int、double、float、boolean</p><h2 id="15-常用的servlet包的名称是？"><a href="#15-常用的servlet包的名称是？" class="headerlink" title="15.常用的servlet包的名称是？"></a>15.常用的servlet包的名称是？</h2><p>A.java.servlet<br>B.javax.servlet<br>C.servlet.http<br>D.javax.servlet.http</p><p><strong>答案：</strong>   B D<br><strong>解析：</strong><br>JEE5.0中的Servlet相关的就下面这几个包:<br>javax.servlet<br>javax.servlet.jsp<br>java.servlet.jsp.el<br>java.servlet.jsp.tagext<br>而最用得多的就是<br>javax.servlet<br>javax.servlet.http<br>这两个包了.</p><h2 id="16-Java的体系结构包含（-）。"><a href="#16-Java的体系结构包含（-）。" class="headerlink" title="16.Java的体系结构包含（ ）。"></a>16.Java的体系结构包含（ ）。</h2><p>A.Java编程语言<br>B.Java类文件格式<br>C.Java API<br>D.JVM</p><p><strong>答案：</strong>   A B C D<br><strong>解析：</strong>    略</p><h2 id="17-对于代码-var-a-10-42-取出-a-的整数部分，以下代码哪些是正确的？"><a href="#17-对于代码-var-a-10-42-取出-a-的整数部分，以下代码哪些是正确的？" class="headerlink" title="17.对于代码 var a = 10.42; 取出 a 的整数部分，以下代码哪些是正确的？"></a>17.对于代码 var a = 10.42; 取出 a 的整数部分，以下代码哪些是正确的？</h2><p>A.parseInt(a);<br>B.Math.floor(a);<br>C.Math.ceil(a);<br>D.a.split(‘.’)[0];</p><p><strong>答案：</strong>   A B<br><strong>解析：</strong>    &gt;Math.ceil(); ceiling（天花板） 所以向上取整<br>Math.floor();floor（地板）所以向下取整<br>split是对字符串的分割，而10.42编译器自动类型推断中应该是double类型的，所以d错误 </p><h2 id="18-判断一块内存空间是否符合垃圾收集器收集的标准有哪些？"><a href="#18-判断一块内存空间是否符合垃圾收集器收集的标准有哪些？" class="headerlink" title="18.判断一块内存空间是否符合垃圾收集器收集的标准有哪些？"></a>18.判断一块内存空间是否符合垃圾收集器收集的标准有哪些？</h2><p>A.给对象赋予了空值null,以下再没有调用过<br>B.对象重新分配了内存空间<br>C.给对象赋予了空值null<br>D.给对象赋予了新值</p><p><strong>答案：</strong>   A B D<br><strong>解析：</strong>    </p><p>在java语言中，判断一块内存空间是否符合垃圾收集器收集标准的标准只有两个：<br>1.给对象赋值为null，以下没有调用过。<br>2.给对象赋了新的值，重新分配了内存空间。</p><h2 id="19-局部内部类可以用哪些修饰符修饰？"><a href="#19-局部内部类可以用哪些修饰符修饰？" class="headerlink" title="19.局部内部类可以用哪些修饰符修饰？"></a>19.局部内部类可以用哪些修饰符修饰？</h2><p>A.public<br>B.private<br>C.abstract<br>D.final</p><p><strong>答案：</strong>   C D<br><strong>解析：</strong><br>局部内部类是放在代码块或方法中的，不能有访问控制修饰符，且不能用static修饰 </p><h2 id="20-Java-Thread的方法resume-负责重新开始被以下哪个方法中断的线程的执行（）。"><a href="#20-Java-Thread的方法resume-负责重新开始被以下哪个方法中断的线程的执行（）。" class="headerlink" title="20.Java.Thread的方法resume()负责重新开始被以下哪个方法中断的线程的执行（）。"></a>20.Java.Thread的方法resume()负责重新开始被以下哪个方法中断的线程的执行（）。</h2><p>A.stop<br>B.sleep<br>C.wait<br>D.suspend</p><p><strong>答案：</strong>   D<br><strong>解析：</strong><br>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">Java笔试内容集合</a> 持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-aca01fc5b3eba5c6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（七）</title>
      <link href="/2019/09/21/interview/java/B-bishi07/"/>
      <url>/2019/09/21/interview/java/B-bishi07/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-13e6b634527e9104.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（七）"></p><h2 id="1-下列程序执行后结果为"><a href="#1-下列程序执行后结果为" class="headerlink" title="1.下列程序执行后结果为( )?"></a>1.下列程序执行后结果为( )?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public int func1(int a, int b) &#123;</span><br><span class="line">        return a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">    public int func1(int a, int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ChildClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    A a &#x3D; new B();</span><br><span class="line">    B b &#x3D; new B();</span><br><span class="line">    System.out.println(&quot;Result&#x3D;&quot; + a.func1(100, 50));</span><br><span class="line">    System.out.println(&quot;Result&#x3D;&quot; + b.func1(100, 50));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.Result=150Result=150<br>B.Result=100Result=100<br>C.Result=100Result=150<br>D.Result=150Result=100</p><p><strong>答案：</strong><br>A<br><strong>解析：</strong><br>其实很简单，涉及转型的题目，分为向上或者向下转型。<br>关键的来了，不论向上或者向下转型，都是一句话，“编译看左边，运行看右边”。也就是编译时候，会看左边引用类型是否能正确编译通过，运行的时候是调用右边的对象的方法。就本题来说，编译时候会发现左边满足条件所以编译通过，运行时候又会调用右边也就是 class B 的方法，所以答案都是150。</p><h2 id="2-下列哪个类的声明是正确的？"><a href="#2-下列哪个类的声明是正确的？" class="headerlink" title="2.下列哪个类的声明是正确的？"></a>2.下列哪个类的声明是正确的？</h2><p>A.protected private number;<br>B.public abstract class Car{}<br>C.abstract private move(){}<br>D.abstract final class HI{}</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>抽象类的目的就是为了让子类实现他本身的方法<br>final修饰的东西不能被更改或继承<br>abstract存在的意义是为了让子类实现方法而存在，final的意义是不让子类进行修改。两者存在互斥关系</p><h2 id="3-关于抽象类叙述正确的是？"><a href="#3-关于抽象类叙述正确的是？" class="headerlink" title="3.关于抽象类叙述正确的是？ ( )"></a>3.关于抽象类叙述正确的是？ ( )</h2><p>A.抽象类不能实现接口<br>B.抽象类必须有“abstract class”修饰<br>C.抽象类必须包含抽象方法<br>D.抽象类也有类的特性，可以被实例化</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>A.抽象类是可以实现接口的，而且抽象类也可以继承自抽象类<br>B.对<br>C.抽象类指有abstract修饰的class，其可以包含抽象方法，也可以不包含<br>D.抽象类和接口都是不能被实例化的，只有具体的类才可以被实例化 </p><h2 id="4-若有定义语句：-int-a-10-double-b-3-14-则表达式-‘A’-a-b-值的类型是（）"><a href="#4-若有定义语句：-int-a-10-double-b-3-14-则表达式-‘A’-a-b-值的类型是（）" class="headerlink" title="4.若有定义语句： int a=10 ; double b=3.14 ; 则表达式 ‘A’+a+b 值的类型是（）"></a>4.若有定义语句： int a=10 ; double b=3.14 ; 则表达式 ‘A’+a+b 值的类型是（）</h2><p>A.char<br>B.int<br>C.double<br>D.float</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>char &lt; short &lt; int &lt; float &lt; double  不同类型运算结果类型向右边靠齐。</p><h2 id="5-When-is-the-text-“Hi-there”displayed"><a href="#5-When-is-the-text-“Hi-there”displayed" class="headerlink" title="5.When is the text “Hi there”displayed?"></a>5.When is the text “Hi there”displayed?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class StaticTest</span><br><span class="line">&#123;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(“Hi there”);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void print()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(“Hello”);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        StaticTest st1 &#x3D; new StaticTest();</span><br><span class="line">        st1.print();</span><br><span class="line">        StaticTest st2 &#x3D; new StaticTest();</span><br><span class="line">        st2.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.Never.<br>B.Each time a new object of type StaticTest is created.<br>C.Once when the class is loaded into the Java virtual machine.<br>D.Only when the main() method is executed.</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>类中静态语句块仅在类加载时被执行一次 </p><h2 id="6-在开发中使用泛型取代非泛型的数据类型（比如用ArrayList取代ArrayList），程序的运行时性能会变得更好。"><a href="#6-在开发中使用泛型取代非泛型的数据类型（比如用ArrayList取代ArrayList），程序的运行时性能会变得更好。" class="headerlink" title="6.在开发中使用泛型取代非泛型的数据类型（比如用ArrayList取代ArrayList），程序的运行时性能会变得更好。"></a>6.在开发中使用泛型取代非泛型的数据类型（比如用ArrayList<String>取代ArrayList），程序的运行时性能会变得更好。</h2><p>A.对<br>B.错</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>泛型仅仅是java的一颗语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的。 </p><h2 id="7-以下说法中正确的有？"><a href="#7-以下说法中正确的有？" class="headerlink" title="7.以下说法中正确的有？"></a>7.以下说法中正确的有？</h2><p>A.StringBuilder是 线程不安全的<br>B.Java类可以同时用 abstract和final声明<br>C.HashMap中，使用 get(key)==null可以 判断这个Hasmap是否包含这个key<br>D.volatile关键字不保证对变量操作的原子性</p><p><strong>答案：</strong><br>A D</p><p><strong>解析：</strong><br>String最慢的原因：<br>String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。<br>String：适用于少量的字符串操作的情况<br>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况<br>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 </p><h2 id="8-下面关于Java-package的描述，哪个是正确的-（）"><a href="#8-下面关于Java-package的描述，哪个是正确的-（）" class="headerlink" title="8.下面关于Java package的描述，哪个是正确的:（）"></a>8.下面关于Java package的描述，哪个是正确的:（）</h2><p>A.包不提供将所有类名分区为更易管理的块的机制.<br>B.包提供可见性控制机制.<br>C.包的一个重要属性是包内定义的所有类都可以通过该包外的代码访问<br>D.声明为包的一部分的类的.class文件可以存储在多个目录中. </p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong></p><p>包的作用:<br>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。<br>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。<br>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。<br>Java使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 </p><h2 id="9-下面代码执行后的结果为（-）？"><a href="#9-下面代码执行后的结果为（-）？" class="headerlink" title="9.下面代码执行后的结果为（ ）？"></a>9.下面代码执行后的结果为（ ）？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nt main()</span><br><span class="line">&#123;</span><br><span class="line">int sum&#x3D;0;</span><br><span class="line">int i&#x3D;0,j&#x3D;0;</span><br><span class="line">for(j&#x3D;0;j&lt;6;j++)</span><br><span class="line">&#123;</span><br><span class="line">if(j%2)continue;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;sum&#x3D;%d&quot;,sum);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.sum=1<br>B.sum=2<br>C.sum=3<br>D.其他几项都不对</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>吐槽点：1.Java题出现C语言的题目。2.定义变量i 等等（既然出现在360大厂的笔试题中，那么我们抛开吐槽点，我们来看下这道题的考点。）<br>考点：<br>1.continue:continue语句的作用是跳过本次循环体中余下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为仅结束本次循环。<br>2.if(j%2)（包含：if以及取模运算）：也就是求j除以2的余数（取模），if(j%3)判断j对3取余以后是否为0，如果不是0，执行if下面的语句,<br>如果是0，执行另外的语句(例如else下面的语句)<br>做题：<br>1.j=0,0%2=0 sum=1<br>2.j=1,1%2=1 sum=1<br>3.j=2,2%2=0 sum=2<br>4.j=3,3%2=1 sum=2<br>5.j=4,4%2=0 sum=3<br>6.j=5,5%2=1 sum=3</p><h2 id="10-关于static说法不正确的是（-）-？"><a href="#10-关于static说法不正确的是（-）-？" class="headerlink" title="10. 关于static说法不正确的是（ ） ？"></a>10. 关于static说法不正确的是（ ） ？</h2><p>A.可以直接用类名来访问类中静态方法(public权限)<br>B.静态块仅在类加载时执行一次<br>C.static方法中不能有用this调用的方法<br>D.不可以用对象名来访问类中的静态方法(public权限)</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>this表示当前类的对象，由static修饰的方法是由类直接调用，不需要创建对象，所以在static里不能用this.</p><h2 id="11-访问权限控制从最大权限到最小权限依次为：public、-包访问权限、protected和private-（）？"><a href="#11-访问权限控制从最大权限到最小权限依次为：public、-包访问权限、protected和private-（）？" class="headerlink" title="11.访问权限控制从最大权限到最小权限依次为：public、 包访问权限、protected和private （）？"></a>11.访问权限控制从最大权限到最小权限依次为：public、 包访问权限、protected和private （）？</h2><p>A.正确<br>B.错误</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>应该是：public&gt;protected&gt;默认(包访问权限)&gt;private，因为protected除了可以被同一包访问，还可以被包外的子类所访问</p><h2 id="12-函数（）把文件位置重定位到文件中的指定位置"><a href="#12-函数（）把文件位置重定位到文件中的指定位置" class="headerlink" title="12.函数（）把文件位置重定位到文件中的指定位置"></a>12.函数（）把文件位置重定位到文件中的指定位置</h2><p>A.fseek<br>B.fread<br>C.fopen<br>D.fgets</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>略</p><h2 id="13-关于spring说法错误的是（）？"><a href="#13-关于spring说法错误的是（）？" class="headerlink" title="13.关于spring说法错误的是（）？"></a>13.关于spring说法错误的是（）？</h2><p>A.spring是一个轻量级JAVA EE的框架集合<br>B.spring是“依赖注入”模式的实现<br>C.使用spring可以实现声明事务<br>D.spring提供了AOP方式的日志系统</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>spring没有提供AOP方式的日志系统<br>AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。<br>Spring通过对AOP的支持，借助log4j等Apache开源组件实现了日志系统。 </p><h2 id="14-以下JAVA程序代码的输出是"><a href="#14-以下JAVA程序代码的输出是" class="headerlink" title="14. 以下JAVA程序代码的输出是?"></a>14. 以下JAVA程序代码的输出是?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">System.out.println(14^3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.2744<br>B.13<br>C.17<br>D.11</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>位运算中的异或运算，将14和3分别表示成二进制，即1110和0011做异或。得出结果为1101，转成十进制即为13 </p><h2 id="15-下列哪一项的实现不可以添加为-TextField-对象的监听器（）？"><a href="#15-下列哪一项的实现不可以添加为-TextField-对象的监听器（）？" class="headerlink" title="15.下列哪一项的实现不可以添加为 TextField 对象的监听器（）？"></a>15.下列哪一项的实现不可以添加为 TextField 对象的监听器（）？</h2><p>A.MouseMotionListener<br>B.FocusListener<br>C.WindowsListener<br>D.ActionListener</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>SWinng的内容。<br>在单行文本输入区(Textfield)构件上可能发生的事件包括FocusEvent焦点事件，所对应的事件监听器是FocusListener；ActionEvent动作事件，所对应的事件监听器是ActionListener；MouseEvent鼠标事件，所对应的事件监听器是MouseMotionListener；</p><h2 id="16-jre-判断程序是否执行结束的标准是（）-？"><a href="#16-jre-判断程序是否执行结束的标准是（）-？" class="headerlink" title="16. jre 判断程序是否执行结束的标准是（） ？"></a>16. jre 判断程序是否执行结束的标准是（） ？</h2><p>A.所有的前台线程执行完毕<br>B.所有的后台线程执行完毕<br>C.所有的线程执行完毕<br>D.和以上都无关</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。<br>前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。 </p><h2 id="17-根据下面的代码，String-s-null-会抛出NullPointerException异常的有（）。"><a href="#17-根据下面的代码，String-s-null-会抛出NullPointerException异常的有（）。" class="headerlink" title="17.根据下面的代码，String s = null;会抛出NullPointerException异常的有（）。"></a>17.根据下面的代码，String s = null;会抛出NullPointerException异常的有（）。</h2><p>A.if( (s!=null) &amp; (s.length()&gt;0) )<br>B.if( (s!=null) &amp;&amp; (s.length()&gt;0) )<br>C.if( (s==null) | (s.length()==0) )<br>D.if( (s==null) || (s.length()==0) )</p><p><strong>答案：</strong><br>A C</p><p><strong>解析：</strong></p><p>逻辑运算符：&amp;&amp;和|| 是按照“短路”方式求值的。如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了<br>位移运算符：&amp;和| 运算符应用于布尔值，得到的结果也是布尔值，不按“短路”方式计算。即在得到计算结果之前，一定要计算两个操作数的值。</p><h2 id="18-A-B-C-D-中哪些是-setvar的重载？"><a href="#18-A-B-C-D-中哪些是-setvar的重载？" class="headerlink" title="18.A,B,C,D 中哪些是 setvar的重载？"></a>18.A,B,C,D 中哪些是 setvar的重载？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class methodover</span><br><span class="line">&#123;</span><br><span class="line">    public void setVar(int a, int b, float c) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.private void setVar(int a， float c， int b){}<br>B.protected void setVar(int a， int b， float c){}<br>C.public int setVar(int a， float c， int b){return a;}<br>D.public int setVar(int a， float c){return a;}</p><p><strong>答案：</strong><br>A C D</p><p><strong>解析：</strong><br>重载是在同一个类中，有多个方法名相同，参数列表不同(参数个数不同，参数类型不同),与方法的返回值无关，与权限修饰符无关，B中的参数列表和题目的方法完全一样了。 </p><h2 id="19-下面有关java的引用类型，说法正确的有？"><a href="#19-下面有关java的引用类型，说法正确的有？" class="headerlink" title="19.下面有关java的引用类型，说法正确的有？"></a>19.下面有关java的引用类型，说法正确的有？</h2><p>A.对于一个对象来说，只要有强引用的存在，它就会一直存在于内存中<br>B.如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br>C.如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存<br>D.一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的空间</p><p><strong>答案：</strong><br>A B C D</p><p><strong>解析：</strong><br>1、强引用：一个对象赋给一个引用就是强引用，比如new一个对象，一个对象被赋值一个对象。<br>2、软引用：用SoftReference类实现，一般不会轻易回收，只有内存不够才会回收。<br>3、弱引用：用WeekReference类实现，一旦垃圾回收已启动，就会回收。<br>4、虚引用：不能单独存在，必须和引用队列联合使用。主要作用是跟踪对象被回收的状态。</p><h2 id="20-以下类型为Final类型的为（）？"><a href="#20-以下类型为Final类型的为（）？" class="headerlink" title="20.以下类型为Final类型的为（）？"></a>20.以下类型为Final类型的为（）？</h2><p>A.HashMap<br>B.StringBuffer<br>C.String<br>D.Hashtable</p><p><strong>答案：</strong><br>B F</p><p><strong>解析：</strong><br>StringBuilder , StringBuffer ,String都是 final </p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=8&sn=9bcd23fe579a559f3f4a3f89e3b8952d" target="_blank" rel="noopener">Java笔试内容集合</a> 欢迎关注，持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-0814ddebc590883b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（六）</title>
      <link href="/2019/09/20/interview/java/B-bishi06/"/>
      <url>/2019/09/20/interview/java/B-bishi06/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-2cfeaad888b917d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（六）"></p><h2 id="1-在Java中，一个类可同时定义许多同名的方法，这些方法的形式参数个数、类型或顺序各不相同，传回的值也可以不相同。这种面向对象程序的特性称为"><a href="#1-在Java中，一个类可同时定义许多同名的方法，这些方法的形式参数个数、类型或顺序各不相同，传回的值也可以不相同。这种面向对象程序的特性称为" class="headerlink" title="1.在Java中，一个类可同时定义许多同名的方法，这些方法的形式参数个数、类型或顺序各不相同，传回的值也可以不相同。这种面向对象程序的特性称为?"></a>1.在Java中，一个类可同时定义许多同名的方法，这些方法的形式参数个数、类型或顺序各不相同，传回的值也可以不相同。这种面向对象程序的特性称为?</h2><p>A.隐藏<br>B.覆盖<br>C.重载<br>D.Java不支持此特性</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>略</p><h2 id="2-编译-Java-源程序文件产生的字节码文件的扩展名为（）？"><a href="#2-编译-Java-源程序文件产生的字节码文件的扩展名为（）？" class="headerlink" title="2.编译 Java 源程序文件产生的字节码文件的扩展名为（）？"></a>2.编译 Java 源程序文件产生的字节码文件的扩展名为（）？</h2><p>A.java<br>B.class<br>C.html<br>D.exe</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>送分题</p><h2 id="3-以下程序的运行结果是（）-？"><a href="#3-以下程序的运行结果是（）-？" class="headerlink" title="3.以下程序的运行结果是（） ？"></a>3.以下程序的运行结果是（） ？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Increment</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String args[])</span><br><span class="line">    &#123;</span><br><span class="line">        int a;</span><br><span class="line">        a &#x3D; 6;</span><br><span class="line">        System.out.print(a);</span><br><span class="line">        System.out.print(a++);</span><br><span class="line">        System.out.print(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.666<br>B.667<br>C.677<br>D.676</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>a++很好记的，表示先用后+，而++a表示先+后用。看+在前在后，也决定第一步。 </p><h2 id="4-有以下程序片段且Interesting不是内部类，下列哪个选项不能插入到行1。（-）"><a href="#4-有以下程序片段且Interesting不是内部类，下列哪个选项不能插入到行1。（-）" class="headerlink" title="4.有以下程序片段且Interesting不是内部类，下列哪个选项不能插入到行1。（ ）"></a>4.有以下程序片段且Interesting不是内部类，下列哪个选项不能插入到行1。（ ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">2.public class Interesting&#123;</span><br><span class="line">3. &#x2F;&#x2F; 省略代码</span><br><span class="line">4.&#125;</span><br></pre></td></tr></table></figure><p>A.import java.awt.*;<br>B.package mypackage;<br>C.class OtherClass{  }<br>D.public class MyClass{ }</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>在同一个java原文件中，可以有多个class类，但是只有有一个公共的 public class </p><h2 id="5-Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#5-Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="5.Math.round(11.5) 等于多少 (). Math.round(-11.5) 等于多少 (  )?"></a>5.Math.round(11.5) 等于多少 (). Math.round(-11.5) 等于多少 (  )?</h2><p>A.11 ,-11<br>B.11 ,-12<br>C.12 ,-11<br>D.12 ,-12</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong></p><ul><li>floor:意为地板，指向下取整，返回不大于它的最大整数 </li><li>ceil:意为天花板，指向上取整，返回不小于它的最小整数 </li><li>round:意为大约，表示“四舍五入”，而四舍五入是往大数方向入。</li><li>Math.round(11.5)的结果为12，Math.round(-11.5)的结果为-11而不是-12。</li></ul><h2 id="6-一个以“-java”为后缀的源文件"><a href="#6-一个以“-java”为后缀的源文件" class="headerlink" title="6.一个以“.java”为后缀的源文件"></a>6.一个以“.java”为后缀的源文件</h2><p>A.只能包含一个public类，类名必须与文件名相同<br>B.只能包含与文件名相同的public类以及其中的内部类<br>C.只能有一个与文件名相同的public类，可以包含其他非public类（不考虑内部类）<br>D.可以包含任意public类</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>.java文件可以包含多个类，唯一的限制就是：一个文件中只能有一个public类，并且此public类必须与文件名相同。而且这些类和写在多个文件中没有区别。</p><h2 id="7-关于Float，下列说法错误的是-？"><a href="#7-关于Float，下列说法错误的是-？" class="headerlink" title="7.关于Float，下列说法错误的是() ？"></a>7.关于Float，下列说法错误的是() ？</h2><p>A.Float是一个类<br>B.Float在java.lang包中<br>C.Float a=1.0是正确的赋值方法<br>D.Float a= new Float(1.0)是正确的赋值方法</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>1.Float是类，float不是类.<br>2.查看JDK源码就可以发现Byte，Character，Short，Integer，Long，Float，Double，Boolean都在java.lang包中.<br>3.Float正确复制方式是Float f=1.0f,若不加f会被识别成double型,double无法向float隐式转换.<br>4.Float a= new Float(1.0)是正确的赋值方法，但是在1.5及以上版本引入自动装箱拆箱后，会提示这是不必要的装箱的警告，通常直接使用Float f=1.0f. </p><h2 id="8-子类要调用继承自父类的方法，必须使用super关键字。"><a href="#8-子类要调用继承自父类的方法，必须使用super关键字。" class="headerlink" title="8.子类要调用继承自父类的方法，必须使用super关键字。"></a>8.子类要调用继承自父类的方法，必须使用super关键字。</h2><p>A.正确<br>B.错误</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>1、子类构造函数调用父类构造函数用super<br>2、子类重写父类方法后，若想调用父类中被重写的方法，用super<br>3、未被重写的方法可以直接调用。</p><h2 id="9-下列属于容器的组件有（）？"><a href="#9-下列属于容器的组件有（）？" class="headerlink" title="9.下列属于容器的组件有（）？"></a>9.下列属于容器的组件有（）？</h2><p>A.JButton<br>B.JPanel<br>C.Thread<br>D.JTextArea</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>JPanel是Java图形用户界面（GUI）工具包中的面板容器类，包含在javax.swing包中，是一种轻量级容器，可以加入到JFrame窗体中。JPanel默认的布局管理器是FlowLayout，其自身可以嵌套组合，在不同子容器中可包含其他组件(component),如JButton、JTextArea、JTextField等，功能是对对窗体上的这些控件进行组合，相当于C++和C#中的Panel类。 </p><h2 id="10-我们在程序中经常使用“System-out-println-”来输出信息，语句中的System是包名，out是类名，println是方法名。"><a href="#10-我们在程序中经常使用“System-out-println-”来输出信息，语句中的System是包名，out是类名，println是方法名。" class="headerlink" title="10.我们在程序中经常使用“System.out.println()”来输出信息，语句中的System是包名，out是类名，println是方法名。"></a>10.我们在程序中经常使用“System.out.println()”来输出信息，语句中的System是包名，out是类名，println是方法名。</h2><p>A.对<br>B.错</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>system是java.lang中的一个类，out是System内的一个成员变量，这个变量是一个java.io.PrintStream类的对象，println就是一个方法了。</p><h2 id="11-正则表达式中，表示匹配非数字字符的字符是（）？"><a href="#11-正则表达式中，表示匹配非数字字符的字符是（）？" class="headerlink" title="11.正则表达式中，表示匹配非数字字符的字符是（）？"></a>11.正则表达式中，表示匹配非数字字符的字符是（）？</h2><p>A.\b<br>B.\d<br>C.\B<br>D.\D</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>大写表示“非”，d表示digit数字。非数字就是\D, w表示word，非单词就是\W </p><h2 id="12-对于以下代码段，4个输出语句中输出true的个数是-。"><a href="#12-对于以下代码段，4个输出语句中输出true的个数是-。" class="headerlink" title="12.对于以下代码段，4个输出语句中输出true的个数是(  )。"></a>12.对于以下代码段，4个输出语句中输出true的个数是(  )。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;</span><br><span class="line">class B extends A&#123;&#125;</span><br><span class="line">class C extends A&#123;&#125;</span><br><span class="line">class D extends B&#123;&#125;</span><br><span class="line">A obj &#x3D; new D();</span><br><span class="line">System.out.println(obj instanceof B);</span><br><span class="line">System.out.println(obj instanceof C);</span><br><span class="line">System.out.println(obj instanceof D);</span><br><span class="line">System.out.println(obj instanceof A);</span><br></pre></td></tr></table></figure><p>A.1<br>B.2<br>C.3<br>D.4</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>D属于B,D属于A,D属于D,D不属于C.所以选C </p><h2 id="13-在Java中，HashMap中是用哪些方法来解决哈希冲突的？"><a href="#13-在Java中，HashMap中是用哪些方法来解决哈希冲突的？" class="headerlink" title="13.在Java中，HashMap中是用哪些方法来解决哈希冲突的？"></a>13.在Java中，HashMap中是用哪些方法来解决哈希冲突的？</h2><p>A.开放地址法<br>B.二次哈希法<br>C.链地址法<br>D.建立一个公共溢出区</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>以上方法都是解决哈希填冲突的策略，但是在java.util.HashMap中，总体来说是使用的链地址法来解决冲突的。<br>当然了，使用链地址法会导致get的效率从o（1）降至o（n），所以在Java8中，使用的是平衡树来解决提高效率的。 </p><h2 id="14-关于匿名内部类叙述正确的是？"><a href="#14-关于匿名内部类叙述正确的是？" class="headerlink" title="14. 关于匿名内部类叙述正确的是？ ( )"></a>14. 关于匿名内部类叙述正确的是？ ( )</h2><p>A.匿名内部类可以继承一个基类，不可以实现一个接口<br>B.匿名内部类不可以定义构造器<br>C.匿名内部类不能用于形参<br>D.以上说法都不正确</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。 </p><h2 id="15-下下面哪一项不是加载驱动程序的方法？"><a href="#15-下下面哪一项不是加载驱动程序的方法？" class="headerlink" title="15.下下面哪一项不是加载驱动程序的方法？"></a>15.下下面哪一项不是加载驱动程序的方法？</h2><p>A.通过DriverManager.getConnection方法加载<br>B.调用方法 Class.forName<br>C.通过添加系统的jdbc.drivers属性<br>D.通过registerDriver方法注册</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>DriverManager.getConnection方法返回一个Connection对象，这是加载驱动之后才能进行的</p><h2 id="16-关于以下代码的说明，正确的是（）？"><a href="#16-关于以下代码的说明，正确的是（）？" class="headerlink" title="16.关于以下代码的说明，正确的是（）？"></a>16.关于以下代码的说明，正确的是（）？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1． class StaticStuff</span><br><span class="line">2． &#123;</span><br><span class="line">3． static int x&#x3D;10；</span><br><span class="line">4． static &#123; x+&#x3D;5；&#125;</span><br><span class="line">5． public static void main（String args[ ]）</span><br><span class="line">6． &#123;</span><br><span class="line">7． System.out.println(“x&#x3D;” + x);</span><br><span class="line">8． &#125;</span><br><span class="line">9． static &#123; x&#x2F;&#x3D;3;&#125;</span><br><span class="line">10. &#125;</span><br></pre></td></tr></table></figure><p>A.4行与9行不能通过编译，因为缺少方法名和返回类型<br>B.9行不能通过编译，因为只能有一个静态初始化器<br>C.编译通过，执行结果为：x=5<br>D.编译通过，执行结果为：x=3</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong></p><p>先执行：<br>1 static int x = 10；<br>再执行两个静态块：<br>1 static { x+=5; }<br>2 static { x/=3; }<br>最后执行main()：<br>1 System.out.println(“x=” + x);</p><p>所以x = 10  -&gt;  x = x +5 = 15  -&gt;  x = x / 3 = 5  打印x=5</p><h2 id="17-以下集合对象中哪几个是线程安全的（）？"><a href="#17-以下集合对象中哪几个是线程安全的（）？" class="headerlink" title="17.以下集合对象中哪几个是线程安全的（）？"></a>17.以下集合对象中哪几个是线程安全的（）？</h2><p>A.LinkedList<br>B.ArrayList<br>C.Vector<br>D.Hashtable</p><p><strong>答案：</strong><br>C D</p><p><strong>解析：</strong></p><p>简单记忆线程安全的集合类：喂！SHE！ 喂是指vector，S是指stack,H是指hashtable，E是指：Eenumeration </p><h2 id="18-下面哪些可能是重载的基本条件（）（注意：是可能为重载的基本条件）"><a href="#18-下面哪些可能是重载的基本条件（）（注意：是可能为重载的基本条件）" class="headerlink" title="18.下面哪些可能是重载的基本条件（）（注意：是可能为重载的基本条件）"></a>18.下面哪些可能是重载的基本条件（）（注意：是可能为重载的基本条件）</h2><p>A.参数的类型不同<br>B.参数的顺序不同<br>C.函数的返回值类型不同<br>D.参数的个数不同</p><p><strong>答案：</strong><br>A B D</p><p><strong>解析：</strong></p><p>重载的概念是：<br>方法名称相同，参数个数、次序、类型不同<br>因此重载对返回值没有要求，可以相同，也可以不同<br>但是如果参数的个数、类型、次序都相同，方法名也相同，仅返回值不同，则无法构成重载</p><h2 id="19-下面有关-java-类加载器-说法正确的是"><a href="#19-下面有关-java-类加载器-说法正确的是" class="headerlink" title="19.下面有关 java 类加载器,说法正确的是?()"></a>19.下面有关 java 类加载器,说法正确的是?()</h2><p>A.引导类加载器(bootstrap class loader):它用来加载 Java 的核心库,是用原生代码来实现的<br>B.扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。<br>C.系统类加载器(system class loader):它根据 Java 应用的类路径(CLASSPATH)来加载 Java 类<br>D.tomcat 为每个 App 创建一个 Loader,里面保存着此 WebApp 的 ClassLoader。需要加载 WebApp 下的类时,就取出 ClassLoader 来使用</p><p><strong>答案：</strong><br>A B C D</p><p><strong>解析：</strong><br>类的加载是由类加载器完成的，类加载器包括：根加载器(BootStrap)、扩展加载器(Extension)、系统加载器(System)和用户自定义类加载器（ java.lang.ClassLoader 的子类）。从 Java 2 (JDK 1.2)开始，类加载过程采取了父亲委托机制（ PDM ）。 PDM 更好的保证了 Java 平台的安全性，在该机制中， JVM 自带的 Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。 JVM 不会向 Java 程序提供对 Bootstrap 的引用。下面是关于几个类加载器的说明：</p><ul><li>Bootstrap ：一般用本地代码实现，负责加载 JVM 基础核心类库（ rt.jar ）；</li><li>Extension ：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap ；</li><li>system class loader：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。<br>用户自定义类加载器： java.lang.ClassLoader 的子类</li><li>父类委托机制是可以修改的，有些服务器就是自定义类加载器优先的。 </li></ul><h2 id="20-关于Java的一些概念，下面哪些描述是正确的："><a href="#20-关于Java的一些概念，下面哪些描述是正确的：" class="headerlink" title="20.关于Java的一些概念，下面哪些描述是正确的：( )"></a>20.关于Java的一些概念，下面哪些描述是正确的：( )</h2><p>A.所有的Java异常和错误的基类都是java.lang.Exception, 包括java.lang.RuntimeException<br>B.通过try … catch … finally语句，finally中的语句部分无论发生什么异常都会得到执行<br>C.java中所有的数据都是对象<br>D.Java通过垃圾回收回收不再引用的变量，垃圾回收时对象的finallize方法一定会得到执行<br>E.Java是跨平台的语言，无论通过哪个版本的Java编写的程序都能在所有的Java运行平台中运行<br>F.Java通过synchronized进行访问的同步，synchronized作用非静态成员方法和静态成员方法上同步的目标是不同的</p><p><strong>答案：</strong><br>B F</p><p><strong>解析：</strong><br>A:Java中所有错误和异常的父类是java.lang.Throwable<br>B：基本数据类型不是对象，不能用new的方法获取，但是每个基本数据类型都对应着封装类型，这些封装类型为了解决基本数据类型面向对象用的。<br>C:Java垃圾回收器负责回收无用对象占据的内存资源,但对象没有使用new获取了一块特殊区域，这块特殊区域的回收使用finallize（）<br>D：Java跨平台是因为有JVM的存在，Java的三个版本的运行需要各自不同的环境。</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">Java笔试内容集合</a> 欢迎关注，持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-5940e77d88203f24?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（五）</title>
      <link href="/2019/09/19/interview/java/B-bishi05/"/>
      <url>/2019/09/19/interview/java/B-bishi05/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-8a182e3da5ea417e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（五）"></p><h2 id="1-以下关于Integer与int的区别错误的是？"><a href="#1-以下关于Integer与int的区别错误的是？" class="headerlink" title="1.以下关于Integer与int的区别错误的是？"></a>1.以下关于Integer与int的区别错误的是？</h2><p>A.int是java提供的8种原始数据类型之一<br>B.Integer是java为int提供的封装类<br>C.int的默认值为0<br>D.Integer的默认值为1</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>略</p><h2 id="2-给定以下方法声明，调用执行mystery（1234）的输出结果？"><a href="#2-给定以下方法声明，调用执行mystery（1234）的输出结果？" class="headerlink" title="2.给定以下方法声明，调用执行mystery（1234）的输出结果？"></a>2.给定以下方法声明，调用执行mystery（1234）的输出结果？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;precondition:  x &gt;&#x3D;0</span><br><span class="line">public void mystery (int x)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(x % 10);</span><br><span class="line"> </span><br><span class="line">if ((x &#x2F; 10) !&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">mystery(x &#x2F; 10);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(x % 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.1441<br>B.43211234<br>C.3443<br>D.12344321</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>递归调用</p><h2 id="3-下面不是类及类成员的访问控制符的是-。（不考虑内部类的情况）"><a href="#3-下面不是类及类成员的访问控制符的是-。（不考虑内部类的情况）" class="headerlink" title="3.下面不是类及类成员的访问控制符的是( )。（不考虑内部类的情况）"></a>3.下面不是类及类成员的访问控制符的是( )。（不考虑内部类的情况）</h2><p>A.public<br>B.private<br>C.static<br>D.protected</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>类访问控制符只有三种：public ，private， protected  static和访问控制无关</p><h2 id="4-下列修饰符中与访问控制权限无关的是？（-）"><a href="#4-下列修饰符中与访问控制权限无关的是？（-）" class="headerlink" title="4.下列修饰符中与访问控制权限无关的是？（ ）"></a>4.下列修饰符中与访问控制权限无关的是？（ ）</h2><p>A.private<br>B.public<br>C.protected<br>D.final</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>private :        修饰私有变量<br>public :         修饰公有变量<br>protected:    修饰受保护变量<br>没有final, final用于保护变量不受改变</p><h2 id="5-局部变量能否和成员变量重名？"><a href="#5-局部变量能否和成员变量重名？" class="headerlink" title="5.局部变量能否和成员变量重名？"></a>5.局部变量能否和成员变量重名？</h2><p>A.可以，局部变量可以与成员变量重名，这时可用“this”来指向成员变量<br>B.可以，这时可用“local”关键字来指向局部变量<br>C.不能，局部变量不能与成员变量重名<br>D.不能，在一个类中不能有重名变量，不管是成员变量还是函数中的局部变量</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>JAVA访问变量采用就近原则，局部变量与成员变量重名时，局部变量比较近，使用局部变量</p><h2 id="6-下列说法正确的是"><a href="#6-下列说法正确的是" class="headerlink" title="6.下列说法正确的是()"></a>6.下列说法正确的是()</h2><p>A.在类方法中可用this来调用本类的类方法<br>B.在类方法中调用本类的类方法可直接调用<br>C.在类方法中只能调用本类的类方法<br>D.在类方法中绝对不能调用实例方法</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>在类方法中调用本类的类方法可直接调用。 实例方法也叫做对象方法。<br>类方法是属于整个类的，而实例方法是属于类的某个对象的。<br>由于类方法是属于整个类的，并不属于类的哪个对象，所以类方法的方法体中不能有与类的对象有关的内容。即类方法体有如下限制：<br>(1) 类方法中不能引用对象变量；<br>(2) 类方法中不能调用类的对象方法；<br>(3) 在类方法中不能使用super、this关键字。<br>(4)类方法不能被覆盖。<br>如果违反这些限制，就会导致程序编译错误。<br>与类方法相比，对象方法几乎没有什么限制：<br>(1) 对象方法中可以引用对象变量，也可以引用类变量；<br>(2) 对象方法中可以调用类方法；<br>(3) 对象方法中可以使用super、this关键字。</p><h2 id="7-关于依赖注入，下列选项中说法错误的是（）？"><a href="#7-关于依赖注入，下列选项中说法错误的是（）？" class="headerlink" title="7.关于依赖注入，下列选项中说法错误的是（）？"></a>7.关于依赖注入，下列选项中说法错误的是（）？</h2><p>A.依赖注入能够独立开发各组件，然后根据组件间关系进行组装<br>B.依赖注入提供使用接口编程<br>C.依赖注入使组件之间相互依赖，相互制约<br>D.依赖注入指对象在使用时动态注入</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>依赖注入目的是减少组件之间的耦合度，使开发变得简单。</p><h2 id="8-运行下面代码，输出的结果是（）"><a href="#8-运行下面代码，输出的结果是（）" class="headerlink" title="8.运行下面代码，输出的结果是（）"></a>8.运行下面代码，输出的结果是（）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public A() &#123;</span><br><span class="line">        System.out.println(&quot;class A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; System.out.println(&quot;I&#39;m A class&quot;); &#125;</span><br><span class="line">    static &#123; System.out.println(&quot;class A static&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class B extends A &#123;</span><br><span class="line">    public B() &#123;</span><br><span class="line">        System.out.println(&quot;class B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; System.out.println(&quot;I&#39;m B class&quot;); &#125;</span><br><span class="line">    static &#123; System.out.println(&quot;class B static&quot;); &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> new B();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static </span><br><span class="line">class B static </span><br><span class="line">I&#39;m A class </span><br><span class="line">class A</span><br><span class="line">I&#39;m B class </span><br><span class="line">class B</span><br></pre></td></tr></table></figure><p>B.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static</span><br><span class="line">I&#39;m A class</span><br><span class="line">class A</span><br><span class="line">class B static</span><br><span class="line">I&#39;m B class</span><br><span class="line">class B</span><br></pre></td></tr></table></figure><p>C.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static</span><br><span class="line">class B static</span><br><span class="line">class A</span><br><span class="line">I&#39;m A class </span><br><span class="line">class B</span><br><span class="line">I&#39;m B class</span><br></pre></td></tr></table></figure><p>D.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static</span><br><span class="line">class A</span><br><span class="line">I&#39;m A class</span><br><span class="line">class B static</span><br><span class="line">class B</span><br><span class="line">I&#39;m B class</span><br></pre></td></tr></table></figure><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>此题考虑 Java 中构造器、初始化块、静态初始化块的执行顺序。</p><p>静态初始化块 &gt; 初始化块 &gt; 构造器<br>父类 &gt; 子类<br>综合下来顺序就是：</p><p>父类静态初始化块<br>子类静态初始化块<br>父类初始化块<br>父类构造器<br>子类初始化块<br>子类构造器<br>需要注意静态初始化块是在类第一次加载的时候就会进行初始化。</p><h2 id="9-下面哪个标识符是合法的？"><a href="#9-下面哪个标识符是合法的？" class="headerlink" title="9.下面哪个标识符是合法的？"></a>9.下面哪个标识符是合法的？</h2><p>A.”9HelloWorld”<br>B.”_Hello World”<br>C.”Hello*World”<br>D.”Hello$World”</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>标识符是以字母开头的字母数字序列：<br>数字是指0~9，字母指大小写英文字母、下划线（_)和美元符号（$），也可以是Unicode字符集中的字符，如汉字；<br>字母、数字等字符的任意组合，不能包含+、- <em>等字符；<br>不能使用关键字；<br>大小写敏感<br>由此可以看出：<br>A：不可以数字开头<br>B：用下划线开头符合，但是中间有空格<br>C:不能包含“</em>”<br>排除ABC，答案即是D</p><h2 id="10-以下程序执行的结果是："><a href="#10-以下程序执行的结果是：" class="headerlink" title="10.以下程序执行的结果是："></a>10.以下程序执行的结果是：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class X&#123;</span><br><span class="line">    Y y&#x3D;new Y();</span><br><span class="line">    public X()&#123;</span><br><span class="line">        System.out.print(&quot;X&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Y&#123;</span><br><span class="line">    public Y()&#123;</span><br><span class="line">        System.out.print(&quot;Y&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Z extends X&#123;</span><br><span class="line">    Y y&#x3D;new Y();</span><br><span class="line">    public Z()&#123;</span><br><span class="line">        System.out.print(&quot;Z&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Z();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.ZYXX<br>B.ZYXY<br>C.YXYZ<br>D.XYZX</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>1.父类静态代码块 （java虚拟机加载类时，就会执行该块代码，故只执行一次）<br>2 .子类静态代码块 （java虚拟机加载类时，就会执行该块代码，故只执行一次）<br>3. 父类属性对象初始化<br>4.父类普通代码块（每次new,每次执行 ）<br>5. 父类构造函数（每次new,每次执行）<br>6.子 类 属性对象初始化<br>7.子类普通代码块（每次new,每次执行 ）<br>8.子 类构造函数（每次new,每次执行）</p><h2 id="11-以下声明合法的是"><a href="#11-以下声明合法的是" class="headerlink" title="11.以下声明合法的是"></a>11.以下声明合法的是</h2><p>A.default  String  s<br>B.public  final  static  native  int  w( )<br>C.abstract  double  d<br>D.abstract  final  double  hyperbolicCosine( )</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>A：java的访问权限有public、protected、private和default的，default不能修饰变量<br>C：普通变量不能用abstract修饰，abstract一般修饰方法和类<br>D：被定义为abstract的类需要被子类继承，但是被修饰为final的类是不能被继承和改写的心存疑问可以实验一下，看是否能通过编译.</p><h2 id="12-java用（）机制实现了进程之间的同步执行"><a href="#12-java用（）机制实现了进程之间的同步执行" class="headerlink" title="12.java用（）机制实现了进程之间的同步执行"></a>12.java用（）机制实现了进程之间的同步执行</h2><p>A.虚拟机<br>B.多个CPU<br>C.异步调用<br>D.监视器</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>同步执行，需要监视器，即锁。</p><h2 id="13-What-is-displayed-when-the-following-is-executed"><a href="#13-What-is-displayed-when-the-following-is-executed" class="headerlink" title="13.What is displayed when the following is executed;"></a>13.What is displayed when the following is executed;</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double d1&#x3D;-0.5;</span><br><span class="line">System.out.println(&quot;Ceil d1&#x3D;&quot;+Math.ceil(d1));</span><br><span class="line">System.out.println(&quot;floor d1&#x3D;&quot;+Math.floor(d1));</span><br></pre></td></tr></table></figure><p>A.Ceil d1=-0.0   floor d1=-1.0<br>B.Ceil d1=0.0    floor d1=-1.0<br>C.Ceil d1=-0.0  floor d1=-0.0<br>D.Ceil d1=0.0   floor d1=0.0<br>E.Ceil d1=0     floor d1=-1</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong></p><h2 id="14-有关下述Java代码描述正确的选项是-。"><a href="#14-有关下述Java代码描述正确的选项是-。" class="headerlink" title="14.有关下述Java代码描述正确的选项是____。"></a>14.有关下述Java代码描述正确的选项是____。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line">   private static void testMethod()&#123;</span><br><span class="line">        System.out.println(&quot;testMethod&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">        ((TestClass)null).testMethod();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.编译不通过<br>B.编译通过，运行异常，报NullPointerException<br>C.编译通过，运行异常，报IllegalArgumentException<br>D.编译通过，运行异常，报NoSuchMethodException<br>E.编译通过，运行异常，报Exception<br>F.运行正常，输出testMethod</p><p><strong>答案：</strong><br>F</p><p><strong>解析：</strong><br>1）此处是类对方法的调用，不是对象对方法的调用。<br>2）方法是static静态方法，直接使用”类.方法”即可，因为静态方法使用不依赖对象是否被创建。null可以被强制类型转换成任意类型（不是任意类型对象），于是可以通过它来执行静态方法。<br>3）非静态的方法用”对象.方法”的方式，必须依赖对象被创建后才能使用，若将testMethod()方法前的static去掉，则会报 空指针异常 。此处也验证了2）的观点<br>当然，不管是否静态方法，都是已经存在的，只是访问方式不同。</p><h2 id="15-下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持："><a href="#15-下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持：" class="headerlink" title="15.下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持：()"></a>15.下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持：()</h2><p>A.java.util.ConcurrentHashMap<br>B.java.util.Map<br>C.java.util.TreeMap<br>D.java.util.SortMap<br>E.java.util.Hashtable<br>F.java.util.HashMap</p><p><strong>答案：</strong><br>A E</p><p><strong>解析：</strong></p><ul><li>ConcurrentHashMap简称CHM,CHM 允许并发的读和线程安全的更新操作。在执行写操作时，CHM 只锁住部分的 Map，并发的更新是通过内部根据并发级别将 Map 分割成小部分实现的，高的并发级别会造成时间和空间的浪费，低的并发级别在写线程多时会引起线程间的竞争，CHM 的所有操作都是线程安全，CHM 返回的迭代器是弱一致性， fail-safe 并且不会抛出ConcurrentModificationException 异常，CHM不允许null的键值。可以使用 CHM 代替 HashTable，但要记住 CHM 不会锁住整个 Map</li><li>除了Hashtable，其他是非线性安全的。</li></ul><h2 id="16-JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是："><a href="#16-JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是：" class="headerlink" title="16.JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是：( )"></a>16.JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是：( )</h2><p>A.HttpSessionAttributeListener<br>B.HttpSessionBindingListener<br>C.HttpSessionObjectListener<br>D.HttpSessionListener;<br>E.HttpSession<br>F.HttpSessionActivationListener</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>HttpSessionAttributeListener：可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知；<br>HttpSessionBindingListener：当该对象从一个会话中被绑定或者解绑时通知该对象，这个对象由HttpSessionBindingEvent对象通知。这可能是servlet程序显式地从会话中解绑定属性的结果，可能是由于会话无效，也可能是由于会话超时；<br>HttpSessionObjectListener：没有该接口API；<br>HttpSessionListener：当web应用程序中的活动会话列表发生更改时通知该接口的实现类，为了接收该通知事件，必须在web应用程序的部署描述符中配置实现类；<br>HttpSessionActivationListener：绑定到会话的对象可以侦听容器事件，通知它们会话将被钝化，会话将被激活。需要一个在虚拟机之间迁移会话或持久会话的容器来通知所有绑定到实现该接口会话的属性。</p><h2 id="17-在java中重写方法应遵循规则的包括（）"><a href="#17-在java中重写方法应遵循规则的包括（）" class="headerlink" title="17.在java中重写方法应遵循规则的包括（）"></a>17.在java中重写方法应遵循规则的包括（）</h2><p>A.访问修饰符的限制一定要大于被重写方法的访问修饰符<br>B.可以有不同的访问修饰符<br>C.参数列表必须完全与被重写的方法相同<br>D.必须具有不同的参数列表</p><p><strong>答案：</strong><br>B C</p><p><strong>解析：</strong><br><strong>方法重写</strong></p><ul><li>参数列表必须完全与被重写方法的相同；</li><li>返回类型必须完全与被重写方法的返回类型相同；</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul><p><strong>方法重载</strong></p><ul><li>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><h2 id="18-What-might-cause-the-current-thread-to-stop-or-pause-executing"><a href="#18-What-might-cause-the-current-thread-to-stop-or-pause-executing" class="headerlink" title="18.What might cause the current thread to stop or pause executing"></a>18.What might cause the current thread to stop or pause executing</h2><p>A.An InterruptedException is thrown.<br>B.The thread executes a wait() call.<br>C.The thread constructs a new Thread.<br>D.A thread of higher priority becomes ready.<br>E.The thread executes a waitforID()call on a MediaTracker.</p><p><strong>答案：</strong><br>A B E</p><p><strong>解析：</strong><br>略</p><h2 id="19-下列说法错误的有（-）"><a href="#19-下列说法错误的有（-）" class="headerlink" title="19.下列说法错误的有（ ）"></a>19.下列说法错误的有（ ）</h2><p>A.Java面向对象语言容许单独的过程与函数存在<br>B.Java面向对象语言容许单独的方法存在<br>C.Java语言中的非静态方法属于类中的成员（member）<br>D.Java语言中的方法必定隶属于某一类（对象），调用方法与C语言的过程或C++语言的函数相同</p><p><strong>答案：</strong><br>A B C D</p><p><strong>解析：</strong><br>Java的静态方法属于类的成员，实例方法属于对象的成员。</p><h2 id="20-下列流当中，属于处理流的是：（）"><a href="#20-下列流当中，属于处理流的是：（）" class="headerlink" title="20.下列流当中，属于处理流的是：（）"></a>20.下列流当中，属于处理流的是：（）</h2><p>A.FilelnputStream<br>B.lnputStream<br>C.DatalnputStream<br>D.BufferedlnputStream</p><p><strong>答案：</strong><br>C D</p><p><strong>解析：</strong><br>此题考察对于java流的理解<br>节点流是实际工作的流，<br>处理流（我们叫包装流可能容易理解一点）设计的目的是让对流中数据的操作，转化成我们能更简单明了的看懂的数据（而不是二进制的字节等）的操作，但实际上增加了很多类，是io流变的更复杂<br>字节流必是一个接点流，字符流就是一个操作流<br>使用时，必须是有一个结点流，然后才能用操作流来包装结点流，即把结点流当参数传个操作流</p><blockquote><p>注：以上笔试题均来自网络，由笔者整理得出</p></blockquote><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">Java笔试内容集合</a> 欢迎关注，持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-f40a013aaaefba88?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（四）</title>
      <link href="/2019/09/18/interview/java/B-bishi04/"/>
      <url>/2019/09/18/interview/java/B-bishi04/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-05e294342b1b1794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（四）"></p><h2 id="1-编译Java-Application-源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为-。"><a href="#1-编译Java-Application-源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为-。" class="headerlink" title="1.编译Java  Application 源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为(      )。"></a>1.编译Java  Application 源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为(      )。</h2><p>A.java<br>B.class<br>C.html<br>D.exe</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>Java源程序的后缀名为“.java”,经过编译之后生成的字节码文件后缀名为“.class”</p><h2 id="2-问以下哪个说法是正确的？（）"><a href="#2-问以下哪个说法是正确的？（）" class="headerlink" title="2. 问以下哪个说法是正确的？（）"></a>2. 问以下哪个说法是正确的？（）</h2><p>A 派生出子类 B, B 派生出子类 C,并且在 java 源代码有如下声明：</p><ol><li>A a0=new A();</li><li>A a1=new B();</li><li>A a2=new C();</li></ol><p>A.只有第一行能通过编译<br>B.第1、2行能通过编译，但第3行编译出错<br>C.第1、2、3行能通过编译，但第2、3行运行时出错<br>D.第1行，第2行和第3行的声明都是正确的</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>这个题考了两个点：</p><ol><li>继承的传递性。</li><li>多态，父类引用指向子类对象。 </li></ol><h2 id="3-以下哪个接口的定义是正确的？（-）"><a href="#3-以下哪个接口的定义是正确的？（-）" class="headerlink" title="3.以下哪个接口的定义是正确的？（ ）"></a>3.以下哪个接口的定义是正确的？（ ）</h2><p>A.interface  B{  void print()  {  } ;}<br>B.interface  B{ static void print() ;}<br>C.abstract  interface  B  extends  A1, A2  //A1、A2为已定义的接口{ abstract  void  print(){  };}<br>D.interface  B{  void  print();}</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>A，接口中方法的默认修饰符时public abstract，抽象方法可是没有方法体的，没有大括号{}<br>B，JDK8中，接口中的方法可以被default和static修饰，但是！！！被修饰的方法必须有方法体。<br>C，注意一下，接口是可以多继承的。整个没毛病，和A选项一样，抽象方法不能有方法体 </p><h2 id="4-以下会产生信息丢失的类型转换是-）"><a href="#4-以下会产生信息丢失的类型转换是-）" class="headerlink" title="4.以下会产生信息丢失的类型转换是( ）"></a>4.以下会产生信息丢失的类型转换是( ）</h2><p>A.float  a=10<br>B.int a=（int）8846.0<br>C.byte  a=10； int b=-a<br>D.double d=100</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>会产生信息丢失不如说<strong>丢失精度</strong>，这样可能更容易明白，而精度丢失只会发生在从大范围到小范围的转换。上面四个选项，只有 B 是从 double 到 int ，也就是从大范围到小范围。</p><h2 id="5-以下代码的输出的正确结果是"><a href="#5-以下代码的输出的正确结果是" class="headerlink" title="5.以下代码的输出的正确结果是"></a>5.以下代码的输出的正确结果是</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">String s &#x3D; &quot;祝你考出好成绩！&quot;;</span><br><span class="line">System.out.println(s.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.24<br>B.16<br>C.15<br>D.8</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>java的String底层是char数组，它的length()返回数组大小，而unicode中一个汉字是可以用一个char表示的。 一个汉字等于一个字符字符是char，一个汉字也等于二个字节，字节是byte。</p><h2 id="6-java中，StringBuilder和StringBuffer的区别，下面说法错误的是？"><a href="#6-java中，StringBuilder和StringBuffer的区别，下面说法错误的是？" class="headerlink" title="6.java中，StringBuilder和StringBuffer的区别，下面说法错误的是？"></a>6.java中，StringBuilder和StringBuffer的区别，下面说法错误的是？</h2><p>A.StringBuffer是线程安全的<br>B.StringBuilder是非线程安全的<br>C.StringBuffer对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。<br>D.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>效率：String(大姐，出生于JDK1.0时代) 不可变字符序列&lt;StringBuffer(二姐，出生于JDK1.0时代)  线程安全的可变字符序列&lt;StringBuilder(小妹，出生于JDK1.5时代) 非线程安全的可变字符序列。Java中的String是一个类，而并非基本数据类型。string是值传入，不是引用传入。StringBuffer和StringBuilder可以算是双胞胎了，这两者的方法没有很大区别。但在线程安全性方面，StringBuffer允许多线程进行字符操作。这是因为在源代码中StringBuffer的很多方法都被关键字synchronized修饰了，而StringBuilder没有。StringBuilder的效率比StringBuffer稍高，如果不考虑线程安全，StringBuilder应该是首选。<strong>另外，JVM运行程序主要的时间耗费是在创建对象和回收对象上。</strong><br>关于D:因为进行字符串加运算时实际上是在堆中开辟大量空间，为了避免资源耗尽java编译器自动将String变量变为StringBulider而后进行append处理。</p><h2 id="7-下列关于修饰符混用的说法，错误的是"><a href="#7-下列关于修饰符混用的说法，错误的是" class="headerlink" title="7.下列关于修饰符混用的说法，错误的是( )"></a>7.下列关于修饰符混用的说法，错误的是( )</h2><p>A.abstract不能与final并列修饰同一个类<br>B.abstract类中不应该有private的成员<br>C.abstract方法必须在abstract类或接口中<br>D.static方法中能直接调用类里的非static的属性</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>1、abstract不能与final并列修饰同一个类  对的。<br>2、abstract类中不应该有private的成员  对的    ：abstract类中可以有private 但是不应该有。<br>3、abstract方法必须在abstract类或接口中  对的   ： 若类中方法有abstract修饰的，该类必须abstract修改。接口方法默认public abstract。<br>4、static方法中能处理非static的属性  错误  ：在JVM中static方法在静态区，静态区无法调用非静态区属性。</p><h2 id="8-如下语句通过算术运算和逻辑运算之后i和-j的结果是（-）"><a href="#8-如下语句通过算术运算和逻辑运算之后i和-j的结果是（-）" class="headerlink" title="8.如下语句通过算术运算和逻辑运算之后i和 j的结果是（ ）"></a>8.如下语句通过算术运算和逻辑运算之后i和 j的结果是（ ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i&#x3D;0;</span><br><span class="line">int j&#x3D;0;</span><br><span class="line">if((++i&gt;0)||(++j&gt;0))&#123;</span><br><span class="line">&#x2F;&#x2F;打印出i和j的值。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.i=0;j=0<br>B.i=1;j=1<br>C.i=0;j=1<br>D.i=1;j=0</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>考察的是短路逻辑的用法，即：当第一个逻辑表达式可以确定结果时，将不再进行剩余表达式的运算。</p><h2 id="9-以下是java-concurrent包下的4个类，选出差别最大的一个"><a href="#9-以下是java-concurrent包下的4个类，选出差别最大的一个" class="headerlink" title="9.以下是java concurrent包下的4个类，选出差别最大的一个"></a>9.以下是java concurrent包下的4个类，选出差别最大的一个</h2><p>A.Semaphore<br>B.ReentrantLock<br>C.Future<br>D.CountDownLatch</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>A、Semaphore：类，控制某个资源可被同时访问的个数;<br>B、ReentrantLock：类，具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大；<br>C、Future：接口，表示异步计算的结果；<br>D、CountDownLatch： 类，可以用来在一个线程中等待多个线程完成任务的类。</p><h2 id="10-下面有关java实例变量-局部变量-类变量和final变量的说法，错误的是？"><a href="#10-下面有关java实例变量-局部变量-类变量和final变量的说法，错误的是？" class="headerlink" title="10.下面有关java实例变量,局部变量,类变量和final变量的说法，错误的是？"></a>10.下面有关java实例变量,局部变量,类变量和final变量的说法，错误的是？</h2><p>A.实例变量指的是类中定义的变量，即成员变量，如果没有初始化，会有默认值。<br>B.局部变量指的是在方法中定义的变量，如果没有初始化，会有默认值<br>C.类变量指的是用static修饰的属性<br>D.final变量指的是用final 修饰的变量</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>B.定义在类中的变量是类的成员变量，可以不进行初始化，Java会自动进行初始化，如果是引用类型默认初始化为null,如果是基本类型例如int则会默认初始化为0<br>局部变量是定义在方法中的变量，必须要进行初始化。<br>被static关键字修饰的变量是静态的，静态变量随着类的加载而加载，所以也被称为类变量<br>被final修饰的变量是常量</p><h2 id="11-关于JAVA的垃圾回收机制，下面哪些结论是正确？"><a href="#11-关于JAVA的垃圾回收机制，下面哪些结论是正确？" class="headerlink" title="11.关于JAVA的垃圾回收机制，下面哪些结论是正确？"></a>11.关于JAVA的垃圾回收机制，下面哪些结论是正确？</h2><p>A.程序可以任意指定释放内存的时间<br>B.JAVA程序不能依赖于垃圾回收的时间或者顺序<br>C.程序可明确地标识某个局部变量的引用不再被使用<br>D.程序可以显式地立即释放对象占有的内存</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。当对象的引用变量被赋值为null，可能被当成垃圾。</p><h2 id="12-JSP分页代码中，哪个步骤次序是正确的？"><a href="#12-JSP分页代码中，哪个步骤次序是正确的？" class="headerlink" title="12.JSP分页代码中，哪个步骤次序是正确的？"></a>12.JSP分页代码中，哪个步骤次序是正确的？</h2><p>A.先取总记录数，得到总页数，最后显示本页的数据。<br>B.先取所有的记录，得到总页数，再取总记录数，最后显示本页的数据。<br>C.先取总页数，得到总记录数，再取所有的记录，最后显示本页的数据。<br>D.先取本页的数据，得到总页数，再取总记录数，最后显示所有的记录。</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>1、count(*)得到总记录数<br>2、计算总页数<br>3、获取所有记录(个人感觉这一步不需要，可以直接获取指定页数数据)<br>4、过滤显示本页数据</p><h2 id="13-关于访问权限说法正确的是-？"><a href="#13-关于访问权限说法正确的是-？" class="headerlink" title="13.关于访问权限说法正确的是 ？ ( )"></a>13.关于访问权限说法正确的是 ？ ( )</h2><p>A.外部类前面可以修饰public,protected和private<br>B.成员内部类前面可以修饰public,protected和private<br>C.局部内部类前面可以修饰public,protected和private<br>D.以上说法都不正确</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>(1)对于外部类而言，它也可以使用访问控制符修饰，但外部类只能有两种访问控制级别：public和默认。因为外部类没有处于任何类的内部，也就没有其所在类的内部、所在类的子类两个范围，因此 private 和 protected 访问控制符对外部类没有意义。<br>(2)内部类的上一级程序单元是外部类，它具有 4 个作用域：同一个类（ private ）、同一个包（ protected ）和任何位置（ public ）。<br>(3)因为局部成员的作用域是所在方法，其他程序单元永远不可能访问另一个方法中的局部变量，所以所有的局部成员都不能使用访问控制修饰符修饰。</p><h2 id="14-以下代码执行的结果显示是多少（-）？"><a href="#14-以下代码执行的结果显示是多少（-）？" class="headerlink" title="14.以下代码执行的结果显示是多少（ ）？"></a>14.以下代码执行的结果显示是多少（ ）？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123; </span><br><span class="line">class Super&#123;  </span><br><span class="line"> int flag&#x3D;1;</span><br><span class="line">         Super()&#123;</span><br><span class="line">             test();</span><br><span class="line">         &#125;  </span><br><span class="line"> void test()&#123;</span><br><span class="line">            System.out.println(&quot;Super.test() flag&#x3D;&quot;+flag);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125; </span><br><span class="line">class Sub extends Super&#123;</span><br><span class="line">        Sub(int i)&#123;  </span><br><span class="line">flag&#x3D;i;</span><br><span class="line">            System.out.println(&quot;Sub.Sub()flag&#x3D;&quot;+flag);</span><br><span class="line">        &#125;  </span><br><span class="line">void test()&#123;</span><br><span class="line">            System.out.println(&quot;Sub.test()flag&#x3D;&quot;+flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">new Demo().new Sub(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.Sub.test() flag=1,Sub.Sub() flag=5<br>B.Sub.Sub() flag=5,Sub.test() flag=5<br>C.Sub.test() flag=0,Sub.Sub() flag=5<br>D.Super.test() flag=1,Sub.Sub() flag=5</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong></p><p>在继承中代码的执行顺序为：<br>1.父类静态对象，父类静态代码块<br>2.子类静态对象，子类静态代码块<br>3.父类非静态对象，父类非静态代码块<br>4.父类构造函数<br>5.子类非静态对象，子类非静态代码块<br>6.子类构造函数<br>对于本题来说：在只想new Sub(5)的时候，父类先初始化了int flag=1，然后执行父类的构造函数Super（），父类构造函数中执行的test（）方法，因子类是重写了test（）方法的，因此父类构造函数中的test（）方法实际执行的是子类的test（）方法，所以输出为Sub.test() flag=1，接着执行子类构造函数Sub(5) 将flag赋值为5，因此输出结果Sub.Sub() flag=5。最终选择了A。</p><h2 id="15-Java多线程有几种实现方法？"><a href="#15-Java多线程有几种实现方法？" class="headerlink" title="15.Java多线程有几种实现方法？"></a>15.Java多线程有几种实现方法？</h2><p>A.继承Thread类<br>B.实现Runnable接口<br>C.实现Thread接口<br>D.以上都不正确</p><p><strong>答案：</strong><br>AB</p><p><strong>解析：</strong><br>AB.<br>多线程一共有三种实现方式<br>方式1：继承Thread类，并重写run()方法<br>方式2：实现Runnable接口，实现run()方法<br>方式3：实现Callable接口，线程结束后可以有返回值，但是该方式是依赖于线程池的。</p><h2 id="16-在Jdk1-7中，下述说法中抽象类与接口的区别与联系正确的有哪些？"><a href="#16-在Jdk1-7中，下述说法中抽象类与接口的区别与联系正确的有哪些？" class="headerlink" title="16.在Jdk1.7中，下述说法中抽象类与接口的区别与联系正确的有哪些？"></a>16.在Jdk1.7中，下述说法中抽象类与接口的区别与联系正确的有哪些？</h2><p>A.抽象类中可以有普通成员变量，接口中没有普通成员变量。<br>B.抽象类和接口中都可以包含静态成员常量。<br>C.一个类可以实现多个接口，但只能继承一个抽象类<br>D.抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法。</p><p><strong>答案：</strong><br>A B C D </p><p><strong>解析：</strong><br>总结一下</p><ol><li>一个子类只能继承一个抽象类,但能实现多个接口</li><li>抽象类可以有构造方法,接口没有构造方法</li><li>抽象类可以有普通成员变量,接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意,接口只能public static final(默认)</li><li>抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法</li><li>抽象类可以有静态方法,接口不能有静态方法</li><li>抽象类中的方法可以是public、protected;接口方法只有public </li></ol><h2 id="17-根据下面这个程序的内容，判断哪些描述是正确的：（-）"><a href="#17-根据下面这个程序的内容，判断哪些描述是正确的：（-）" class="headerlink" title="17.根据下面这个程序的内容，判断哪些描述是正确的：（ ）"></a>17.根据下面这个程序的内容，判断哪些描述是正确的：（ ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">String s &#x3D; &quot;tommy&quot;;</span><br><span class="line">Object o &#x3D; s;</span><br><span class="line">sayHello(o); &#x2F;&#x2F;语句1</span><br><span class="line">sayHello(s); &#x2F;&#x2F;语句2</span><br><span class="line">&#125;</span><br><span class="line">public static void sayHello(String to) &#123;</span><br><span class="line">System.out.println(String.format(&quot;Hello, %s&quot;, to));</span><br><span class="line">&#125;</span><br><span class="line">public static void sayHello(Object to) &#123;</span><br><span class="line">System.out.println(String.format(&quot;Welcome, %s&quot;, to));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.这段程序有编译错误<br>B.语句1输出为:Hello, tommy<br>C.语句2输出为:Hello, tommy<br>D.语句1输出为:Welcome, tommy<br>E.语句2输出为:Welcome, tommy<br>F.根据选用的Java编译器不同，这段程序的输出可能不同</p><p><strong>答案：</strong><br>CD</p><p><strong>解析：</strong><br>略</p><h2 id="18-Java特性中-abstract-class和interface有什么区别（）"><a href="#18-Java特性中-abstract-class和interface有什么区别（）" class="headerlink" title="18.Java特性中,abstract class和interface有什么区别（）"></a>18.Java特性中,abstract class和interface有什么区别（）</h2><p>A.抽象类可以有构造方法，接口中不能有构造方法<br>B.抽象类中可以有普通成员变量，接口中没有普通成员变量<br>C.抽象类中不可以包含静态方法，接口中可以包含静态方法<br>D.一个类可以实现多个接口，但只能继承一个抽象类。</p><p><strong>答案：</strong><br>A B D</p><p><strong>解析：</strong><br>接口中的成员变量被隐式的声明为public static final ，jdk1.8后接口中可以有静态方法而且存在方法体</p><h2 id="19-关于下面代码片段叙述正确的是（）"><a href="#19-关于下面代码片段叙述正确的是（）" class="headerlink" title="19.关于下面代码片段叙述正确的是（）"></a>19.关于下面代码片段叙述正确的是（）</h2><p>代码片段：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte b1&#x3D;1,b2&#x3D;2,b3,b6; </span><br><span class="line">final byte b4&#x3D;4,b5&#x3D;6; </span><br><span class="line">b6&#x3D;b4+b5; </span><br><span class="line">b3&#x3D;(b1+b2); </span><br><span class="line">System.out.println(b3+b6);</span><br></pre></td></tr></table></figure><p>A.输出结果：13<br>B.语句：b6=b4+b5编译出错<br>C.语句：b3=b1+b2编译出错<br>D.运行期抛出异常</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>C.被final修饰的变量是常量，这里的b6=b4+b5可以看成是b6=10；在编译时就已经变为b6=10了。而b1和b2是byte类型，java中进行计算时候将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。Java中的byte，short，char进行计算时都会提升为int类型。 </p><h2 id="20-下列那些方法是线程安全的-所调用的方法都存在"><a href="#20-下列那些方法是线程安全的-所调用的方法都存在" class="headerlink" title="20.下列那些方法是线程安全的(所调用的方法都存在)"></a>20.下列那些方法是线程安全的(所调用的方法都存在)</h2><p>A.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyServlet implements Servlet &#123;</span><br><span class="line">public void service (ServletRequest req, ServletResponse resp) &#123;</span><br><span class="line">BigInteger I &#x3D; extractFromRequest(req);</span><br><span class="line">encodeIntoResponse(resp,factors);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyServlet implements Servlet &#123;</span><br><span class="line">private long count &#x3D;0;</span><br><span class="line">public long getCount() &#123;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line">public void service (ServletRequest req, ServletResponse resp) &#123;</span><br><span class="line">BigInteger I &#x3D; extractFromRequest(req);</span><br><span class="line">BigInteger[] factors &#x3D; factor(i);</span><br><span class="line">count ++;</span><br><span class="line">encodeIntoResponse(resp,factors);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">private int value;</span><br><span class="line">public synchronized int get() &#123;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">public synchronized void set (int value) &#123;</span><br><span class="line">this.value &#x3D; value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Factorizer implements Servlet &#123;</span><br><span class="line">private volatile MyCache cache &#x3D; new MyCache(null,null);</span><br><span class="line"></span><br><span class="line">public void service(ServletRequest req, ServletResponse resp) &#123;</span><br><span class="line">BigInteger i &#x3D; extractFromRequest(req);</span><br><span class="line">BigInteger[] factors &#x3D; cache.getFactors(i);</span><br><span class="line">if (factors &#x3D;&#x3D; null) &#123;</span><br><span class="line">factors &#x3D; factor(i);</span><br><span class="line">cache &#x3D; new MyCache(i,factors);</span><br><span class="line">&#125;</span><br><span class="line">encodeIntoResponse(resp,factors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案：</strong><br>A C D</p><p><strong>解析：</strong><br>A：没有成员（没有共享资源），线程安全；<br>B：假设存在线程1和线程2，count初始值为0，当线程1执行count++中count+1（此时未写回最终计算值），这时线程2执行count++中读取count，发生数据错误，导致线程1线程2的结果都为1，而不是线程1的结果为1，线程2的结果为2，线程不安全；<br>C：成员私有，对成员的set get方法都加重量级锁，线程安全； D：volatile有两个作用：可见性（volatile变量的改变能使其他线程立即可见，但它不是线程安全的，参考B）和禁止重排序；这里是可见性的应用，类中方法对volatile修饰的变量只有赋值，线程安全； 欢迎指正。 </p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">笔试内容集合</a> 持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-68883ebbbccb6b4f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（三）</title>
      <link href="/2019/09/17/interview/java/B-bishi03/"/>
      <url>/2019/09/17/interview/java/B-bishi03/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-f8e19f0c0785f2e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（三）"></p><h2 id="1-下列InputStream类中哪个方法可以用于关闭流？"><a href="#1-下列InputStream类中哪个方法可以用于关闭流？" class="headerlink" title="1.下列InputStream类中哪个方法可以用于关闭流？"></a>1.下列InputStream类中哪个方法可以用于关闭流？</h2><p>A.skip（）<br>B.close（）<br>C.mark（）<br>D.reset（）</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>inputstream的close方法用来关闭流<br>skip()用来跳过一些字节<br>mark（）用来标记流<br>reset（）复位流 </p><h2 id="2-下面语句正确的是（）"><a href="#2-下面语句正确的是（）" class="headerlink" title="2.下面语句正确的是（）"></a>2.下面语句正确的是（）</h2><p>A.x+1=5<br>B.i++=1<br>C.a++b=1<br>D.x+=1</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>选D，+=，-=，*=，/=最常见。<br>ABC都编译错误。</p><h2 id="3-下面关于继承的描述正确的是？"><a href="#3-下面关于继承的描述正确的是？" class="headerlink" title="3.下面关于继承的描述正确的是？"></a>3.下面关于继承的描述正确的是？</h2><p>A.在Java中只允许单一继承<br>B.在Java中一个类只能实现一个接口<br>C.在Java中一个类不能同时继承一个类和实现一个接口<br>D.Java的单一继承使代码不可靠</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>略</p><h2 id="4-下列哪种说法是正确的？"><a href="#4-下列哪种说法是正确的？" class="headerlink" title="4.下列哪种说法是正确的？"></a>4.下列哪种说法是正确的？</h2><p>A.实例方法可直接调用超类的实例方法<br>B.实例方法可直接调用超类的类方法<br>C.实例方法可直接调用本类的类方法<br>D.实例方法可直接调用其他类的实例方法</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>a.实例方法可以调用超类公有实例方法<br>b.实例方法可以直接调用超类的公有类方法<br>d.实例方法可以通过类名调用其他类的类方法 </p><h2 id="5-A派生出子类B，B派生出子类C，并且在java源代码中有如下声明："><a href="#5-A派生出子类B，B派生出子类C，并且在java源代码中有如下声明：" class="headerlink" title="5.A派生出子类B，B派生出子类C，并且在java源代码中有如下声明："></a>5.A派生出子类B，B派生出子类C，并且在java源代码中有如下声明：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.A a0&#x3D;new A();</span><br><span class="line">2.A a1&#x3D;new B();</span><br><span class="line">3.A a2&#x3D;new C();</span><br></pre></td></tr></table></figure><p>以下哪个说法是正确的？ </p><p>A.第1行,第2行和第3行的声明都是正确的<br>B.第1,2,3行都能通过编译，但第2,3行运行时出错<br>C.第1,2行能通过编译，但第3行编译出错<br>D.只有第1行能通过编译</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>一句话 向上转型是无条件的 </p><h2 id="6-java中，静态变量static在不同线程的不同实例中地址是否一样？他们储存在什么区域？（）"><a href="#6-java中，静态变量static在不同线程的不同实例中地址是否一样？他们储存在什么区域？（）" class="headerlink" title="6.java中，静态变量static在不同线程的不同实例中地址是否一样？他们储存在什么区域？（）"></a>6.java中，静态变量static在不同线程的不同实例中地址是否一样？他们储存在什么区域？（）</h2><p>A.地址一样，在堆栈区。<br>B.地址不一样，在堆栈区。<br>C.地址一样，在全局区。<br>D.地址不一样，在全局区。</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>static变量存储在方法区，线程共享，全局区是方法区的一部分，其实用排除法也可以知道 static变量不可能位于堆栈区 </p><h2 id="7-下面代码的输出结果是什么？"><a href="#7-下面代码的输出结果是什么？" class="headerlink" title="7.下面代码的输出结果是什么？"></a>7.下面代码的输出结果是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ZeroTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     try&#123;</span><br><span class="line">       int i &#x3D; 100 &#x2F; 0;</span><br><span class="line">       System.out.print(i);</span><br><span class="line">  &#125;catch(Exception e)&#123;</span><br><span class="line">       System.out.print(1);</span><br><span class="line">       throw new RuntimeException();</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line">       System.out.print(2);</span><br><span class="line">  &#125;</span><br><span class="line">      System.out.print(3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.3<br>B.123<br>C.1<br>D.12</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>1、inti = 100/ 0; 会出现异常，会抛出异常，System.out.print(i)不会执行，<br>2、catch捕捉异常，继续执行System.out.print(1);<br>3、当执行 thrownewRuntimeException(); 又会抛出异常，这时，除了会执行finally中的代码，其他地方的代码都不会执行 </p><h2 id="8-以下代码将打印出"><a href="#8-以下代码将打印出" class="headerlink" title="8.以下代码将打印出?"></a>8.以下代码将打印出?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">      List  Listlist1 &#x3D; new ArrayList();</span><br><span class="line">      Listlist1.add(0);</span><br><span class="line">      List Listlist2 &#x3D; Listlist1;</span><br><span class="line">  System.out.println(Listlist1.get(0) instanceof Integer);</span><br><span class="line">  System.out.println(Listlist2.get(0) instanceof Integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.编译错误<br>B.true true<br>C.true false<br>D.false false</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据，该题中装入了0，是一个基本类型，但是JDK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。编译能够正常通过。<br>将list1的引用赋值给了list2，那么list1和list2都将指向同一个堆内存空间。instanceof是Java中关键字，用于判断一个对象是否属于某个特定类的实例，并且返回boolean类型的返回值。显然，list1.get(0)和list2.get(0)都属于Integer的实例 </p><h2 id="9-在运行时，由java解释器自动引入，而不用import语句引入的包是-。"><a href="#9-在运行时，由java解释器自动引入，而不用import语句引入的包是-。" class="headerlink" title="9. 在运行时，由java解释器自动引入，而不用import语句引入的包是()。"></a>9. 在运行时，由java解释器自动引入，而不用import语句引入的包是()。</h2><p>A.java.lang<br>B.java.system<br>C.java.io<br>D.java.util</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>ava.lang包是java语言包，是自动导入的。<br>java.util包是java的工具包，需要手动导入。<br>java.sql包，JDBC接口类，需要手动导入。<br>java.io;各种输入输入流，需要手动导入。 </p><h2 id="10-下面这三条语句"><a href="#10-下面这三条语句" class="headerlink" title="10.下面这三条语句"></a>10.下面这三条语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(“is ”+ 100 + 5)；</span><br><span class="line">System.out.println(100 + 5 +“ is”)；</span><br><span class="line">System.out.println(“is ”+ (100 + 5))；</span><br></pre></td></tr></table></figure><p>的输出结果分别是？ ( ) </p><p>A.is 1005, 1005 is, is 1005<br>B.is 105, 105 is, is 105<br>C.is 1005, 1005 is, is 105<br>D.is 1005, 105 is, is 105</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>1.”is”说明后面的内容都会被强制转换为string，所以是最后结果是拼接起来的<br>2.100+5先得到105，然后与is拼接<br>3.先算括号内的</p><h2 id="11-Given"><a href="#11-Given" class="headerlink" title="11.Given:"></a>11.Given:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class IfTest&#123;</span><br><span class="line">    public static void main(string[]args)&#123;</span><br><span class="line">        int x&#x3D;3;</span><br><span class="line">        int y&#x3D;1;</span><br><span class="line">        if(x&#x3D;y)</span><br><span class="line">            System.out.println(“Not equal”);</span><br><span class="line">        else</span><br><span class="line">            System.out.println(“Equal”);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>What is the result?</p><p>A.The output is “Equal”<br>B.The output in “Not Equal”<br>C.An error at line 5 causes compilation to fall.<br>D.The program executes but does not print a message.</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>这个题考查两个知识点。<br>1、Java中，赋值是有返回值的 ，赋什么值，就返回什么值。比如这题，x=y，返回y的值，所以括号里的值是1。<br>2、Java跟C的区别，C中赋值后会与0进行比较，如果大于0，就认为是true；而Java不会与0比较，而是直接把赋值后的结果放入括号。 </p><h2 id="12-在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？"><a href="#12-在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？" class="headerlink" title="12.在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？"></a>12.在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？</h2><p>A.管道<br>B.消息队列<br>C.高速缓存数据库<br>D.套接字</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 </p><h2 id="13-下列程序的运行结果"><a href="#13-下列程序的运行结果" class="headerlink" title="13.下列程序的运行结果"></a>13.下列程序的运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void getCustomerInfo() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; do something that may cause an Exception</span><br><span class="line">&#125; catch (java.io.FileNotFoundException ex) &#123;</span><br><span class="line">System.out.print(&quot;FileNotFoundException!&quot;);</span><br><span class="line">&#125; catch (java.io.IOException ex) &#123;</span><br><span class="line">System.out.print(&quot;IOException!&quot;);</span><br><span class="line">&#125; catch (java.lang.Exception ex) &#123;</span><br><span class="line">System.out.print(&quot;Exception!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.IOException!<br>B.IOException!Exception!<br>C.FileNotFoundException!IOException!<br>D.FileNotFoundException!IOException!Exception!</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>题目说抛出一个异常，但是没说具体是什么异常，那么就要分情况了：<br>1.如果抛出一个FileNotFoundException(或其子类)，那么最终结果就打印FileNotFoundException<br>2.如果抛出一个IOException,或者IOException的子类(不包含FileNotFoundException及其子类)，那么最终结果就打印IOException<br>3.如果抛出一个Exception(不包含IOException及其子类),那么最终结果就打印Exception.<br>以上，所以3个皆有可能.但是，不管是哪一种情况，只会输出其中之一。<br>从答案上来看，B,C，D的输出情况是不存在的。因此选A </p><h2 id="14-如下代码的输出结果是什么？"><a href="#14-如下代码的输出结果是什么？" class="headerlink" title="14.如下代码的输出结果是什么？"></a>14.如下代码的输出结果是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public int aMethod()&#123;</span><br><span class="line">        static int i &#x3D; 0;</span><br><span class="line">        i++;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">    Test test &#x3D; new Test();</span><br><span class="line">    test.aMethod();</span><br><span class="line">    int j &#x3D; test.aMethod();</span><br><span class="line">    System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.0<br>B.1<br>C.2<br>D.编译失败</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>静态变量只能在类主体中定义，不能在方法中定义</p><h2 id="15-下面有关servlet和cgi的描述，说法错误的是？"><a href="#15-下面有关servlet和cgi的描述，说法错误的是？" class="headerlink" title="15.下面有关servlet和cgi的描述，说法错误的是？"></a>15.下面有关servlet和cgi的描述，说法错误的是？</h2><p>A.servlet处于服务器进程中，它通过多线程方式运行其service方法<br>B.CGI对每个请求都产生新的进程，服务完成后就销毁<br>C.servlet在易用性上强于cgi，它提供了大量的实用工具例程，例如自动地解析和解码HTML表单数据、读取和设置HTTP头、处理Cookie、跟踪会话状态等<br>D.cgi在移植性上高于servlet，几乎所有的主流服务器都直接或通过插件支持cgi</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>选择D，servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</p><h2 id="16-下列关于构造方法的叙述中，错误的是（）"><a href="#16-下列关于构造方法的叙述中，错误的是（）" class="headerlink" title="16.下列关于构造方法的叙述中，错误的是（）"></a>16.下列关于构造方法的叙述中，错误的是（）</h2><p>A.java语言规定构造方法名与类名必须相同<br>B.java语言规定构造方法没有返回值，但不同void声明<br>C.java语言规定构造方法不可以重载<br>D.java语言规定构造方法只能通过new自动调用</p><p><strong>答案：</strong><br>CD</p><p><strong>解析：</strong><br>关于答案d,通过this也可以调用 </p><h2 id="17-What-is-Static-Method-in-Java（）"><a href="#17-What-is-Static-Method-in-Java（）" class="headerlink" title="17.What is Static Method in Java（）"></a>17.What is Static Method in Java（）</h2><p>A.It is a method which belongs to the class and not to the object(instance)<br>B.A static method can access only static data. It can not access non-static data (instance variables)<br>C.A static method can call only other static methods and can not call a non-static method from it.<br>D.A static method can not be accessed directly by the class name and doesn’t need any object</p><p><strong>答案：</strong><br>ABC</p><p><strong>解析：</strong></p><p>A：静态方法是一个属于类而不属于对象(实例)的方法。（√）<br>B：静态方法只能访问静态数据。无法访问非静态数据(实例变量)。（√）<br>C：静态方法只能调用其他静态方法，不能从中调用非静态方法。（√）<br>D：静态方法不能通过类名直接访问，也不需要任何对象。（×） 静态方法可以直接用类名访问。</p><h2 id="18-下列哪种情况会调用拷贝构造函数（）"><a href="#18-下列哪种情况会调用拷贝构造函数（）" class="headerlink" title="18.下列哪种情况会调用拷贝构造函数（）"></a>18.下列哪种情况会调用拷贝构造函数（）</h2><p>A.用派生类的对象去初始化基类对象时<br>B.将类的一个对象赋值给该类的另一个对象时<br>C.函数的形参是类的对象，调用函数进行形参和实参结合时<br>D.函数的返回值是类的对象，函数执行返回调用时</p><p><strong>答案：</strong><br>A C D</p><p><strong>解析：</strong></p><p>复制构造函数被调用的三种情况</p><p>1.定义一个对象时，以本类另一个对象作为初始值，发生复制构造；</p><p>2.如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造；</p><p>3.如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。</p><h2 id="19-Java对象的初始化方式有（-）"><a href="#19-Java对象的初始化方式有（-）" class="headerlink" title="19.Java对象的初始化方式有（ ）"></a>19.Java对象的初始化方式有（ ）</h2><p>A.初始化块<br>B.构造器<br>C.定义变量时指定初始化值<br>D.其它各项都不对</p><p><strong>答案：</strong><br>A B C</p><p><strong>解析：</strong></p><p>对象的初始化方式：<br>1.new时初始化 ；<br>2.静态工厂 newInstance；<br>3.反射Class.forName()；<br>4.clone方式；<br>5.反序列化；</p><h2 id="20-截止JDK1-8版本-java并发框架支持锁包括"><a href="#20-截止JDK1-8版本-java并发框架支持锁包括" class="headerlink" title="20.截止JDK1.8版本,java并发框架支持锁包括?"></a>20.截止JDK1.8版本,java并发框架支持锁包括?</h2><p>A.读写锁<br>B.自旋锁<br>C.X锁<br>D.乐观锁<br>E.排他锁</p><p><strong>答案：</strong><br>A B D</p><p><strong>解析：</strong></p><p>1、自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁<br>2、阻塞锁 被阻塞的线程，不会争夺锁。<br>3、可重入锁 多次进入改锁的域<br>4、读写锁<br>5、互斥锁 锁本身就是互斥的<br>6、悲观锁 不相信，这里会是安全的，必须全部上锁<br>7、乐观锁 相信，这里是安全的。<br>8、公平锁 有优先级的锁<br>9、非公平锁 无优先级的锁<br>10、偏向锁 无竞争不锁，有竞争挂起，转为轻量锁<br>11、对象锁 锁住对象<br>12、线程锁<br>13、锁粗化 多锁变成一个，自己处理<br>14、轻量级锁 CAS 实现<br>15、锁消除 偏向锁就是锁消除的一种<br>16、锁膨胀 jvm实现，锁粗化<br>17、信号量 使用阻塞锁 实现的一种策略<br>18、排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p><blockquote><p>注：以上笔试题均来自网络，由笔者整理得出</p></blockquote><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">笔试内容集合</a> 欢迎关注，持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-3d2d38cc1d994291?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（二）</title>
      <link href="/2019/09/16/interview/java/B-bishi02/"/>
      <url>/2019/09/16/interview/java/B-bishi02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-c168c90d99f96d7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（二）"></p><h2 id="1-HashMap的数据结构是怎样的？"><a href="#1-HashMap的数据结构是怎样的？" class="headerlink" title="1. HashMap的数据结构是怎样的？"></a>1. HashMap的数据结构是怎样的？</h2><p>A.数组<br>B.链表<br>C.数组+链表<br>D.二叉树</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong></p><p>JDK8以后，HashMap的数据结构是数组+链表+红黑树 </p><h2 id="2-在-JAVA-编程中，Java-编译器会将-Java-程序转换为（-）？"><a href="#2-在-JAVA-编程中，Java-编译器会将-Java-程序转换为（-）？" class="headerlink" title="2. 在 JAVA 编程中，Java 编译器会将 Java 程序转换为（ ）？"></a>2. 在 JAVA 编程中，Java 编译器会将 Java 程序转换为（ ）？</h2><p>A.字节码<br>B.可执行代码<br>C.机器代码<br>D.以上都不对</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong></p><ul><li>编译器将Java源代码编译成字节码class文件</li><li>类加载到JVM里面后，执行引擎把字节码转为可执行代码</li><li>执行的过程，再把可执行代码转为机器码，由底层的操作系统完成执行。 </li></ul><h2 id="3-下面有关JVM内存，说法错误的是？"><a href="#3-下面有关JVM内存，说法错误的是？" class="headerlink" title="3.下面有关JVM内存，说法错误的是？"></a>3.下面有关JVM内存，说法错误的是？</h2><p>A.程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的<br>B.Java方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的<br>C.方法区用于存储JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程隔离的<br>D.原则上讲，所有的对象都在堆区上分配内存，是线程之间共享的</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器</p><ul><li>虚拟机栈区：也就是我们常说的栈区，线程私有，存放基本类型，对象的引用和 returnAddress ，在编译期间完成分配。</li><li>堆区：JAVA 堆，也称 GC 堆，所有线程共享，存放对象的实例和数组， JAVA 堆是垃圾收集器管理的主要区域。</li><li>方法区：所有线程共享，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。</li><li>程序计数器：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址。</li></ul><ol start="4"><li>JAVA中，下列语句哪一个正确（） </li></ol><p>A.class中的constructor不可省略<br>B.constructor必须与class同名，但方法不能与class同名<br>C.constructor在一个对象被new时执行<br>D.一个class只能定义一个constructor</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>A 省略构造函数,编译器会自动生成。<br>D 构造函数可以重载<br>B 方法是可以和类名同名的，和构造方法唯一的区别就是，构造方法没有返回值。</p><h2 id="5-在JAVA中，假设A有构造方法A-int-a-，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）"><a href="#5-在JAVA中，假设A有构造方法A-int-a-，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）" class="headerlink" title="5.在JAVA中，假设A有构造方法A(int a)，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）"></a>5.在JAVA中，假设A有构造方法A(int a)，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）</h2><p>A.this.A(x)<br>B.this(x)<br>C.super(x)<br>D.A(x)</p><p><strong>答案：</strong><br>B </p><p><strong>解析：</strong><br>this的作用其中一个就是在一个构造方法中调用另一个构造方法，格式为this(参数)；<br>super是调用父类的方法；<br>A(a)这种形式是在new一个类时使用。 </p><h2 id="6-下列选项中属于面向对象程序设计语言特征的是（）"><a href="#6-下列选项中属于面向对象程序设计语言特征的是（）" class="headerlink" title="6.下列选项中属于面向对象程序设计语言特征的是（）"></a>6.下列选项中属于面向对象程序设计语言特征的是（）</h2><p>A.继承性<br>B.多态性<br>C.相似性<br>D.封装性</p><p><strong>答案：</strong><br> A B D</p><p><strong>解析：</strong><br>面对对象三大特征：封装，继承，多态 </p><h2 id="7-以下哪个正确？"><a href="#7-以下哪个正确？" class="headerlink" title="7.以下哪个正确？"></a>7.以下哪个正确？</h2><p>A.abstract类只能用来派生子类，不能用来创建abstract类的对象。<br>B.final类不但可以用来派生子类，也可以用来创建final类的对象。<br>C.abstract不能与final同时修饰一个类。<br>D.abstract类定义中可以没有abstract方法。</p><p><strong>答案：</strong><br>A C D</p><p><strong>解析：</strong><br>1、abstract类不能用来创建abstract类的对象；<br>2、final类不能用来派生子类，因为用final修饰的类不能被继承；<br>3、如2所述，final不能与abstract同时修饰一个类，abstract类就是被用来继承的；<br>4、类中有abstract方法必须用abstract修饰，但abstract类中可以没有抽象方法，接口中也可以有abstract方法。</p><h2 id="8-JAVA反射机制主要提供了以下哪些功能？"><a href="#8-JAVA反射机制主要提供了以下哪些功能？" class="headerlink" title="8. JAVA反射机制主要提供了以下哪些功能？"></a>8. JAVA反射机制主要提供了以下哪些功能？</h2><p>A.在运行时判断一个对象所属的类<br>B.在运行时构造一个类的对象<br>C.在运行时判断一个类所具有的成员变量和方法<br>D.在运行时调用一个对象的方法</p><p><strong>答案：</strong><br>A B C D</p><p><strong>解析：</strong><br>Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。<br>因此，答案为：ABCD </p><h2 id="9-以下关于Histroy对象的属性或方法描述正确的是（）"><a href="#9-以下关于Histroy对象的属性或方法描述正确的是（）" class="headerlink" title="9.以下关于Histroy对象的属性或方法描述正确的是（）"></a>9.以下关于Histroy对象的属性或方法描述正确的是（）</h2><p>A.bcak回到浏览器载入历史URL地址列表的当前URL的前一个URL<br>B.go表示刷新当前页面<br>C.length保存历史URL地址列表的长度信息<br>D.forward转到浏览器载入历史URL地址列表的当前URL的下一个URL。</p><p><strong>答案：</strong><br>A D</p><p><strong>解析：</strong></p><p>选A、D。考察的是浏览器的内置对象管理模型，简称BOM(Browser Object Model)中的Histroy属性和方法。</p><ul><li>length 返回浏览器历史列表中的URL数量。所以C中表述的长度信息是错误的。</li><li>back() 加载 history列表中的前一个URL。</li><li>forward() 加载  history  列表中的下一个URL。</li><li>go()  加载history列表中的某个具体页面。所以B的表述刷新当前页面是错误的。</li></ul><h2 id="10"><a href="#10" class="headerlink" title="10."></a>10.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class NameList</span><br><span class="line">&#123;</span><br><span class="line">    private List names &#x3D; new ArrayList();</span><br><span class="line">    public synchronized void add(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        names.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void printAll()     &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; names.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(names.get(i) + ””);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">        final NameList sl &#x3D; new NameList();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            new Thread()</span><br><span class="line">            &#123;</span><br><span class="line">                public void run()</span><br><span class="line">                &#123;</span><br><span class="line">                    sl.add(“A”);</span><br><span class="line">                    sl.add(“B”);</span><br><span class="line">                    sl.add(“C”);</span><br><span class="line">                    sl.printAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; .start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Which two statements are true if this class is compiled and run? </p><p>A.An exception may be thrown at runtime.<br>B.The code may run with no output, without exiting.<br>C.The code may run with no output, exiting normally(正常地).<br>D.The code may rum with output “A B A B C C “, then exit.<br>E.The code may rum with output “A B C A B C A B C “, then exit.<br>F.The code may ruin with output “A A A B C A B C C “, then exit.<br>G.The code may ruin with output “A B C A A B C A B C “, then exit.</p><p><strong>答案：</strong><br>E G</p><p><strong>解析：</strong></p><p>在每个线程中都是顺序执行的，所以sl.printAll();必须在前三句执行之后执行，也就是输出的内容必有（连续或非连续的）ABC。而线程之间是穿插执行的，所以一个线程执行 sl.printAll();之前可能有另一个线程执行了前三句的前几句。<br>E答案相当于线程1顺序执行完然后线程2顺序执行完。<br>G答案则是线程1执行完前三句add之后线程2插一脚执行了一句add然后线程1再执行 sl.printAll();输出ABCA。接着线程2顺序执行完输出ABCABC<br>输出加起来即为ABCAABCABC。</p><h2 id="11-关于容器下面说法正确的是？"><a href="#11-关于容器下面说法正确的是？" class="headerlink" title="11. 关于容器下面说法正确的是？ ( )"></a>11. 关于容器下面说法正确的是？ ( )</h2><p>A.列表(List)和集合(Set)存放的元素都是可重复的。<br>B.列表(List)和集合(Set)存放的元素都是不可重复的。<br>C.映射(Map)&lt;key,value&gt;中key是可以重复的。<br>D.映射(Map)&lt;key,value&gt;中value是可以重复的。</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>列表（List）的元素是有序、可重复的；<br>集合（Set）的元素是无序、不可重复的。 </p><h2 id="12-以下说法错误的是-（）"><a href="#12-以下说法错误的是-（）" class="headerlink" title="12.以下说法错误的是?（）"></a>12.以下说法错误的是?（）</h2><p>A.数组是一个对象<br>B.数组不是一种原生类<br>C.数组的大小可以任意改变<br>D.在Java中，数组存储在堆中连续内存空间里</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>在java中,数组是一个对象,不是一种原生类,对象所以存放在堆中,又因为数组特性,是连续的,只有C不对</p><h2 id="13-下列哪个修饰符可以使在一个类中定义的成员变量只能被同一包中的类访问？"><a href="#13-下列哪个修饰符可以使在一个类中定义的成员变量只能被同一包中的类访问？" class="headerlink" title="13.下列哪个修饰符可以使在一个类中定义的成员变量只能被同一包中的类访问？"></a>13.下列哪个修饰符可以使在一个类中定义的成员变量只能被同一包中的类访问？</h2><p>A.private<br>B.无修饰符<br>C.public<br>D.protected</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br><img src="https://upload-images.jianshu.io/upload_images/7326374-da4c30aa9fc41454.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解析"></p><h2 id="14-关于以下程序代码的说明正确的是"><a href="#14-关于以下程序代码的说明正确的是" class="headerlink" title="14.关于以下程序代码的说明正确的是?"></a>14.关于以下程序代码的说明正确的是?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class HasStatic &#123;</span><br><span class="line">private static int x &#x3D; 100;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">HasStatic hs1 &#x3D; new HasStatic();</span><br><span class="line">hs1.x++;</span><br><span class="line">HasStatic hs2 &#x3D; new HasStatic();</span><br><span class="line">hs2.x++;</span><br><span class="line">hs1 &#x3D; new HasStatic();</span><br><span class="line">;</span><br><span class="line">hs1.x++;</span><br><span class="line">HasStatic.x--;</span><br><span class="line">System.out.println(&quot;x&#x3D;&quot; + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.程序通过编译，输出结果为：x=103<br>B.10行不能通过编译，因为x是私有静态变量<br>C.5行不能通过编译，因为引用了私有静态变量<br>D.程序通过编译，输出结果为：x=102</p><p><strong>答案：</strong><br>D </p><p><strong>解析：</strong><br>此题选择D。<br>首先要了解static的意思。</p><p>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。<br>static变量在第一次使用的时候初始化，但只会有一份成员对象。<br>所以这里不仅可以调用，而且每一次调用都确实修改了x的值，也就是变化情况是这样的：<br>x=101<br>x=102<br>x=103<br>x=102</p><h2 id="15-如何放掉一个指定占据的内存空间？（）"><a href="#15-如何放掉一个指定占据的内存空间？（）" class="headerlink" title="15.如何放掉一个指定占据的内存空间？（）"></a>15.如何放掉一个指定占据的内存空间？（）</h2><p>A.调用free()方法<br>B.代用system.gc()方法<br>C.赋值给该项对象的引用为null<br>D.程序员无法明确强制垃圾回收器运行</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>在《java虚拟机》一书中明确讲了，释放掉占据的内存空间是由gc完成，但是程序员无法明确强制其运行，该空间在不被引用的时候不一定会立即被释放，这取决于GC本身，无法由程序员通过代码控制。 </p><h2 id="16-一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？"><a href="#16-一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？" class="headerlink" title="16.一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？"></a>16.一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？</h2><p>A.表对应类<br>B.记录对应对象<br>C.表的字段对应类的属性<br>D.表之间的参考关系对应类之间的依赖关系</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>一般关系数据模型和对象数据模型之间有以下对应关系：表对应类，记录对应对象，表的字段对应类的属性</p><h2 id="17-下列关于Java并发的说法中正确的是（）"><a href="#17-下列关于Java并发的说法中正确的是（）" class="headerlink" title="17.下列关于Java并发的说法中正确的是（）"></a>17.下列关于Java并发的说法中正确的是（）</h2><p>A.CopyOnWriteArrayList适用于写多读少的并发场景<br>B.ReadWriteLock适用于读多写少的并发场景<br>C.ConcurrentHashMap的写操作不需要加锁，读操作需要加锁<br>D.只要在定义int类型的成员变量i的时候加上volatile关键字，那么多线程并发执行i++这样的操作的时候就是线程安全的了</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>A，CopyOnWriteArrayList适用于写少读多的并发场景<br>B，ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥，读与读之间可以并发执行。在读多写少的情况下可以提高效率<br>C，ConcurrentHashMap是同步的HashMap，读写都加锁<br>D，volatile只保证多线程操作的可见性，不保证原子性 </p><h2 id="18-以下代码执行后输出结果为（-）"><a href="#18-以下代码执行后输出结果为（-）" class="headerlink" title="18.以下代码执行后输出结果为（ ）"></a>18.以下代码执行后输出结果为（ ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    public static Test t1 &#x3D; new Test();</span><br><span class="line">    &#123;</span><br><span class="line">         System.out.println(&quot;blockA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;blockB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Test t2 &#x3D; new Test();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>A.blockAblockBblockA<br>B.blockAblockAblockB<br>C.blockBblockBblockA<br>D.blockBblockAblockB</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>静态块：用static申明，JVM加载类时执行，仅执行一次<br>构造块：类中直接用{}定义，每一次创建对象时执行<br>执行顺序优先级：静态块&gt;main()&gt;构造块&gt;构造方法  静态块按照申明顺序执行，先执行Test t1 = new Test();<br>所有先输出blockA，然后执行静态块，输出blockB，最后执行main<br>方法中的Test t2 = new Test();输出blockA。 </p><h2 id="19-有关hashMap跟hashTable的区别，说法正确的是？"><a href="#19-有关hashMap跟hashTable的区别，说法正确的是？" class="headerlink" title="19.有关hashMap跟hashTable的区别，说法正确的是？"></a>19.有关hashMap跟hashTable的区别，说法正确的是？</h2><p>A.HashMap和Hashtable都实现了Map接口<br>B.HashMap是非synchronized，而Hashtable是synchronized<br>C.HashTable使用Enumeration，HashMap使用Iterator<br>D.HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</p><p><strong>答案：</strong><br>ABCD</p><p><strong>解析：</strong></p><p>A正确。Map是一个接口，hashtable,hashmap都是它的实现。<br>B正确。由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。<br>C正确。HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。<br>D正确。 哈希值的使用不同，HashTable直接使用对象的hashCode，代码是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int hash &#x3D; key.hashCode();</span><br><span class="line">int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br></pre></td></tr></table></figure><p>而HashMap重新计算hash值，而且用与代替求模：<br>int hash = hash(k);<br>int i = indexFor(hash, table.length); </p><h2 id="20-以下可以正确获取结果集的有"><a href="#20-以下可以正确获取结果集的有" class="headerlink" title="20.以下可以正确获取结果集的有?"></a>20.以下可以正确获取结果集的有?</h2><p>A.Statement sta=con.createStatement();<br>ResultSet rst=sta.executeQuery(“select * from book”);</p><p>B.Statement sta=con.createStatement(“select * from book”); ResultSet rst=sta.executeQuery();</p><p>C.PreparedStatement pst=con.prepareStatement();<br>ResultSet rst=pst.executeQuery(“select * from book”);</p><p>D.PreparedStatement pst=con.prepareStatement(“select * from book”);<br>ResultSet rst=pst.executeQuery();</p><p><strong>答案：</strong><br>A D  </p><p><strong>解析：</strong><br>A,D是正确的；创建Statement是不传参的，PreparedStatement是需要传入sql语句<br>说一下preparedStatement和statement的区别与联系：在JDBC应用中,如果你已经是稍有水平开发者,你就应该始终以PreparedStatement代替Statement.也就是说,在任何时候都不要使用Statement。<br>PreparedStatement 接口继承 Statement,PreparedStatement 实例包含已编译的 SQL 语句,所以其执行速度要快于Statement对象。Statement为一条Sql语句生成执行计划，如果要执行两条sql语句select colume from table where colume=1;select colume from table where colume=2; 会生成两个执行计划一千个查询就生成一千个执行计划！ PreparedStatement用于使用绑定变量重用执行计划 select colume from table where colume=:x; 通过set不同数据只需要生成一次执行计划，可以重用</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">笔试内容集合</a> 持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-283e473b53f21625?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（一）</title>
      <link href="/2019/09/11/interview/java/B-bishi01/"/>
      <url>/2019/09/11/interview/java/B-bishi01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-9b65a59238ede835.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（一）"></p><h2 id="1-若在某一个类定义中定义有如下的方法：-abstract-void-performDial-该方法属于（）"><a href="#1-若在某一个类定义中定义有如下的方法：-abstract-void-performDial-该方法属于（）" class="headerlink" title="1. 若在某一个类定义中定义有如下的方法： abstract void performDial( ); 该方法属于（） ?"></a>1. 若在某一个类定义中定义有如下的方法： abstract void performDial( ); 该方法属于（） ?</h2><p>A.本地方法<br>B.最终方法<br>C.静态方法<br>D.抽象方法</p><p><strong>答案：</strong> D</p><p><strong>解析：</strong></p><ul><li>本地方法：简单地讲，一个native Method就是一个java调用非java代码的接口；native方法表示该方法要用另外一种依赖平台的编程语言实现。</li><li>最终方法：final void B(){},这样定义的方法就是最终方法，最终方法在子类中不可以被重写，也就是说，如果有个子类继承了这个最终方法所在的类，那么这个子类中不能出现void B(){}这样的方法。 </li><li>最终类：final class A {},这样定义的类就是最终类，最终类不能被继承。 </li><li>abstract修饰抽象类 </li></ul><h2 id="2-在为传统面向对象语言的程序做单元测试的时候-经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？"><a href="#2-在为传统面向对象语言的程序做单元测试的时候-经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？" class="headerlink" title="2.在为传统面向对象语言的程序做单元测试的时候,经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？"></a>2.在为传统面向对象语言的程序做单元测试的时候,经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？</h2><p>A.封装<br>B.多态<br>C.继承<br>D.抽象</p><p><strong>答案：</strong>  A</p><p><strong>解析：</strong><br>A.封装<br>反射破坏代码的封装性，破坏原有的访问修饰符访问限制 </p><h2 id="3-以下程序的执行结果是："><a href="#3-以下程序的执行结果是：" class="headerlink" title="3.以下程序的执行结果是："></a>3.以下程序的执行结果是：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static boolean foo(char c) &#123;</span><br><span class="line">System.out.print(c);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main1(String[] args) &#123;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">for (foo(&#39;A&#39;); foo(&#39;B&#39;) &amp;&amp; (i &lt; 2); foo(&#39;C&#39;)) &#123;</span><br><span class="line">i++;</span><br><span class="line">foo(&#39;D&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.ABDCBDCB<br>B.ABCDABCD<br>C.编译时出错<br>D.运行时抛出异常</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>略，代码敲一遍就知道了= =！</p><ol start="4"><li>一个完整的URL地址由(),(),端口和文件四部分组成。 </li></ol><p>A.协议 用户名<br>B.协议 主机名<br>C.主机名 ip<br>D.以上都不正确</p><p><strong>答案：</strong><br>B </p><p><strong>解析：</strong><br><strong>URL(Uniform Resource Locator) *<em>，统一资源定位符，能够对因特网的资源进行定位。<br>*</em>URL</strong>一般有四部分组成： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><ul><li>现在最常用的&lt;协议&gt;为http协议。</li><li>&lt;主机&gt;是指主机在因特网上的域名。</li><li>http协议的默认&lt;端口&gt;为80（可以省略）。</li><li>&lt;路径&gt;是指要活的的文件的路径。 </li></ul><h2 id="5-以下程序的输出结果是？"><a href="#5-以下程序的输出结果是？" class="headerlink" title="5.以下程序的输出结果是？"></a>5.以下程序的输出结果是？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    String str &#x3D; new String(&quot;good&quot;);</span><br><span class="line">    char[] ch &#x3D; &#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39; &#125;;</span><br><span class="line"> </span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Example ex &#x3D; new Example();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str + &quot; and &quot;);</span><br><span class="line">        System.out.print(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   public static void change(String str, char ch[])      </span><br><span class="line">   &#123;</span><br><span class="line">        str &#x3D; &quot;test ok&quot;;</span><br><span class="line">        ch[0] &#x3D; &#39;g&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.good and abc<br>B.good and gbc<br>C.test ok and abc<br>D.test ok and gbc</p><p><strong>答案：</strong><br>B </p><p><strong>解析：</strong><br>考察值传递和引用传递。对于值传递，拷贝的值用完之后就会被释放，对原值没有任何影响，但是对于引用传递，拷贝的是对象的引用，和原值指向的同一块地址，即操作的是同一个对象，所以操作之间会相互影响<br>所以对于String str是值传递，操作之间互不影响，原值保持不变。而ch是数组，拷贝的是对象的引用，值发生了改变，因此选择B </p><h2 id="6-下面有关servlet-service描述错误的是？"><a href="#6-下面有关servlet-service描述错误的是？" class="headerlink" title="6.下面有关servlet service描述错误的是？"></a>6.下面有关servlet service描述错误的是？</h2><p>A.不管是post还是get方法提交过来的连接，都会在service中处理<br>B.doGet/doPost 则是在 javax.servlet.GenericServlet 中实现的<br>C.service()是在javax.servlet.Servlet接口中定义的<br>D.service判断请求类型，决定是调用doGet还是doPost方法</p><p><strong>答案：</strong><br>B </p><p><strong>解析：</strong><br>doGet/doPost 则是在 javax.servlet.http.HttpServlet 中实现的</p><h2 id="7-以下代码运行输出的是"><a href="#7-以下代码运行输出的是" class="headerlink" title="7.以下代码运行输出的是"></a>7.以下代码运行输出的是</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">    private String name &#x3D; &quot;Person&quot;;</span><br><span class="line">    int age&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line">public class Child extends Person&#123;</span><br><span class="line">    public String grade;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Person p &#x3D; new Child();</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.输出：Person<br>B.没有输出<br>C.编译出错<br>D.运行出错</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>Java中对字段属性是静态绑定，方法成员是动态绑定，这里错在：在子类中试图访问父类的private字段，所以编译不通过，将private去掉就可访问，不是动态绑定的问题，它本来就属于静态绑定。</p><h2 id="8-在-myjsp-jsp-中，关于下面的代码说法错误的是："><a href="#8-在-myjsp-jsp-中，关于下面的代码说法错误的是：" class="headerlink" title="8.  在 myjsp.jsp 中，关于下面的代码说法错误的是： (  )"></a>8.  在 myjsp.jsp 中，关于下面的代码说法错误的是： (  )</h2><p>&lt;%@ page language=”java” import=”java.util.*” errorPage=”error.jsp” isErrorPage=”false” %&gt; </p><p>A.该页面可以使用 exception 对象<br>B.该页面发生异常会转向 error.jsp<br>C.存在 errorPage 属性时，isErrorPage 是默认为 false<br>D.error.jsp 页面一定要有isErrorPage 属性且值为 true</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>exception是JSP九大内置对象之一，其实例代表其他页面的异常和错误。只有当页面是错误处理页面时，即isErroePage为true时，该对象才可以使用。对于C项，errorPage的实质就是JSP的异常处理机制,发生异常时才会跳转到errorPage指定的页面，没必要给errorPage再设置一个errorPage。所以当errorPage属性存在时， isErrorPage属性值为false </p><h2 id="9-Java对象的初始化方式有（-）"><a href="#9-Java对象的初始化方式有（-）" class="headerlink" title="9.Java对象的初始化方式有（ ）"></a>9.Java对象的初始化方式有（ ）</h2><p>A.初始化块<br>B.构造器<br>C.定义变量时指定初始化值<br>D.其它各项都不对</p><p><strong>答案：</strong><br>A B C</p><p><strong>解析：</strong></p><p>对象的初始化方式：<br>1.new时初始化 ；<br>2.静态工厂 newInstance；<br>3.反射Class.forName()；<br>4.clone方式；<br>5.反序列化；</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">Java笔试内容集合</a> 持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-dcdca3329b2e2104?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP备考指南之第二章：项目运作环境</title>
      <link href="/2019/04/24/pmp/PMP03/"/>
      <url>/2019/04/24/pmp/PMP03/</url>
      
        <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/7326374-4b037c7db1d5d591.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PMP备考指南之第二章：项目运作环境" title="PMP备考指南之第二章：项目运作环境"></p><blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎关注个人博客网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><blockquote><p>本文已同步至 <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">GitHub</a>/<a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">Gitee</a>/公众号，感兴趣的同学帮忙点波关注~</p></blockquote><h1 id="第二章：项目运作环境"><a href="#第二章：项目运作环境" class="headerlink" title="第二章：项目运作环境"></a>第二章：项目运作环境</h1><h2 id="1-事业环境因素、组织过程资产"><a href="#1-事业环境因素、组织过程资产" class="headerlink" title="1. 事业环境因素、组织过程资产"></a>1. 事业环境因素、组织过程资产</h2><p>事业环境因素 Enterprise Environmental Factors:是项目团队不能控制的，将对项目产生影响、限制或指令作用的各种条件。可能提高或限制项目管理的灵活性，也可能对项目结果产生积极或消极影响。包括：</p><p>1）组织文化、结构和治理；<br>2）设施和资源的地理分布；<br>3）基础设施：现有设施、设备、组织通讯渠道、IT 硬件、可用性和性能等<br>4）信息技术软件：进度计划软件工具、配置管理系统、其他在线自动化系统的网络接口、工作授权系统等<br>5）资源可用性：合同和采购制约因素、已批准的供应商、分包商和合作协议等）<br>6）员工能力：现有人力资源的专业知识、技能、能力和特定知识</p><p>（以上6条来自组织内部）</p><p>7）市场条件：竞争者、市场份额、品牌认知、商标等<br>8）社会和文化影响与问题：政治氛围、行为规范、道德、观念等<br>9）法律限制：与安全、数据保护、商业行为、雇佣与采购等有关的国家和地方法律法规<br>10）商业数据库：标杆对照结果、标准化的成本估算数据、行业风险研究信息、风险数据库等<br>11）学术研究：行业研究、出版物、标杆对照结果等<br>12）政府或行业标准：与产品、生产、环境、质量、工艺等有关的监管机构法规和标准<br>13）财务考虑因素：货币汇率、利率、通货膨胀率、关税、地理位置等<br>14）物理环境因素：工作条件、天气、制约因素等</p><p>（以上 8 条来自组织外部 ）</p><h2 id="2-组织文化与风格（内部的事业环境因素）"><a href="#2-组织文化与风格（内部的事业环境因素）" class="headerlink" title="2. 组织文化与风格（内部的事业环境因素）"></a>2. 组织文化与风格（内部的事业环境因素）</h2><ul><li>文化与风格是经过长期积淀而形成的群体现象，组织文化由组织成员的共同经验积淀而成。</li><li>共同的愿景、使命、价值观、信念和期望；</li><li>规章、政策、方法和程序；</li><li>对领导力、层级体系和职权关系的看法；</li><li>行为准则、职业道德；</li><li>风险承受力；</li><li>运营环境等等。</li></ul><p><strong>事业环境因素 ： 有来自组织内的、也有组织外的，都是项目团队不能控制、无法避免的。</strong></p><h2 id="3-组织过程资产"><a href="#3-组织过程资产" class="headerlink" title="3. 组织过程资产"></a>3. 组织过程资产</h2><p>一定是组织内部的。组织过程资产是执行组织所特有并使用的计划、流程、政策、程序和知识库，包括来自任何项目参与组织的，可用于执行或治理项目的任何产物、实践或知识。</p><p>包括两大类：</p><ul><li>过程、政策与程序（通常由 PMO 更新）</li><li>组织知识库（通常由项目更新）。</li></ul><h3 id="3-1-过程、政策与程序"><a href="#3-1-过程、政策与程序" class="headerlink" title="3.1 过程、政策与程序"></a>3.1 过程、政策与程序</h3><p>组织用于执行工作的流程与程序。</p><h4 id="3-1-1-启动和规划："><a href="#3-1-1-启动和规划：" class="headerlink" title="3.1.1 启动和规划："></a>3.1.1 启动和规划：</h4><p>1）指南和标准，用于裁剪的标准流程和程序以满足项目的特定要求<br>2）特定的组织标准，例如各种政策（如 HR、HSE、安保与保密、质量、采购和环境等政策）<br>3）产品和项目生命周期、方法与程序（如项目管理方法、评估指标、过程审计、改进目标、核对单、组织内使用的标准化的过程定义等）<br>4）模板（如项目管理计划、项目文件、项目登记册、报告格式、合同模板、风险分类、风险描述模板、概率与影响定义、概率和影响矩阵、以及干系人登记册模板等）<br>5） 预先批准的供应商清单和各种合同协议类型（如总价合同、成本补偿合同和工料合同）</p><h4 id="3-1-2-执行和监控："><a href="#3-1-2-执行和监控：" class="headerlink" title="3.1.2 执行和监控："></a>3.1.2 执行和监控：</h4><p>1） 变更控制程序<br>2） 风险控制程序<br>3） 跟踪矩阵<br>4） 财务控制程序<br>5） 问题与缺陷管理程序<br>6） 资源的可用性控制和分配管理<br>7） 组织对沟通的要求<br>8） 确定工作优先顺序、批准工作与签发工作授权的程序<br>9）模板（如风险登记册、问题日志和变更日志）<br>10）标准化的指南、工作指示、建议书评价准则和绩效测量准<br>11）产品、服务或成果的核实和确认程序</p><h4 id="3-1-3-收尾"><a href="#3-1-3-收尾" class="headerlink" title="3.1.3 收尾"></a>3.1.3 收尾</h4><p>项目收尾指南和要求（如项目终期审计、项目评价、可交付成果验收、合同收尾、资源分配，以及向生产和（或）运营部门转移知识等）</p><h3 id="3-2-组织知识库"><a href="#3-2-组织知识库" class="headerlink" title="3.2 组织知识库"></a>3.2 组织知识库</h3><p>组织用来存取信息的知识库。</p><p>包括：<br>1）配置管理知识库；<br>2）财务数据库；<br>3）历史信息与经验教训知识库；（项目收尾时，要总结经验教训、更新组织过程资产，供<br>将来的项目参考。这是考点）<br>4）问题与缺陷管理数据库；<br>5）测量指标数据库；<br>6）以往项目的项目档案；</p><h2 id="4-如何区分组织过程资产和事业环境因素？"><a href="#4-如何区分组织过程资产和事业环境因素？" class="headerlink" title="4. 如何区分组织过程资产和事业环境因素？"></a>4. 如何区分组织过程资产和事业环境因素？</h2><p>第 1，是组织内部的还是外部的，如果是外部的，一定是事业环境因素；如果是组织内部，可能是组织过程资产，也可能是事业环境因素。<br>第 2，项目经理是否可以选择，组织过程资产是可以选择用或不用；事业环境因素是不容项目经理选择的。<br>第 3，以“程序”结尾的词大多是组织过程资产；以“系统”结尾的词大多是事业环境因素</p><h2 id="5-组织结构"><a href="#5-组织结构" class="headerlink" title="5.组织结构"></a>5.组织结构</h2><p>组织结构/组织形式定义：人员的职责、权限和相互关系的安排；是一种事业环境因素。可能影响人力资源的可用性和项目的执行方式。<br>三大类：职能型、矩阵型（弱矩阵、平衡矩阵、强矩阵）、项目导向型，所以一共是五种组织结构。<br>五种组织结构我们一个个介绍：</p><h3 id="5-1-职能型组织"><a href="#5-1-职能型组织" class="headerlink" title="5.1 职能型组织"></a>5.1 职能型组织</h3><p><img src="http://upload-images.jianshu.io/upload_images/7326374-829f7696b02b2a43.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="职能型组织" title="职能型组织"></p><p>职能经理就是部门经理角色，职能经理掌握人员绩效、完全掌握项目预算。pm 是兼职，pm极小或没有权力。</p><p>职能型组织 优点：员工只有一个上级、单线沟通、职责分工明确。<br>职能型组织 缺点：跨部门沟通困难，部门利益高于项目，员工以自己的本职工作为重点，妨碍客户参与项目，因此对项目的反应速度特别慢。</p><h3 id="5-2-弱矩阵型组织"><a href="#5-2-弱矩阵型组织" class="headerlink" title="5.2 弱矩阵型组织"></a>5.2 弱矩阵型组织</h3><p><img src="http://upload-images.jianshu.io/upload_images/7326374-32ff5286311580e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="弱矩阵型组织" title="弱矩阵型组织"></p><p>pm 权力小于职能经理比起职能型组织，弱矩阵的优点：加强了部门间沟通.pm 是项目联络员或协调员。</p><p>项目联络员和协调员有区别：<br>项目联络员：联络沟通作用，没有权力，需要职能经理做决定。<br>项目协调员：有一定的决策权、可以向高层经理汇报,打小报告。<br>所以两者最大的区别在于：是否能够做决策。职能经理完全掌握预算，pm 是兼职</p><h3 id="5-3-平衡矩阵组织"><a href="#5-3-平衡矩阵组织" class="headerlink" title="5.3 平衡矩阵组织"></a>5.3 平衡矩阵组织</h3><p><img src="http://upload-images.jianshu.io/upload_images/7326374-0f2f5e24d5a5e2d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="平衡矩阵组织" title="平衡矩阵组织"></p><p>PM 权力几乎等于职能经理</p><p>优点：资源使用效率高</p><p>缺点：员工要听 2 个领导<br>pm 和职能经理共同掌握预算，pm 兼职。平衡矩阵可以叫项目经理了，弱矩阵和职能型里叫项目协调员或项目联络员。<br>缺省组织架构：如果 pmp 考试中，题目没有特别声明是什么组织类型，就默认是平衡矩阵。</p><h3 id="5-4-强矩阵组织"><a href="#5-4-强矩阵组织" class="headerlink" title="5.4 强矩阵组织"></a>5.4 强矩阵组织</h3><p><img src="http://upload-images.jianshu.io/upload_images/7326374-2f5b6306ee43eff1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="强矩阵组织" title="强矩阵组织"></p><p>pm 拥有中到高的权力。强矩阵型组织中，PM 和项目管理行政人员都是全职，并且拥有全权管理项目预算的权力。这是强矩阵组织和职能型、弱矩阵、平衡矩阵最大的不同。</p><p>PM 的汇报上级不再是职能经理，而是项目经理的经理。</p><p>矩阵式组织：<br>优点：兼顾项目与职能工作，资源使用率更高，比职能型组织部门间沟通更好<br>缺点：一个员工有 2 个汇报对象（pm 和职能经理），沟通复杂。</p><h3 id="5-5-项目型组织"><a href="#5-5-项目型组织" class="headerlink" title="5.5 项目型组织"></a>5.5 项目型组织</h3><p><img src="http://upload-images.jianshu.io/upload_images/7326374-01eeeb6250e3f2bf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目型组织" title="项目型组织"></p><p>Pm 拥有高到几乎全部的职权，对预算完全掌握，pm 和项目管理行政人员都是全职。<br>优点：pm 权力充分，团队职责清晰，沟通容易，对项目的反应速度非常快。<br>缺点：员工缺乏归属感、缺乏事业的连续性和保障，资源配置重复使用效率低。</p><p>三大类组织结构总结如下：</p><p>1）职能型：适合专业技能单一、在部门内开展简单项目活动；<br>2）矩阵型：适合跨部门、跨专业的项目，提高资源的使用效率；<br>3）项目型：适合项目难度高、风险大，需要团队全身心投入，pm 最大限度的掌握项目资源。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-291660ad31b1f9f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三大类组织结构" title="三大类组织结构"></p><p>项目管理办公室（ Project Management Office ， PMO ）<br>1、定义：是对与项目相关的治理过程进行标准化，并促进资源、方法论、工具和技术共享的一个组织部门。<br>2、按照对项目控制权力的大小来分，支持型、控制型、指令型。PMO的职责范围可大可小，从提供项目管理支持服务，到直接管理一个或多个项目。<br> 1）支持型：担当顾问角色，为各位项目经理提供项目模板、最佳实践、培训、经验教训等资源支持，权力很小，打打酱油玩的 PMO。<br> 2）控制型：PMO 权力居中<br> 3）指令型：直接管理和控制项目，控制权力最大的是指令型。</p><p>3、PM 和 PMO 角色差异：<br>PM——Project Manager 项目经理<br>PMO——Project Management Office 项目管理办公室<br>1）项目经理关注特定的项目目标（单个项目），PMO 关注项目集（多个项目）范围的变更；<br>2）项目经理控制分配给本项目资源，PMO 优化利用所有项目所共享的组织资源；<br>3）项目经理管理单个项目的制约因素（范围、进度、成本、质量等），PMO 站在企业的高度对方法论、标准、整体风险/机会、测量指标和项目间的依赖关系进行管理。从以上总结的三点我们能感觉出来 PMO 是 PM 的上级领导。 </p><h2 id="6-练习题"><a href="#6-练习题" class="headerlink" title="6. 练习题"></a>6. 练习题</h2><p>一个项目经理刚接手一个新项目，该项目和他以前做过的一个项目类似。为了借鉴以前项目的经验，他应该先查看哪份文件？</p><p>A、项目章程<br>B、项目管理计划<br>C、历史信息<br>D、合同</p><p>参考答案：C。为了借鉴项目的经验，应该查看历史信息。历史信息属于组织过程资产，里面有以往项目的成功经验与失败教训。</p><p>发起人因费用超标要终止项目，关键干系人不同意，关键干系人认为项目不能仅仅用钱衡量。项目经理需要做一个经验教训总结报告，该文件属于以下哪一项？</p><p>A、组织过程资产<br>B、项目管理计划<br>C、风险管理计划<br>D、事业环境因素</p><p>参考答案：A。经验教训总结报告存档在组织过程资产中。</p><p>在实施一个新的 it 系统后，公司遭遇持续不满。项目经理应该做什么来改进未来类似项目的满意度？</p><p>A.建立一个通用的软件模块代码库<br>B.确保更新项目管理信息系统（pmis）数据并可用<br>C.安排一次与公司其他项目经理的会议<br>D.创建一个经验教训知识库</p><p>答案：D。要改进未来项目的满意度，需要参考过去的成功经验和失败的教训。组织过程资产的价值</p><p>某公司建立了一个项目管理办公室，用于协调和管理其众多项目。公司的 PMO 提出了一个具体的项目组织结构建议，并作为标准在全公司实施。该组织结构特点是设置了享有中高级权力（包括控制项目预算）的全职项目经理和全职管理人员。该 PMO 提出了何种组织结构？</p><p>A、 强矩阵<br>B、 弱矩阵<br>C、 项目型<br>D、 职能型</p><p>答案：A。中高级权力的 PM，管理人员是全职，这是强矩阵组织结构。</p><p>很小或没有职权的项目经理属于下列哪一种组织类型组成部分？</p><p>A、 弱矩阵<br>B、 职能型<br>C、 强矩阵<br>D、 平衡矩阵</p><p>答案：B。很小或没有权力的 PM 是职能型。</p><p>你在不同文化、不同部门间，负责一个项目，请问在什么组织类型中？</p><p>A、项目型<br>B、职能型<br>C、矩阵型<br>D、完全项目型</p><p>答案：C。矩阵型：适合跨部门、跨专业的项目，提高资源的使用效率；</p><blockquote><p>关注公众号，随时随地获取编程知识，面试题，PMP等相关资料<br><img src="http://upload-images.jianshu.io/upload_images/7326374-acf306463da9635e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/7326374-5036c26bc9329384.jpg?imageMogr2/auto-orient/strip" alt="求关注" title="求关注"></p>]]></content>
      
      
      <categories>
          
          <category> PMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP备考指南之第一章：引论</title>
      <link href="/2019/04/23/pmp/PMP02/"/>
      <url>/2019/04/23/pmp/PMP02/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7326374-bd3bfc390a2513e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PMP-引论.png"></p><blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎关注个人博客网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><blockquote><p>本文已同步至 <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">GitHub</a>/<a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">Gitee</a>/公众号，感兴趣的同学帮忙点波关注~</p></blockquote><h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章  引论"></a>第一章  引论</h1><p>1、“项目管理知识体系”：应该包含所有行业、应用领域项目管理的具体知识、技能、方法和实践。<br>2、我们发的这本巨厚的书叫“项目管理知识体系指南”简称“PMBOK 指南”，PMBOK 指南的目的：</p><ul><li>收录项目管理知识体系中被“普遍公认”的“良好做法”的那一部分。</li><li>形成的一个项目管理标准和框架，提供一套项目管理专业的通用词汇；适用于所有领域、行业的项目管理。</li><li>标准实践中可以加以选择和裁剪；</li><li>PMBOK 指南只讨论单个项目的管理</li><li>PMBOK 指南只讨论项目管理的共性</li><li>它是一套项目管理的指南，并不是具体的方法论。</li></ul><h2 id="1-什么是项目？"><a href="#1-什么是项目？" class="headerlink" title="1. 什么是项目？"></a>1. 什么是项目？</h2><p>项目是：为创造独特的产品、服务或成果而进行的临时性工作。</p><p><strong>pmbok 告诉我们项目有三大特性：<code>临时性</code>、<code>独特性</code>、<code>渐进明细</code></strong>。</p><p>1）项目的过程是临时的，但临时并不意味着时间短。比如：修建体育场鸟巢是个项目，这个项目用了好几年时间，这个时间很长。过程是临时的，指的是项目有明确的起点和终点，起点是立项的时候。终点是：</p><ul><li>目标达成（正常收尾）</li><li>不能达到目标项目终止（有可能是没钱了）</li><li>项目需求不复存在</li><li>客户或发起人希望终止等等</li></ul><p>2）结果的独特性：项目创造的可交付成果是独特的，所以导致项目的不确定性和风险。项目创造出来的结果，PMBOK 里叫做可交付成果。可交付成果：可以是有形的产品，也可以是无形的服务能力、知识。比如：咱们参加PMP 培训这是一个项目，参加考试后得到的 PMP 的培训证书这是有形的产品，所掌握的项目管理知识这是无形的。这些都是可交付成果。</p><p>3）渐进明细：项目的计划不可能一步到位，随着项目的进展信息越来越详细具体、估算越来越准确，而持续改进和细化计划。由于可能发生变化，应该在整个项目生命周期中，反复开展制定项目管理计划工作，对计划进行渐进明细。</p><h3 id="1-1-商业价值"><a href="#1-1-商业价值" class="headerlink" title="1.1 商业价值"></a>1.1 商业价值</h3><p>是指组织所从事业务的整体价值，包括全部的有形和无形价值。</p><p>1）有形价值包括：货币资产、固定设施、股东权益、物品器材等</p><p>2）无形价值包括：商誉、品牌认知度、公共利益、商标等</p><p>对持续运营的有效管理可以创造商业价值。<br>对项目的投资可以提升创造商业价值的能力。</p><h2 id="2-什么是项目管理？"><a href="#2-什么是项目管理？" class="headerlink" title="2. 什么是项目管理？"></a>2. 什么是项目管理？</h2><ol><li><p>项目管理是将知识、技能、工具与技术应用于项目活动，以满足项目的要求。项目管理通过合理运用和整合 49 个项目管理过程得以实现。</p></li><li><p>49个项目管理过程归类于五大过程组：启动、规划、执行、监控、收尾。项目可能各种各样，但是项目管理的过程和过程组是通用的。</p></li><li><p>项目管理需要满足并平衡相互制约的多重因素，比如：范围、质量、进度、预算、资源、风险。</p></li></ol><h3 id="2-1-项目集管理、项目组合管理："><a href="#2-1-项目集管理、项目组合管理：" class="headerlink" title="2.1 项目集管理、项目组合管理："></a>2.1 项目集管理、项目组合管理：</h3><ol><li><p>项目集：是一组相互关联且被协调管理的项目、子项目集和项目集活动。<br>项目集重点关注项目间的依赖关系，找到管理这些依赖关系的最佳方法。比如：参加英文培训+大学英语考试 CET 四六级、托福、雅思考试。这是一组项目集。互相有关联性都是英语培训考试、有依赖关系。</p></li><li><p>项目组合：是为了实现战略目标组合在一起管理的项目、项目集、子项目组合和运营工作。为实现战略目标或便于管理而组合在一起的项目，不一定彼此有依赖关系或直接相关，但可共享资源、供应商、技术等，关注资源的优先分配。比如：周杰伦自己的本行是歌手，应该唱歌开演唱会，但是现在还做一些与本行没有关系的事，开餐厅、卖古董、开健身房等等，这些事不一定直接相关，但它是关注资源（周杰伦的钱）的优先分配，到底钱先用来开餐厅还是开健身房？并且共享了周杰伦这位共同的雇主。</p></li><li><p>项目集、项目组合和项目之间的关系：项目组合中可以包含若干项目集或项目，项目集可以包含若干项目。</p></li></ol><h2 id="3-项目与战略规划"><a href="#3-项目与战略规划" class="headerlink" title="3. 项目与战略规划"></a>3. 项目与战略规划</h2><p>项目是组织实现战略目标的常用手段。这句话的意思是说做任何一个项目，都要和组织的战略目标保持一致，如果和战略目标不一致，这个项目也就没有存在的意义。</p><p>出于以下战略考虑来批准项目：</p><ul><li>市场需求</li><li>战略机会/业务需求</li><li>社会需要</li><li>环境考虑</li><li>客户要求</li><li>技术进步</li><li>法律要求</li></ul><h3 id="3-1-项目与运营"><a href="#3-1-项目与运营" class="headerlink" title="3.1 项目与运营"></a>3.1 项目与运营</h3><p>运营是支撑日常业务，实现业务战略和战术目标的手段。<br>运营的特性：持续性、重复性。<br>项目的特性：临时性、独特性。</p><p>运营的目标是为了维持经营，运营工作中会产生项目需求，某些运营无法实现的结果需要通过项目的方式实现；<br>项目的结果可能回到运营中去，变成日常工作内容。因此，项目经理在项目中需要充分考虑来自运营部门的干系人的需求。项目的目标是实现其目标，然后结束项目。</p><h3 id="3-2-项目生命周期"><a href="#3-2-项目生命周期" class="headerlink" title="3.2 项目生命周期"></a>3.2 项目生命周期</h3><p>1 、定义：项目生命周期是指从启动到收尾的一系列阶段，这些阶段通常按顺序排列，阶段通常有时间限制，每一个阶段都是一个子项目，有明确的起点和终点。</p><p>通用的项目生命周期结构：</p><ul><li>启动项目（概念阶段）</li><li>组织与准备（开发/规划阶段）</li><li>执行项目工作（实施阶段）</li><li>结束项目（收尾阶段）</li></ul><p>需要定义多少个阶段，和管理控制要求有关。如果希望管控的更严密些，则可以多定义一些阶段；反之则可以少一些。阶段，是从技术角度来划分的；过程组，从管理的角度来划分项目。既然每一个阶段都是一个子项目，那么就意味着每一个阶段都包括了五大过程组（启动、规划、执行、监控、收尾）。</p><p>​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​</p><h3 id="3-3-项目生命周期的特征：​"><a href="#3-3-项目生命周期的特征：​" class="headerlink" title="3.3 项目生命周期的特征：​"></a>3.3 项目生命周期的特征：​</h3><p>​​​​​​​​​​<br>​​​​​​​​​​​<img src="http://upload-images.jianshu.io/upload_images/7326374-8e0503841717e38e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命特征"></p><p>1）成本与人力投入开始时低，执行期间最高，项目收尾结束时迅速回落；</p><p>2）项目的风险与不确定性、干系人的影响力，开始最大，逐步减小；项目一开始风险是最大的，因为一开始一切都是未知，随着项目进行中，项目渐进明细，风险和不确定性慢慢减小。干系人影响力一开始最大，产品最初只有雏形干系人很轻易的可以改变它，随着项目进展产品逐步有了明确特性，干系人如果要改变它是很困难的，变更的代价非常高，因此干系人的影响力是减小的。</p><p>3）变更的代价，开始时最小，项目收尾时最大。因为随着项目的进行成本投入越来越多，变更付出的代价也会越来越大。</p><p>3 、阶段与阶段的关系：<br>1）阶段按顺序进行，一个阶段只能在前一阶段完成后开始，称为“顺序关系”。按部就班的特点减少了项目的不确定性，但也排除缩短项目总工期的可能性。</p><p>2）为缩短项目工期，一个阶段在前一个阶段完成前开始，称为“交叠关系”。这种做法可能需要额外的资源来并行开展工作，可能增加风险和返工的机会。阶段的结束，以阶段性可交付成果的移交为标志，阶段结束时间点可称为：里程碑、阶段关口、阶段审查、阶段门、关键决策点。</p><h3 id="3-4-五种类型的生命周期："><a href="#3-4-五种类型的生命周期：" class="headerlink" title="3.4 五种类型的生命周期："></a>3.4 五种类型的生命周期：</h3><p>1）预测型生命周期：也叫完全计划型，一个阶段一个阶段的按部就班执行，适用于对项目结果了解很充分的项目。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-1c715aa7c93b4c20?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="预测型生命周期"></p><p>先做需求分析，再做概要设计、详细设计、然后编码、测试、最后发布，按照计划去做，基本没有变更。</p><p>2）迭代型生命周期：通过一系列重复的循环活动、来不断优化产品功能。比如：磨刀，每一轮迭代都要把刀磨的更加锋利。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-7d8f9601b2710b6c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="迭代型生命周期"></p><p>3）增量型生命周期：在预定的时间内渐进地增加产品的功能。例如：开发多功能洗衣机，第一个阶段开发出一个功能（漂洗），第二个阶段开发出第二个功能（甩干），第三个阶段开发出第三个功能（烘干）。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-c4f4978d0555236c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增量型生命周期"></p><p>4）适应型生命周期（也叫变更驱动、敏捷方法）：迭代型和增量型的混合。最终目标和交付的成果也难以事先确定，管理过程也经常有变化,需要应对快速变化的环境。例如：秘书为领导写稿，秘书先根据领导的最初要求写出第一个版本的草稿（可交付成果）。领导看了以后提出意见（新的需求），秘书再根据意见写出第二个草稿（可交付成果），交给领导查看。如此多次迭代，直到写出让领导满意的稿子。相当于一边提需求，一边交付。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-79d6bf9b0d30ef04?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="适应型生命周期"></p><p>5）混合型生命周期：瀑布与敏捷的混合，充分了解或有确定需求的项目要素遵循预测型开发生命周期，而仍在发展中的要素遵循适应型开发生命周期。例如：硬件部分用预测型，软件部分用适应型。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-b7f52ff527499302?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="混合型生命周期"></p><h3 id="3-5-项目管理过程"><a href="#3-5-项目管理过程" class="headerlink" title="3.5 项目管理过程"></a>3.5 项目管理过程</h3><p>1、过程是为创建预定的产品、服务或成果而执行的一系列相互关联的行动和活动。过程将会是以后我们面对 PMP 讲义主要内容，组织过程资产和事业环境因素即使没有列出也需要参考。事业环境因素（EEFs）限制项目的灵活性，组织过程资产（OPAs）为裁剪过程提供指南和准则。</p><p>2、过程由输入、工具与技术、输出三部分构成</p><p>Input 输入<br>Tools &amp; Technique 工具与技术<br>Output 输出</p><p>输入、工具与技术、输出简称为 ITTO<br>I 输入，需要什么？<br>TT 用什么方法和手段？<br>O 输出，产生什么？</p><p>比如：制作红茶的过程；<br>输入：茶叶、水等；<br>工具与技术：发酵、加热、烹、煮；<br>输出：红茶。</p><p>3、PMI 把项目管理分为 49 个过程；那么这 49 个过程间是怎么样联系的呢？</p><p>一个过程的输出会成为另一个过程的输入。比如我们刚才讲的例子，制作红茶的过程。输出是：红茶。对于另一个过程“制作珍珠奶茶”，此时“红茶”又作为输入了。</p><p>输入：红茶、珍珠、水<br>工具与技术：混合搅拌、煮<br>输出：珍珠奶茶</p><p>这是制作珍珠奶茶的过程。</p><p><strong>49个项目管理过程被分在5大过程组中，启动、规划、执行、监控、收 尾。PMP学习重点将围绕这49个过程的ITTO展开。</strong></p><p>49  个项目管理过程被分在 5  大过程组中，启动、规划、执行、监控、收尾。PMP学习重点将围绕这 49  个过程的 ITTO  展开。</p><p>1 ）启动过程组：</p><p>定义一个新项目或一个新阶段；过程组目的：保证干系人期望与项目目的的一致性，让干系人明了项目范围和目标，明白他们在项目和阶段中的参与，实现他们的期望。</p><ul><li>启动过程组的两个过程：识别干系人、制定项目章程。</li><li>识别干系人：是要识别他们的参与度、期望、影响力以及对项目成功的影响。</li><li>制定项目章程：一般由项目经理编写，项目管理团队协助编写。由发起人、PMO 或项目组合治理委员会等公司高层领导来批准。一旦项目章程获得批准，项目也就得到了正式的授权。</li></ul><p>2 ）规划过程组</p><p>明确项目范围，为实现目标制定行动方案；<br>过程组目的：制定用于指导项目实施的项目管理计划和项目文件。<br>过程组作用：为成功完成项目或阶段确定战略、战术及行动方案及路线。随着收集和掌握的项目信息或特性不断增多，以及发生的重大变更，项目可能需要进一步规划。项目管理计划的逐渐细化叫“渐进明细”，表明项目规划和文档编制是反复进行的秩序性活动。在规划项目、制定项目管理计划和项目文件时，项目团队应当征求所有干系人的意见，鼓励所有干系人的参与。</p><p>3）执行过程组</p><p>完成项目管理计划中确定的工作，满足项目规范要求；过程组需要：按照项目管理计划来协调人员与资源，管理干系人期望，以及整合并实施项目活动。执行的结果可能引发计划更新和基准重建，执行的偏差可能影响项目管理计划或项目文件，需要加以仔细分析，并制定适当的管理应对措施。项目的大部分预算将花费在执行过程组中。</p><p>4）监控过程组</p><p>跟踪、审查和调整项目进展与绩效，启动有必要的变更；过程组作用：定期对项目绩效进行测量和分析，从而识别与项目管理计划的偏差。控制变更，推荐纠正措施、制定预防措施等等。</p><p>5）收尾过程组</p><p>完结所有过程组的活动，正式结束项目或阶段。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-28e58257dc3df938?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="收尾过程组"></p><p>逻辑上五个过程组是按顺序进行的，但实际上有交叉部分，监控过程组贯穿整个生命周期。阶段是从技术角度来分解项目；过程是从管理角度来分解项目。</p><h2 id="4-十五矩阵"><a href="#4-十五矩阵" class="headerlink" title="4. 十五矩阵"></a>4. 十五矩阵</h2><p>把 49 个项目管理过程归入十大项目管理知识领域和五大项目管理过程组。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-2ac7be298da4797c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="十五矩阵"></p><p>1、最左边，纵向按照十大知识领域：项目整合管理、项目范围管理、项目时间管理、项目成本管理、项目质量管理、项目资源管理、项目沟通管理、项目风险管理、项目采购管理、项目干系人管理；</p><p>在 pmbok 第六版当中第 13 章叫相关方管理，但是考虑到干系人这个词在项目管理界用了10 多年，我们依然认为 “ 干系人 ” 更加的专业，仍然把 13 章叫做干系人管理，特此声明</p><p>第四章 项目整合管理：协调子计划的接口管理；<br>第五章 项目范围管理：确定项目哪些工作该做、哪些不该做；<br>第六章 项目进度管理：确保项目工作按时完成；<br>第七章 项目成本管理：确保项目工作按照预算完成；<br>第八章 项目质量管理：确保项目工作到达要求；<br>第九章 项目资源管理：做好实物资源和项目团队的管理；<br>第十章 项目沟通管理：有团队就需要沟通，做好沟通管理；<br>第十一章 项目风险管理：项目有不确定的、有可能发生的事件，做好风险管理；<br>第十二章 项目采购管理：有些工作自己不能做需要外包，做好采购管理；<br>第十三章 项目干系人管理：项目是满足干系人的要求，做好干系人管理。</p><p>2、最上方，横向按照项目管理过程五大过程组：启动过程组、规划过程组、执行过程组、监控过程组、收尾过程组；右边，灰色和白色填充处一共 49 个过程，是以后学习 PMP 理论的重点内容；</p><p>3、第四章项目整合管理知识领域包含:4.1 制定项目章程、4.2 制定项目管理计划、4.3 指导与管理项目执行、4.4 管理项目知识、4.5 监控项目工作、4.6 实施整体变更控制、4.7 结束项目或阶段 7 个过程。</p><p>4.1 制定项目章程过程属于启动过程组<br>4.2 制定项目管理计划过程属于规划过程组<br>4.3 指导与管理项目执行过程、4.4 管理项目知识，两个过程属于执行过程组<br>4.5 监控项目工作、4.6 实施整体变更控制，两个过程属于监控过程组<br>4.7 结束项目或阶段过程属于收尾过程组</p><p>以此类推，一共有 49 个过程。<br>可以看出之所以叫十五矩阵，是因为“十”十大知识领域，“五”五大过程组。之后的章节我们将围绕49个过程和过程的输入、工具与技术、输出展开。49个过程必须熟悉，要知道他们分别属于哪个知识领域，他们分别属于哪个过程组</p><h2 id="5-练习题"><a href="#5-练习题" class="headerlink" title="5. 练习题"></a>5. 练习题</h2><p>公司里面有 A、B、C 三个项目。这些项目根据公司的目标，按照一套相同的标准化分优先顺序。项目 B 的优先级较高，因为它将会扩大公司的市场份额，减少对不可靠供应商的依赖性。这是在执行什么活动？</p><p>A、 项目组合管理<br>B、 项目集管理<br>C、 项目管理<br>D、 份额管理</p><p>答案：A。题干说：关注资源的优先分配、减少依赖性。这是关键词</p><p>某个技术重组项目的计划处于计划编制阶段已经数月，在此期间，这项技术已得到显著的进步。这项目预计在这个月开始，而且必须更新范围管理计划来反映技术上的变化。项目经理必须向关键干系人详细说明项目范围存在的可能变更。项目经理理解项目的不确定性水平将会处于下列哪一种情况？</p><p>A、保持在预计和计划水平<br>B、增加<br>C、开始是增加，然后减少<br>D、减少</p><p>答案：D。项目一开始风险最大，因为一开始一切都是未知，随着项目进行中，项目渐进明细，风险和不确定性慢慢减小。</p><p>以下哪项陈述最准确描述了项目？</p><p>A、项目范围变更的代价在项目的最初阶段最大<br>B、项目干系人的影响在整个项目期间是相同的<br>C、在项目执行阶段成本和人力投入量达到顶峰<br>D、项目的下一阶段永远不应该开始，直到前一个阶段的可交付成果被完全审查和批准</p><p>答案：C。 项目范围变更的代价在项目的最初阶段是最小的，排除 A。项目干系人的影响在整个项目期间开始时最大，之后递减。排除 B 阶段可能交叠进行，排除 D。</p><p>在一个快速变化环境中工作的项目经理，将收集到的需求清单排列优先顺序进行工作计划。让优先级最高的可交付成果 3 周内完成。项目经理正在使用哪一种项目生命周期方法？</p><p>A、适应<br>B、预测<br>C、直觉<br>D、反复</p><p>答案 A，题干关键字“快速变化环境中”工作的 PM，这是适应型敏捷开发。快速变化就不可能用预测型，排除 B。</p><p>下列哪项陈述反映了项目的风险程度？</p><p>A、 项目初始阶段的风险最小<br>B、 风险在整个项目期间保持恒定<br>C、 项目实施过程中风险最大<br>D、 项目初始阶段风险最大</p><p>答案：D。项目的风险与不确定性，开始最大，逐步减小；</p><p>下列哪项最好地描述了项目利害关系者介入项目规划时所造成的影响？</p><p>A、耗时,使得规划过程变慢<br>B、只对内部服务合同有帮助<br>C、通常有助于制订完整、准确的项目计划<br>D、不需要，因为项目利害关系者通常不想介入</p><p>答案：C。在规划项目、制定项目管理计划和项目文件时，项目团队应当征求所以干系人的意见，鼓励所有干系人的参与。</p><p>项目经理正在负责一个十分复杂的大型项目，与项目团队成员讨论后决定分阶段予以实施，并定下了第一个阶段为设计阶段。请问在设计阶段中应进行哪些项目管理过程组？</p><p>A、启动和规划过程组<br>B、规划和执行过程组<br>C、启动、规划、执行、监控、收尾过程组<br>D、启动、执行、收尾过程组</p><p>答案：C。每个阶段都是一个子项目，都应该进行五大过程组。阶段＝子项目</p><p>在项目的什么时间点，项目经理将会审查控制措施？</p><p>A、在计划编制阶段<br>B、在启动和执行阶段<br>C、在项目收尾阶段<br>D、在项目过程中持续审查</p><p>答案：D。监控过程组贯穿整个项目始终。</p><p>执行过程组的主要目标是什么？</p><p>A. 跟踪并审查项目进度<br>B. 管理利害关系者的期望<br>C. 满足项目规范<br>D．监控进度表</p><p>答案:C.执行过程组定义：完成项目管理计划中的工作，满足项目规范要求。</p><blockquote><p>关注公众号，随时随地获取编程知识，面试题，PMP等相关资料<br><img src="http://upload-images.jianshu.io/upload_images/7326374-acf306463da9635e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP备考指南之相关事项介绍</title>
      <link href="/2019/04/22/pmp/PMP01/"/>
      <url>/2019/04/22/pmp/PMP01/</url>
      
        <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/7326374-15a6057e82bcb5dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PMP相关事项" title="PMP相关事项"></p><blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎关注个人博客网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><blockquote><p>本文已同步至 <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">GitHub</a>/<a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">Gitee</a>/公众号，感兴趣的同学帮忙点波关注~</p></blockquote><p>PMP是当今IT、通信、建筑、等高新技术行业的热门资格认证，无论是技术升级管理，还是管理者的能力提升，都离不开PMP的理论体系。今天就来介绍下PMP备考前的相关内容。</p><h2 id="PMP认证的报名条件"><a href="#PMP认证的报名条件" class="headerlink" title="PMP认证的报名条件"></a>PMP认证的报名条件</h2><p>1、申请者具有学士学位或同等的大学学历，并且须至少具有4500小时的项目管理相关经历。PMI要求申请者需至少3年以上，具有4500小时的项目管理经历(计算方法：不重叠累积)。仅在申请日之前6年之内的经历有效。</p><p>2、申请者虽不具备学士学位或同等大学学历，但持有中学文凭或同等中学学历证书， 并且至少具有7500小时的项目管理经历(计算方法：不重叠累积)。PMI要求申请者需至少5年以上，具有7500小时的项目管理经历。仅在申请日之前8年之内的经历有效。</p><p>3、具备PMI授权培训机构颁发的35PDU培训证书(必须由PMI或中国外专局授权的培训机构出具)。报考者可以在资格申请后的一年内，申请考试。</p><h2 id="PMP考试时间"><a href="#PMP考试时间" class="headerlink" title="PMP考试时间"></a>PMP考试时间</h2><p>PMP每年有4次的考试机会，分别是 3月30日、6月22日、9月7日、12月7日。<br>而PMP认证考试报名时间一般是在PMP考试前两个半月截止，建议大家提前做好时间计划!</p><h2 id="考试费用"><a href="#考试费用" class="headerlink" title="考试费用"></a>考试费用</h2><p>一、初考：2018年PMP认证考试初考需要交纳3900元人民币。（培训费另算）</p><p>二、重考：未通过PMP考试的考生，建议及时报名参加重考，因为考生只有一年的资格期来通过考试，在资格期内，有2-3次的考试机会。重考者需要交纳重考费。重考费为2500元人民币。（培训费另算）</p><p>注：缴费方式只能使用汇款/转账。</p><h2 id="PMP-考试介绍"><a href="#PMP-考试介绍" class="headerlink" title="PMP 考试介绍"></a>PMP 考试介绍</h2><ul><li><p>它是笔试，200 道选择题，都是单选题，四选一；</p></li><li><p>不做选择，算答错。选了多个，也算错；</p></li><li><p>中英文对照，对于中国考生看中文就可以了，但是有些题的翻译不咋样，所以当读到题 目有些别扭、或者觉得选项与题目都有点不符的时候，应该对照一下英文；</p></li><li><p>200 题里面有 25 题不计分，是 PMI 用来测试本次考试是否太难、或太容易、或者争议 非常大的题目。但是这 25 题并不知道是哪些，随机散乱的分布在试卷中。所以 200 题的 PMP 考试，131 及以上算是及格，我们清晖要求 140 以上。</p></li><li><p>答题时间：9：00～13：00，共计 4 个小时。</p></li></ul><h2 id="PMP-考试试题分布"><a href="#PMP-考试试题分布" class="headerlink" title="PMP 考试试题分布"></a>PMP 考试试题分布</h2><table><thead><tr><th>过程组</th><th>比例</th><th>题目数量</th></tr></thead><tbody><tr><td>启动过程组</td><td>13%</td><td>26 题</td></tr><tr><td>规划过程组</td><td>24%</td><td>48 题</td></tr><tr><td>执行过程组</td><td>30%</td><td>60 题</td></tr><tr><td>监控过程组</td><td>25%</td><td>50 题</td></tr><tr><td>收尾过程组</td><td>8%</td><td>16 题</td></tr></tbody></table><p>1、题目也是随机分布，不按过程组顺序。<br>2、从 2017 年 9 月份的考试开始，PMI 对 PMP 的成绩显示进行了调整，不再用之前的 P\M\B 三个等级来体现成绩，而是以：Needs Improvement（需要提高） \ Below Target（低 于目标） \ Targer（目标水平） \ Above Target（高于目标） 四个标准来分别体现五个过程 组的成绩状态。<br>考题类型：<br>1、直接考输入、工具、输出的题，这类题较少，5 题以内。<br>2、情景题：PM 在管理一个项目，前一个阶段如何„.后一个阶段„客户提出变更，问 PM 下 一步应该怎么办？<br>3、过程描述题：描述了某一处理过程，问这是应用的哪一项技术？项目团队采用的是哪一 种工具？项目经理使用的是哪种风险应对策略？<br>4、计算题：挣值管理、风险管理、三点估算、关键路径时差等等。<br>5、管理常识题：墨菲定律、彼得原理等<br>6、冷僻题：比如 KISS 法则：Keep It Simple and Stupid 简约并不简单。</p><h2 id="PMI-理念"><a href="#PMI-理念" class="headerlink" title="PMI 理念"></a>PMI 理念</h2><p>1 、项目经理是整合者，是在做整合管理。<br>项目经理对项目管理负责，“管理”是你的核心任务，项目经理并不需要亲自去做所有 事情，比如：并不需要亲自写代码、并不需要负责所有风险、并不需要解决所有问题，PMI 讲究团队合作。</p><p>2 、项目经理必须被授权。<br>就像我们做项目首先需要立项，获得项目批准书。没有被授权的项目经理就像没有拿到 “圣旨”，就没有权力调动或使用资源。各个公司可能叫法不同，有的叫立项报告。但是 PMI 统一把项目批准书称为“项目章程”。项目章程的批准就意味着项目经理被授权了。</p><p>3 、项目经理要积极主动，鼓励干系人的参与。<br>项目经理不能简单地服从领导安排，也不能消极拖延工作。</p><p>4 、拒绝镀金，拒绝多此一举。<br>镀金：是项目人员为了“讨好”客户而“画蛇添足”做的项目活动。PMI 觉得镀金的 项目是失败的，反对镀金。比如客户要 PM 去买包烟，PM 买了烟后又私自决定给客户配了 个打火机。这就是镀金了，客户并不需要打火机，也许客户自己有更高级的“ZIPPO”。镀金，是画蛇添足、因为浪费了资源。镀金，PMI 是明令禁止。</p><p>5 、项目团队必须得到尊重、重视、并且要及时沟通，反对免费加班。</p><p>6 、做项目时有两个因素必须考虑：组织过程资产、事业环境因素。<br>组织过程资产：比如，项目做完了，收尾时候把成功经验和失败教训记录在组织过程资 产中，下一个项目启动时要参考组织过程资产。组织过程资产当中，不仅仅包括经验教训， 还有其他，我们后续章节会陆续介绍。事业环境因素：是项目团队无法改变的，比如：公司文化、公司的制度、政治氛围等。</p><h2 id="答题技巧"><a href="#答题技巧" class="headerlink" title="答题技巧"></a>答题技巧</h2><p>1、一定要看清四个选项后，选择一个相对正确的答案。有时候四个选项都没有原则性的错 误，但是要选一个“最”对的.</p><p>2、PMP 考试答题不能完全按照自己的实际工作凭经验判断，美国人的思路跟我们有些差异, 答题要从 PMI 理念的角度出发。</p><p>比如：实际工作中为了提高客户满意度，会赠送一些增值功能，而这些功能在原本约定的范 围中没有的，这就是镀金。但是 PMI 的态度是非常坚决的，反对镀金。</p><p>3、注意区分多余和误导信息，注意题目中问什么，有些题目问：以上都是正确的，除了？</p><p>4、项目经理直接拒绝、和直接服从的肯定要排除，绝对不是答案。项目经理要积极主动。</p><p>5、对于项目团队的管理，要注意人性化管理，如团队成员疲劳，应支持休息，反对加班， 一般来说牺牲团队个人休息、休假、离职等请求的选项都不正确。</p><p>6、一般不选 PMBOK 中没有出现过的陌生词汇，这样太不专业了；</p><p>比如：在月项目状态会上，客户抱怨缺乏与项目进展有关的信息。项目经理应参考下列哪一 份文件？<br>A、进度进展报告<br>B、进度管理计划<br>C、沟通管理计划<br>D、工作绩效报告</p><p>题干说“客户抱怨缺乏与项目进展有关的信息”，凭经验判断答案选 A 进度进展报告。但是 PMBOK 并没有“进度进展报告”这个说法，一定不能选 A，选 A 太不专业了，A 就 是用来打酱油的。<br>正确答案 C ，缺乏信息是因为没有沟通导致的。</p><h2 id="学习方法与建议"><a href="#学习方法与建议" class="headerlink" title="学习方法与建议"></a>学习方法与建议</h2><p>距离考试有接近三个月时间。</p><p>1 、 学习时间<br>模拟考试前：每天 1<del>2 小时复习，模拟考试后：每天 3</del>4 小时。绝大多数考试不过的 原因，是学习时间不够。所以请大家务必坚持每天学习。</p><p>2 、学习方式<br>模拟考试前：看讲义、看 PMBOK、做单元测试题；模拟考试后：看讲义、看 PMBOK、模拟考试题、单元测试。注：输入、工具、输出简称 ITTO。</p><p>3 、学习技巧<br>（1）温故而知新，不仅要多看错题，做完一套题，对的也要重看一遍。因为难免有些题是我们蒙对的，虽然选对了，但是我们并不知道具体原理，为了保证下一次不需要蒙，我们也都要看一遍，保证做过的每一道题，我们都清楚的知道其中的原理，或者同类型的选择方式。<br>（2）要善于总结，对于自己的错题和易混淆题，应该善于对比、总结，自己记录其中的规律。<br>（3）要善于利用碎片化时间进行学习。大家白天上班很忙，晚上也没整块的时间学习，那么就要善于利用上<br>班路上、下班回家路上、中午休息或者晚上睡前的时间多多学习。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-acf306463da9635e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p>]]></content>
      
      
      <categories>
          
          <category> PMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
