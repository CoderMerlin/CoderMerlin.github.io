<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>玩转 IDEA 系列教程——强烈推荐官方中文(汉化)插件！</title>
      <link href="/2020/06/04/idea/idea01/"/>
      <url>/2020/06/04/idea/idea01/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7326374-6ced95eb61b5c7f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="玩转 IDEA 系列教程"></p><blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人博客网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p>IDEA2020.1版本的到来，官方也悄悄更新了IDEA的中文插件。至今为止也有一段时间了，本人也下载使用过，对于英语底子薄弱的同学来说，中文插件还是非常友好的！</p><p>有兴趣的童鞋也可以下载尝尝鲜~</p><p>接下来，我们来介绍如何安装这款插件！</p><h3 id="一、在线安装"><a href="#一、在线安装" class="headerlink" title="一、在线安装"></a>一、在线安装</h3><p>打开设置——&gt;插件  </p><p>输入框<strong>搜索</strong>：<code>Chinese (Simplified) Language Pack</code></p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-83502d2553bef53b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="settings"></p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-865b2992d6e8bf3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="搜索安装"></p><p>之后重启即可使用！</p><h3 id="二、离线安装"><a href="#二、离线安装" class="headerlink" title="二、离线安装"></a>二、离线安装</h3><p>离线下载地址：<a href="https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack-eap" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/13710-chinese-simplified-language-pack-eap</a></p><blockquote><p>注意事项：需要根据自身的IDEA版本号进行相应的选择下载！</p></blockquote><h4 id="下载离线包"><a href="#下载离线包" class="headerlink" title="下载离线包"></a>下载离线包</h4><p><img src="https://upload-images.jianshu.io/upload_images/7326374-2e619f00d788d070.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载地址"></p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-d931e1f8b8cb89a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="查看对应的版本号"></p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-5f306ae6f01494f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="build.png"></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><blockquote><p>安装离线包有两张方法</p></blockquote><p>方式一：</p><p>File -&gt; Settings -&gt; Plugins -&gt; 安装本地插件包</p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-5e6b0d36aaae4838.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地安装"></p><p>方式二：</p><p>直接将插件包托入到IDEA框内即可！</p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-964e7ab9ae57523c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="离线安装方式2"></p><p>之后重启即可使用！</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://upload-images.jianshu.io/upload_images/7326374-77788a7f9f4174f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装完成"></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><p>文章收录至<br>Github: <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCoderMerlin%2Fcoder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2F573059382%2Fcoder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~</p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-0c9d0fbd2c954edb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建-博客搭建完整教程</title>
      <link href="/2020/05/14/BLOG03-HEXO-JC/"/>
      <url>/2020/05/14/BLOG03-HEXO-JC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师！</p></blockquote><blockquote><p>欢迎大家访问我的博客：<a href="https://codermerlin.github.io/" target="_blank" rel="noopener">Coder编程——个人博客</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实早在三年前，刚毕业那会就在网上学着搭建自己的个人博客。后面由于其他原因（主要是<strong>懒</strong>）就没再继续管理。如今又为何重新拾起呢？</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/emoticon/htwyakszb.jpg" alt="后退我要开始装逼啦"></p><p>第一：自己本身从毕业到工作也已经有了三年时间，或多或少有了一些工作经验和感悟。<br>第二：平时有时间的时候，自己也会看看博客，写写文章（划划水）。<br>第三：工作这么久，也要记录一下自己的学习记录，分享给大家。<br>….</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/emoticon/hlbbzdl.jpg" alt="我知道了"></p><p>下面的开始写教程了，这篇教程主要参考：</p><ul><li><a href="https://www.itrhx.com/" target="_blank" rel="noopener">https://www.itrhx.com/</a></li></ul><p>他的教程写的非常详细！本文也主要参考他写的内容，并修改~</p><p>推荐文章： <a href="http://www.cnblogs.com/jhzhu/p/3893297.html" target="_blank" rel="noopener">《我为什么写博客》</a> （By 知明所以）<br>　　　　 　<a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="noopener">《为什么你应该（从现在开始就）写博客》</a> (By 刘未鹏 | Mind Hacks)</p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><h3 id="1-1-Github-Pages"><a href="#1-1-Github-Pages" class="headerlink" title="1.1 Github Pages"></a>1.1 Github Pages</h3><p><strong>Github Pages</strong>可以被认为是用户编写的、托管在github上的静态网页。使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。</p><p>类似Github Pages的</p><ul><li>Gitee Pages</li><li>Gitlab Pages</li><li>Coding</li></ul><p>等等</p><p>后续我也会写文章专门介绍，这几个Pages的搭建过程，欢迎大家关注~</p><h3 id="1-2-Hexo"><a href="#1-2-Hexo" class="headerlink" title="1.2 Hexo"></a>1.2 Hexo</h3><p><strong>Hexo</strong> 是一个快速、简洁且高效的博客框架。<strong>Hexo</strong> 使用 <strong>Markdown</strong>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h2 id="2-环境安装"><a href="#2-环境安装" class="headerlink" title="2. 环境安装"></a>2. 环境安装</h2><h3 id="2-1-安装Node-js"><a href="#2-1-安装Node-js" class="headerlink" title="2.1 安装Node.js"></a>2.1 安装Node.js</h3><p>访问<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>，按需下载相应版本，默认安装可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG01/A02.png" alt="Node"></p><p>更多详细教程：</p><ul><li><a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">https://www.runoob.com/nodejs/nodejs-install-setup.html</a></li><li><a href="https://blog.csdn.net/antma/article/details/86104068" target="_blank" rel="noopener">https://blog.csdn.net/antma/article/details/86104068</a></li></ul><h3 id="2-2-安装Git"><a href="#2-2-安装Git" class="headerlink" title="2.2 安装Git"></a>2.2 安装Git</h3><p>访问<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">官网</a>，按需下载相应版本，默认安装即可。</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG01/A02-1.png" alt="Git官网"></p><p>更多详细教程：</p><ul><li>Win10安装：<a href="https://blog.csdn.net/qq_32786873/article/details/80570783" target="_blank" rel="noopener">https://blog.csdn.net/qq_32786873/article/details/80570783</a></li><li>Mac安装：<a href="https://www.jianshu.com/p/b91f848655af" target="_blank" rel="noopener">https://www.jianshu.com/p/b91f848655af</a></li></ul><h3 id="2-3-检查软件是否安装成功"><a href="#2-3-检查软件是否安装成功" class="headerlink" title="2.3 检查软件是否安装成功"></a>2.3 检查软件是否安装成功</h3><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG01/A04.png" alt="Git"><br>同时按下 Win 键和 R 键打开运行窗口,输入 cmd ，然后输入以下命令，有相应版本信息显示则安装成功，若不正确可以卸载软件重新安装，此外若安装成功，在桌面右键鼠标，可以看到菜单里多了 Git GUI Here 和 Git Bash Here两个选项，第一个是图形界面的Git操作，另一个是命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">$ node -v</span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG01/A03.png" alt="检查版本"></p><p>正确输出版本号，说明安装成功了~</p><h2 id="3-Hexo安装"><a href="#3-Hexo安装" class="headerlink" title="3. Hexo安装"></a>3. Hexo安装</h2><p>正在编写。。。</p>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建-设置标签/分类/归档相关页面</title>
      <link href="/2020/05/12/BLOG02-HEXO-BQFLGD/"/>
      <url>/2020/05/12/BLOG02-HEXO-BQFLGD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近晚上有时间就忙着倒腾自己的博客网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p><p>网站还在建设当中，我会慢慢分享自己的搭建博客的过程和遇到的问题，在这里与大家一起分享！</p><h3 id="设置标签页面"><a href="#设置标签页面" class="headerlink" title="设置标签页面"></a>设置标签页面</h3><p>主题的 _config.yml 文件中，找到如下配置<code>menu_desktop</code> 或者 <code>menu_mobile</code>。(注意：填写的路径要对应上)</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BOLG03/04.png" alt="配置项"></p><p>在<code>\source\tags</code> 中新建index.md。写入以下内容即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: tag</span><br><span class="line">index: true</span><br><span class="line">title: 所有标签</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>在需要发布的文章同样注意加入tags。举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Java学习路线整理</span><br><span class="line">updated: 2020-03-19 00:34:14</span><br><span class="line">date: 2020-03-19 00:34:14</span><br><span class="line">categories: </span><br><span class="line">  - [Java]</span><br><span class="line">  - [面试]</span><br><span class="line">tags:</span><br><span class="line">  - [Java]</span><br><span class="line">  - [面试]</span><br><span class="line">  </span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>效果如图：<br><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BOLG03/02.png" alt="标签图"></p><h3 id="设置分类页面"><a href="#设置分类页面" class="headerlink" title="设置分类页面"></a>设置分类页面</h3><p>主题的 _config.yml 文件中，找到如下配置<code>menu_desktop</code> 或者 <code>menu_mobile</code>。(注意：填写的路径要对应上)</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BOLG03/04.png" alt="配置项"></p><p>在<code>\source\categories</code> 中新建index.md。写入以下内容即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: category</span><br><span class="line">title: 所有分类</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>在需要发布的文章同样注意加入tags。举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Java学习路线整理</span><br><span class="line">updated: 2020-03-19 00:34:14</span><br><span class="line">date: 2020-03-19 00:34:14</span><br><span class="line">categories: </span><br><span class="line">  - [Java]</span><br><span class="line">  - [面试]</span><br><span class="line">tags:</span><br><span class="line">  - [Java]</span><br><span class="line">  - [面试]</span><br><span class="line">  </span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>效果如图：<br><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BOLG03/01.png" alt="分类图"></p><h3 id="设置归档页面"><a href="#设置归档页面" class="headerlink" title="设置归档页面"></a>设置归档页面</h3><p><strong>归档页面不要添加任何文件！</strong><br><strong>归档页面不要添加任何文件！</strong><br><strong>归档页面不要添加任何文件！</strong><br>重要的事说三遍！</p><p>只需要在主题的 _config.yml 文件中，找到如下配置<code>menu_desktop</code> 或者 <code>menu_mobile</code>。(注意：填写的路径要对应上), 填写<code>archives/</code>即可。</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BOLG03/04.png" alt="配置项"></p><p>效果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BOLG03/03.png" alt="归档图"></p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTg3NzYyOA==&mid=2247484326&idx=1&sn=0f11d4a0d23ac377a83f9fba1d4a67d4&chksm=96e672b5a191fba32b18844de26ba6dc2060a8e16b184d73c6f9dd45ca0498062eaa9273d86c&token=475512204&lang=zh_CN#rd?_blank" target="_blank" rel="noopener">[博客搭建] 增加百度统计功能</a></p><p><a href="https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21" target="_blank" rel="noopener">ProcessOn是一个在线作图工具的聚合平台~</a></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/coder-programming-wechat.webp.jpg" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建-增加百度统计功能</title>
      <link href="/2020/05/12/BLOG01-HEXO-BDTJ/"/>
      <url>/2020/05/12/BLOG01-HEXO-BDTJ/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近晚上有时间就忙着倒腾自己的博客网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p><p>网站还在建设当中，我会慢慢分享自己的搭建博客的过程和遇到的问题，在这里与大家一起分享！</p><p>百度统计是百度推出的一款免费的专业网站流量分析工具，能够告诉用户访客是如何找到并浏览用户的网站，在网站上做了些什么，非常有趣，接下来我们把百度统计添加到自己博客当中</p><p>访问<a href="https://tongji.baidu.com/" target="_blank" rel="noopener">百度统计首页</a>，注册一个账号后登陆，添加你的博客网站</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG02BDTJ/01.png" alt="01"></p><p>点击<strong>增加网站</strong>,填写个人网站的信息。</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG02BDTJ/02.png" alt="02"></p><p>接着点击代码获取，复制该代码<br><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG02BDTJ/03.png" alt="03"></p><p>然后到目录<code>\themes\hexo-theme-material-x\layout\_partial\head.ejs</code>，里面粘贴你刚刚复制的代码。<br>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (config.baidu_analytics_key) &#123; %&gt;</span><br><span class="line">    &lt;!-- ba --&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    var _hmt &#x3D; _hmt || [];</span><br><span class="line">    (function() &#123;</span><br><span class="line">      var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">      hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?&lt;%&#x3D; config.baidu_analytics_key %&gt;&quot;;</span><br><span class="line">      var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">      s.parentNode.insertBefore(hm, s);</span><br><span class="line">    &#125;)();</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>修改博客根目录下的 _config.yml 文件(注意：不是主题下的_config.yml)，将你的key填写进去：</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG02BDTJ/05.png" alt="05"></p><p>所有操作完成后可以在百度统计管理页面检查代码是否安装成功，如果代码安装正确，一般20分钟后，可以查看网站分析数据</p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG02BDTJ/06.png" alt="06"></p><p><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/BLOG02BDTJ/07.png" alt="07"></p><p>另外推荐：<a href="https://web.umeng.com/main.php?c=user&a=index" target="_blank" rel="noopener">友盟</a>，2010年4月在北京成立，安全、可靠、公正、第三方的网站流量统计分析系统</p><p>参考：<br><a href="https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/" target="_blank" rel="noopener">https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/</a></p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21" target="_blank" rel="noopener">ProcessOn是一个在线作图工具的聚合平台~</a></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://cdn.jsdelivr.net/gh/CoderMerlin/blog-image/images/coder-programming-wechat.webp.jpg" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 百度统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习路线整理</title>
      <link href="/2020/03/19/java/"/>
      <url>/2020/03/19/java/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#java">Java</a><ul><li><a href="#基础">基础</a></li><li><a href="#并发">并发</a></li><li><a href="#jvm">JVM</a></li><li><a href="#java8-新特性">Java8 新特性</a></li><li><a href="#代码优化">代码优化</a></li></ul></li><li><a href="#网络">网络</a></li><li><a href="#操作系统">操作系统</a></li><li><a href="#数据结构">数据结构</a></li><li><a href="#算法">算法</a><ul><li><a href="#入门">入门</a></li><li><a href="#经典">经典</a></li><li><a href="#面试">面试</a></li></ul></li><li><a href="#数据库">数据库</a></li><li><a href="#系统设计">系统设计</a><ul><li><a href="#设计模式">设计模式</a></li><li><a href="#常用框架">常用框架</a><ul><li><a href="#springspringboot">Spring/SpringBoot</a></li><li><a href="#netty">Netty</a></li></ul></li><li><a href="#分布式">分布式</a></li><li><a href="#网站架构">网站架构</a></li><li><a href="#软件底层">软件底层</a></li><li><a href="#其他">其他</a></li></ul></li><li><a href="#其他-1">其他</a></li></ul><!-- /TOC --><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li><strong><a href="https://book.douban.com/subject/2000732/" target="_blank" rel="noopener">《Head First Java》</a></strong> ：  可以说是我的 Java 启蒙书籍了，特别适合新手读当然也适合我们用来温故 Java 知识点。</li><li><strong><a href="https://book.douban.com/subject/25762168/" target="_blank" rel="noopener">《Java 核心技术卷 1+卷 2》</a></strong>: 很棒的两本书，建议有点 Java 基础之后再读，介绍的还是比较深入的，非常推荐。这两本书我一般也会用来巩固知识点或者当做工具书参考，是两本适合放在自己身边的好书。</li><li><strong><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">《Java 编程思想 (第 4 版)》</a></strong>（推荐，豆瓣评分 9.1，3.2K+人评价）：大部分人称之为Java领域的圣经，但我不推荐初学者阅读，有点劝退的味道。稍微有点基础后阅读更好。</li><li><strong><a href="https://book.douban.com/subject/26259017/" target="_blank" rel="noopener">《JAVA 网络编程 第 4 版》</a></strong>：  可以系统的学习一下网络的一些概念以及网络编程在 Java 中的使用。</li><li><strong><a href="https://book.douban.com/subject/26740520/" target="_blank" rel="noopener">《Java性能权威指南》</a></strong>：O’Reilly 家族书，性能调优的入门书，我个人觉得性能调优是每个 Java 从业者必备知识，这本书的缺点就是太老了，但是这本书可以作为一个实战书，尤其是 JVM 调优！不适合初学者。前置书籍：《深入理解 Java 虚拟机》</li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li><strong><a href="https://book.douban.com/subject/30351286/" target="_blank" rel="noopener">《Java 并发编程之美》</a></strong> ：<strong>我觉得这本书还是非常适合我们用来学习 Java 多线程的。这本书的讲解非常通俗易懂，作者从并发编程基础到实战都是信手拈来。</strong> 另外，这本书的作者加多自身也会经常在网上发布各种技术文章。我觉得这本书也是加多大佬这么多年在多线程领域的沉淀所得的结果吧！他书中的内容基本都是结合代码讲解，非常有说服力！</li><li><strong><a href="https://book.douban.com/subject/26663605/" target="_blank" rel="noopener">《实战 Java 高并发程序设计》</a></strong>： 这个是我第二本要推荐的书籍，比较适合作为多线程入门/进阶书籍来看。这本书内容同样是理论结合实战，对于每个知识点的讲解也比较通俗易懂，整体结构也比较清。</li><li><strong><a href="https://github.com/RedSpider1/concurrent" target="_blank" rel="noopener">《深入浅出 Java 多线程》</a></strong>：这本书是几位大厂（如阿里）的大佬开源的，Github 地址：<a href="https://github.com/RedSpider1/concurrent" target="_blank" rel="noopener">https://github.com/RedSpider1/concurrent</a>几位作者为了写好《深入浅出 Java 多线程》这本书阅读了大量的 Java 多线程方面的书籍和博客，然后再加上他们的经验总结、Demo 实例、源码解析，最终才形成了这本书。这本书的质量也是非常过硬！给作者们点个赞！这本书有统一的排版规则和语言风格、清晰的表达方式和逻辑。并且每篇文章初稿写完后，作者们就会互相审校，合并到主分支时所有成员会再次审校，最后再通篇修订了三遍。</li><li><strong>《Java 并发编程的艺术》</strong> ：这本书不是很适合作为 Java 多线程入门书籍，需要具备一定的 JVM 基础，有些东西讲的还是挺深入的。另外，就我自己阅读这本书的感觉来说，我觉得这本书的章节规划有点杂乱，但是，具体到某个知识点又很棒！这可能也和这本书由三名作者共同编写完成有关系吧！</li><li>……</li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li><strong><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解 Java 虚拟机（第 3 版）》</a>）</strong>：必读！必读！必读！神书，建议多刷几篇。里面不光有丰富地JVM理论知识，还有JVM实战案例！必读！</li><li><strong><a href="https://book.douban.com/subject/26354292/" target="_blank" rel="noopener">《实战 JAVA 虚拟机》</a></strong>：作为入门的了解 Java 虚拟机的知识还是不错的。</li></ul><h3 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8 新特性"></a>Java8 新特性</h3><ul><li><strong><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="noopener">《Java 8 实战》</a></strong>：面向 Java 8 的技能升级，包括 Lambdas、流和函数式编程特性。实战系列的一贯风格让自己快速上手应用起来。Java 8 支持的 Lambda 是精简表达在语法上提供的支持。Java 8 提供了 Stream，学习和使用可以建立流式编程的认知。</li><li><strong><a href="https://book.douban.com/subject/26556574/" target="_blank" rel="noopener">《Java 8 编程参考官方教程》</a></strong>：建议当做工具书来用！哪里不会翻哪里！</li></ul><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ul><li><strong><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构_改善既有代码的设计》</a></strong>：豆瓣 9.1 分，重构书籍的开山鼻祖。</li><li><strong><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">《Effective java 》</a></strong>：本书介绍了在 Java 编程中很多极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。这篇文章能够非常实际地帮助你写出更加清晰、健壮和高效的代码。本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。</li><li><strong><a href="https://book.douban.com/subject/5442024/" target="_blank" rel="noopener">《代码整洁之道》</a></strong>：虽然是用 Java 语言作为例子，全篇都是在阐述 Java 面向对象的思想，但是其中大部分内容其它语言也能应用到。</li><li><strong>阿里巴巴 Java 开发手册</strong> ：<a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">https://github.com/alibaba/p3c</a></li><li><strong>Google Java 编程风格指南：</strong> <a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">http://www.hawstein.com/posts/google-java-style.html</a></li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li><strong><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解 HTTP》</a></strong>： 讲漫画一样的讲 HTTP，很有意思，不会觉得枯燥，大概也涵盖也 HTTP 常见的知识点。因为篇幅问题，内容可能不太全面。不过，如果不是专门做网络方向研究的小伙伴想研究 HTTP 相关知识的话，读这本书的话应该来说就差不多了。</li><li><strong><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">《HTTP 权威指南》</a></strong>:如果要全面了解 HTTP 非此书不可！</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li><strong><a href="https://book.douban.com/subject/4889838/" target="_blank" rel="noopener">《鸟哥的 Linux 私房菜》</a></strong>：本书是最具知名度的 Linux 入门书《鸟哥的 Linux 私房菜基础学习篇》的最新版，全面而详细地介绍了 Linux 操作系统。</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><strong><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="noopener">《大话数据结构》</a></strong>：入门类型的书籍，读起来比较浅显易懂，适合没有数据结构基础或者说数据结构没学好的小伙伴用来入门数据结构。</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><ul><li><strong><a href="https://book.douban.com/subject/30357170/" target="_blank" rel="noopener">《我的第一本算法书》</a> （豆瓣评分 7.1，0.2K+人评价）</strong> 一本不那么“专业”的算法书籍。和下面两本推荐的算法书籍都是比较通俗易懂，“不那么深入”的算法书籍。我个人非常推荐，配图和讲解都非常不错！</li><li><strong><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">《算法图解》</a>（豆瓣评分 8.4，1.5K+人评价）</strong> ：入门类型的书籍，读起来比较浅显易懂，非常适合没有算法基础或者说算法没学好的小伙伴用来入门。示例丰富，图文并茂，以让人容易理解的方式阐释了算法.读起来比较快，内容不枯燥！</li><li><strong><a href="https://book.douban.com/subject/25894685/" target="_blank" rel="noopener">《啊哈!算法》</a> （豆瓣评分 7.7，0.5K+人评价）</strong> ：和《算法图解》类似的算法趣味入门书籍。</li></ul><h3 id="经典"><a href="#经典" class="headerlink" title="经典"></a>经典</h3><blockquote><p>下面这些书籍都是经典中的经典，但是阅读起来难度也比较大，不做太多阐述，神书就完事了！推荐先看 《算法》，然后再选下面的书籍进行进一步阅读。不需要都看，找一本好好看或者找某本书的某一个章节知识点好好看。</p></blockquote><ul><li><strong><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">《算法 第四版》</a>（豆瓣评分 9.3，0.4K+人评价）：</strong> 我在大二的时候被我们的一个老师强烈安利过！自己也在当时购买了一本放在宿舍，到离开大学的时候自己大概看了一半多一点。因为内容实在太多了！另外，这本书还提供了详细的Java代码，非常适合学习 Java 的朋友来看，可以说是 Java 程序员的必备书籍之一了。再来介绍一下这本书籍吧！这本书籍算的上是算法领域经典的参考书，全面介绍了关于算法和数据结构的必备知识，并特别针对排序、搜索、图处理和字符串处理进行了论述。</li><li><strong><a href="https://book.douban.com/subject/3227098/" target="_blank" rel="noopener">编程珠玑</a>（豆瓣评分 9.1，2K+人评价）</strong> ：经典名著，被无数读者强烈推荐的书籍，几乎是顶级程序员必看的书籍之一了。这本书的作者也非常厉害，Java之父 James Gosling 就是他的学生。很多人都说这本书不是教你具体的算法，而是教你一种编程的思考方式。这种思考方式不仅仅在编程领域适用，在其他同样适用。</li><li><strong><a href="https://book.douban.com/subject/4048566/" target="_blank" rel="noopener">《算法设计手册》</a>（豆瓣评分9.1 ， 45人评价）</strong> :被 <a href="https://teachyourselfcs.com/" target="_blank" rel="noopener">Teach Yourself Computer Science</a> 强烈推荐的一本算法书籍。</li><li><strong><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">《算法导论》</a> （豆瓣评分 9.2，0.4K+人评价）</strong></li><li><strong><a href="https://book.douban.com/subject/1130500/" target="_blank" rel="noopener">《计算机程序设计艺术（第1卷）》</a>（豆瓣评分 9.4，0.4K+人评价）</strong> </li></ul><h3 id="面试-1"><a href="#面试-1" class="headerlink" title="面试"></a>面试</h3><ol><li><strong><a href="https://book.douban.com/subject/6966465/" target="_blank" rel="noopener">《剑指Offer》</a>（豆瓣评分 8.3，0.7K+人评价）</strong>这本面试宝典上面涵盖了很多经典的算法面试题，如果你要准备大厂面试的话一定不要错过这本书。《剑指Offer》 对应的算法编程题部分的开源项目解析：<a href="https://github.com/gatieme/CodingInterviews" target="_blank" rel="noopener">CodingInterviews</a></li><li><strong><a href="https://book.douban.com/subject/30422021/" target="_blank" rel="noopener">程序员代码面试指南：IT名企算法与数据结构题目最优解（第2版）</a> （豆瓣评分 8.7，0.2K+人评价）</strong> ：题目相比于《剑指 offer》 来说要难很多，题目涵盖面相比于《剑指 offer》也更加全面。全书一共有将近300道真实出现过的经典代码面试题。</li><li><strong><a href="https://book.douban.com/subject/3004255/" target="_blank" rel="noopener">编程之美</a>（豆瓣评分 8.4，3K+人评价）</strong>：这本书收集了约60道算法和程序设计题目，这些题目大部分在近年的笔试、面试中出现过，或者是被微软员工热烈讨论过。作者试图从书中各种有趣的问题出发，引导读者发现问题，分析问题，解决问题，寻找更优的解法。</li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><strong>MySQL:</strong></p><ul><li><strong><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">《高性能 MySQL》</a></strong>：这本书不用多说了把！MySQL 领域的经典之作，拥有广泛的影响力。不但适合数据库管理员（dba）阅读，也适合开发人员参考学习。不管是数据库新手还是专家，相信都能从本书有所收获。如果你的时间不够的话，第5章关于索引的内容和第6章关于查询的内容是必读的！</li><li><a href="https://book.douban.com/subject/24708143/" target="_blank" rel="noopener">《MySQL 技术内幕-InnoDB 存储引擎》</a>（推荐，豆瓣评分 8.7）：了解 InnoDB 存储引擎底层原理必备的一本书，比较深入。</li></ul><p><strong>Redis:</strong></p><ul><li><strong><a href="https://book.douban.com/subject/26612779/" target="_blank" rel="noopener">《Redis 实战》</a></strong>：如果你想了解 Redis 的一些概念性知识的话，这本书真的非常不错。</li><li><strong><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis 设计与实现》</a></strong>：也还行吧！</li></ul><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li><strong><a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">《设计模式 : 可复用面向对象软件的基础》</a></strong> ：设计模式的经典！</li><li><strong><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式（中文版）》</a></strong> ：相当赞的一本设计模式入门书籍。用实际的编程案例讲解算法设计中会遇到的各种问题和需求变更（对的，连需求变更都考虑到了！），并以此逐步推导出良好的设计模式解决办法。</li><li><strong><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></strong> ：本书通篇都是以情景对话的形式，用多个小故事或编程示例来组织讲解GOF(即《设计模式 : 可复用面向对象软件的基础》这本书))，但是不像《设计模式 : 可复用面向对象软件的基础》难懂。但是设计模式只看书是不够的，还是需要在实际项目中运用，在实战中体会。</li></ul><h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><h4 id="Spring-SpringBoot"><a href="#Spring-SpringBoot" class="headerlink" title="Spring/SpringBoot"></a>Spring/SpringBoot</h4><ul><li><strong><a href="https://book.douban.com/subject/26767354/" target="_blank" rel="noopener">《Spring 实战（第 4 版）》</a></strong> ：不建议当做入门书籍读，入门的话可以找点国人的书或者视频看。这本定位就相当于是关于 Spring 的新华字典，只有一些基本概念的介绍和示例，涵盖了 Spring 的各个方面，但都不够深入。就像作者在最后一页写的那样：“学习 Spring，这才刚刚开始”。</li><li><strong>《<a href="https://book.douban.com/subject/30452948/" target="_blank" rel="noopener">Spring源码深度解析 第2版</a>》</strong>  ：读Spring源码必备的一本书籍。市面上关于Spring源码分析的书籍太少了。</li><li><strong><a href="https://book.douban.com/subject/30452637/" target="_blank" rel="noopener">《Spring 5高级编程（第5版）》</a></strong> ：推荐阅读，对于Spring5的新特性介绍的很好！不过内容比较多，可以作为工具书参考。</li><li><strong><a href="https://read.douban.com/ebook/58113975/?dcs=subject-rec&dcm=douban&dct=26767354" target="_blank" rel="noopener">《精通Spring4.x企业应用开发实战》</a></strong> :通过实战讲解，比较适合作为Spring入门书籍来看。</li><li><strong><a href="https://book.douban.com/subject/26652876/" target="_blank" rel="noopener">《Spring入门经典》</a></strong> ：适合入门，也有很多示例！</li><li><strong><a href="https://book.douban.com/subject/34894533/" target="_blank" rel="noopener">《Spring Boot实战派》</a></strong> ：这本书使用的Spring Boot 2.0+的版本，还算比较新。整本书采用“知识点+实例”的形式编写。本书通过“58个基于知识的实例+2个综合性的项目”，深入地讲解Spring Boot的技术原理、知识点和具体应用；把晦涩难懂的理论用实例展现出来，使得读者对知识的理解变得非常容易，同时也立即学会如何使用它。说实话，我还是比较推荐这本书的。</li><li><strong><a href="https://book.douban.com/subject/33390560/" target="_blank" rel="noopener">《Spring Boot编程思想（核心篇）》</a></strong> ：SpringBoot深入书，不适合初学者。书尤其的厚，这本书的缺点是书的很多知识点的讲解过于啰嗦和拖沓，优点是书中对SpringBoot内部原理讲解很清楚。</li></ul><h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><ul><li><strong><a href="https://book.douban.com/subject/30381214/" target="_blank" rel="noopener">《Netty进阶之路：跟着案例学Netty》</a></strong> : 这本书的优点是有不少实际的案例的讲解，通过案例来学习是很不错的！</li><li><strong><a href="https://waylau.gitbooks.io/netty-4-user-guide/content/" target="_blank" rel="noopener">《Netty 4.x 用户指南》</a></strong> ：《Netty 4.x 用户指南》中文翻译（包含了官方文档以及其他文章）。</li><li><strong><a href="https://juejin.im/book/5b4bc28bf265da0f60130116?referrer=59fbb2daf265da4319559f3a" target="_blank" rel="noopener">《Netty 入门与实战：仿写微信 IM 即时通讯系统》</a></strong>   ：基于 Netty 框架实现 IM 核心系统，带你深入学习 Netty 网络编程核心知识</li><li><strong><a href="https://book.douban.com/subject/27038538/" target="_blank" rel="noopener">《Netty 实战》</a></strong> ：可以作为工具书参考！</li></ul><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ul><li><strong><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="noopener">《从 Paxos 到 Zookeeper》</a></strong>：简要介绍几种典型的分布式一致性协议，以及解决分布式一致性问题的思路，其中重点讲解了 Paxos 和 ZAB 协议。同时，本书深入介绍了分布式一致性问题的工业解决方案——ZooKeeper，并着重向读者展示这一分布式协调框架的使用方法、内部实现及运维技巧，旨在帮助读者全面了解 ZooKeeper，并更好地使用和运维 ZooKeeper。</li><li><strong><a href="https://book.douban.com/subject/27591386/" target="_blank" rel="noopener">《RabbitMQ 实战指南》</a></strong>：《RabbitMQ 实战指南》从消息中间件的概念和 RabbitMQ 的历史切入，主要阐述 RabbitMQ 的安装、使用、配置、管理、运维、原理、扩展等方面的细节。如果你想浅尝 RabbitMQ 的使用，这本书是你最好的选择；如果你想深入 RabbitMQ 的原理，这本书也是你最好的选择；总之，如果你想玩转 RabbitMQ，这本书一定是最值得看的书之一</li><li><strong><a href="https://book.douban.com/subject/27025912/" target="_blank" rel="noopener">《Spring Cloud 微服务实战》</a></strong>：从时下流行的微服务架构概念出发，详细介绍了 Spring Cloud 针对微服务架构中几大核心要素的解决方案和基础组件。对于各个组件的介绍，《Spring Cloud 微服务实战》主要以示例与源码结合的方式来帮助读者更好地理解这些组件的使用方法以及运行原理。同时，在介绍的过程中，还包含了作者在实践中所遇到的一些问题和解决思路，可供读者在实践中作为参考。</li></ul><h3 id="网站架构"><a href="#网站架构" class="headerlink" title="网站架构"></a>网站架构</h3><ul><li><strong><a href="https://book.douban.com/subject/25723064/" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析+李智慧》</a></strong>:这本书我读过，基本不需要你有什么基础啊~读起来特别轻松，但是却可以学到很多东西，非常推荐了。另外我写过这本书的思维导图，关注我的微信公众号：“Java 面试通关手册”回复“大型网站技术架构”即可领取思维导图。</li><li><strong><a href="https://book.douban.com/subject/26999243/" target="_blank" rel="noopener">《亿级流量网站架构核心技术》</a></strong>：一书总结并梳理了亿级流量网站高可用和高并发原则，通过实例详细介绍了如何落地这些原则。本书分为四部分：概述、高可用原则、高并发原则、案例实战。从负载均衡、限流、降级、隔离、超时与重试、回滚机制、压测与预案、缓存、池化、异步化、扩容、队列等多方面详细介绍了亿级流量网站的架构核心技术，让读者看后能快速运用到实践项目中。</li></ul><h3 id="软件底层"><a href="#软件底层" class="headerlink" title="软件底层"></a>软件底层</h3><ul><li><strong><a href="https://book.douban.com/subject/10426640/" target="_blank" rel="noopener">《深入剖析 Tomcat》</a></strong>：本书深入剖析 Tomcat 4 和 Tomcat 5 中的每个组件，并揭示其内部工作原理。通过学习本书，你将可以自行开发 Tomcat 组件，或者扩展已有的组件。 读完这本书，基本可以摆脱背诵面试题的尴尬。</li><li><strong><a href="https://book.douban.com/subject/26745255/" target="_blank" rel="noopener">《深入理解 Nginx（第 2 版）》</a></strong>：作者讲的非常细致，注释都写的都很工整，对于 Nginx 的开发人员非常有帮助。优点是细致，缺点是过于细致，到处都是代码片段，缺少一些抽象。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong><a href="https://book.douban.com/subject/25953851/" target="_blank" rel="noopener">《深入分析 Java Web 技术内幕》</a></strong>：  感觉还行，涉及的东西也蛮多。</li></ul><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul><li><p><strong><a href="https://read.douban.com/ebook/387525/?dcs=subject-rec&dcm=douban&dct=2243615" target="_blank" rel="noopener">《黑客与画家》</a></strong>：这本书是硅谷创业之父，Y Combinator 创始人 Paul Graham 的文集。之所以叫这个名字，是因为作者认为黑客（并非负面的那个意思）与画家有着极大的相似性，他们都是在创造，而不是完成某个任务。</p></li><li><p><strong><a href="https://book.douban.com/subject/26265544/" target="_blank" rel="noopener">《图解密码技术》</a></strong>：本书以<strong>图配文</strong>的形式，第一部分讲述了密码技术的历史沿革、对称密码、分组密码模式（包括ECB、CBC、CFB、OFB、CTR）、公钥、混合密码系统。第二部分重点介绍了认证方面的内容，涉及单向散列函数、消息认证码、数字签名、证书等。第三部分讲述了密钥、随机数、PGP、SSL/TLS 以及密码技术在现实生活中的应用。关键字：JWT 前置知识、区块链密码技术前置知识。属于密码知识入门书籍。</p></li><li><p>《人月神话》 、《程序开发心理学》 、《程序员修炼之道，从小工道专家》、 《高效程序员的45个习惯，敏捷开发修炼之道》 、《高效能程序员的修炼》 、《软技能，代码之外的生存之道》  、《程序员的职业素养》 、《程序员的思维修炼》</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享一些摘抄的优美句子~</title>
      <link href="/2020/01/14/good/"/>
      <url>/2020/01/14/good/</url>
      
        <content type="html"><![CDATA[<h5 id="1-有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了。有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了。"><a href="#1-有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了。有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了。" class="headerlink" title="1.有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了。有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了。"></a>1.有一个夜晚我烧毁了所有的记忆，从此我的梦就透明了。有一个早晨我扔掉了所有的昨天，从此我的脚步就轻盈了。</h5><p>——泰戈尔﻿﻿</p><h5 id="2-我是你路上最后一个过客，最后一个春天，最后一场雪，最后一次求生的战争"><a href="#2-我是你路上最后一个过客，最后一个春天，最后一场雪，最后一次求生的战争" class="headerlink" title="2.我是你路上最后一个过客，最后一个春天，最后一场雪，最后一次求生的战争"></a>2.我是你路上最后一个过客，最后一个春天，最后一场雪，最后一次求生的战争</h5><p>——保尔 艾吕雅﻿﻿</p><h5 id="3-虽然我已经十年没见过他，但我知道我会永远想念他。后来我再也没有交过像十二岁时那帮人一样的好朋友。也许，每个人都是这样"><a href="#3-虽然我已经十年没见过他，但我知道我会永远想念他。后来我再也没有交过像十二岁时那帮人一样的好朋友。也许，每个人都是这样" class="headerlink" title="3.虽然我已经十年没见过他，但我知道我会永远想念他。后来我再也没有交过像十二岁时那帮人一样的好朋友。也许，每个人都是这样"></a>3.虽然我已经十年没见过他，但我知道我会永远想念他。后来我再也没有交过像十二岁时那帮人一样的好朋友。也许，每个人都是这样</h5><p>——罗伯莱纳﻿﻿</p><h5 id="4-在喧闹、混杂的生活中你应该与你的内心和平相处。尽管这世上有很多假冒和欺骗，有很多单调乏味的工作和众多破灭的梦幻，他仍然是一个美好的世界。记住：你应该努力的追求幸福。"><a href="#4-在喧闹、混杂的生活中你应该与你的内心和平相处。尽管这世上有很多假冒和欺骗，有很多单调乏味的工作和众多破灭的梦幻，他仍然是一个美好的世界。记住：你应该努力的追求幸福。" class="headerlink" title="4.在喧闹、混杂的生活中你应该与你的内心和平相处。尽管这世上有很多假冒和欺骗，有很多单调乏味的工作和众多破灭的梦幻，他仍然是一个美好的世界。记住：你应该努力的追求幸福。"></a>4.在喧闹、混杂的生活中你应该与你的内心和平相处。尽管这世上有很多假冒和欺骗，有很多单调乏味的工作和众多破灭的梦幻，他仍然是一个美好的世界。记住：你应该努力的追求幸福。</h5><p>（此文于1692年镌于巴尔的摩圣保罗教堂）﻿﻿</p><h5 id="5-我开始真正爱自己，我不再继续沉溺于过去，也不再为明天而忧虑，现在的我只活在一切在发生的当下，今天我活在此时此地，如此日复一日，这就叫”完美”。"><a href="#5-我开始真正爱自己，我不再继续沉溺于过去，也不再为明天而忧虑，现在的我只活在一切在发生的当下，今天我活在此时此地，如此日复一日，这就叫”完美”。" class="headerlink" title="5.我开始真正爱自己，我不再继续沉溺于过去，也不再为明天而忧虑，现在的我只活在一切在发生的当下，今天我活在此时此地，如此日复一日，这就叫”完美”。"></a>5.我开始真正爱自己，我不再继续沉溺于过去，也不再为明天而忧虑，现在的我只活在一切在发生的当下，今天我活在此时此地，如此日复一日，这就叫”完美”。</h5><p>——《当我开始爱自己》﻿﻿</p><h5 id="6-如果有一天你不再寻找爱情，只是去爱；你不再渴望成功，只是去做；你不再追逐成长，只是去修；一切才真正开始"><a href="#6-如果有一天你不再寻找爱情，只是去爱；你不再渴望成功，只是去做；你不再追逐成长，只是去修；一切才真正开始" class="headerlink" title="6.如果有一天你不再寻找爱情，只是去爱；你不再渴望成功，只是去做；你不再追逐成长，只是去修；一切才真正开始"></a>6.如果有一天你不再寻找爱情，只是去爱；你不再渴望成功，只是去做；你不再追逐成长，只是去修；一切才真正开始</h5><p>——纪伯伦﻿﻿</p><h5 id="7-我原谅了从前的自己，就像谅解了一个野心勃勃的傻逼，体恤了一个笨手笨脚的勇士，释怀了一个难以启齿的秘密。"><a href="#7-我原谅了从前的自己，就像谅解了一个野心勃勃的傻逼，体恤了一个笨手笨脚的勇士，释怀了一个难以启齿的秘密。" class="headerlink" title="7.我原谅了从前的自己，就像谅解了一个野心勃勃的傻逼，体恤了一个笨手笨脚的勇士，释怀了一个难以启齿的秘密。﻿﻿"></a>7.我原谅了从前的自己，就像谅解了一个野心勃勃的傻逼，体恤了一个笨手笨脚的勇士，释怀了一个难以启齿的秘密。﻿﻿</h5><h5 id="8-原来可以这样爱你，什么也可以说，什么也可以不说。让我采一束月光吧！插在今夜我寂寥的窗前。过了今夜，我不会再有力气为你写诗和流泪。"><a href="#8-原来可以这样爱你，什么也可以说，什么也可以不说。让我采一束月光吧！插在今夜我寂寥的窗前。过了今夜，我不会再有力气为你写诗和流泪。" class="headerlink" title="8.原来可以这样爱你，什么也可以说，什么也可以不说。让我采一束月光吧！插在今夜我寂寥的窗前。过了今夜，我不会再有力气为你写诗和流泪。"></a>8.原来可以这样爱你，什么也可以说，什么也可以不说。让我采一束月光吧！插在今夜我寂寥的窗前。过了今夜，我不会再有力气为你写诗和流泪。</h5><p>——海烟﻿﻿</p><h5 id="9-我不知该如何珍藏明里这份温暖，也不知该将她的灵魂带往何处。我清楚地明白，我们无法保证将来能够永远在一起。横亘在我们面前的是那沉重的人生于漫长时间，让人不由得产生一种无力感"><a href="#9-我不知该如何珍藏明里这份温暖，也不知该将她的灵魂带往何处。我清楚地明白，我们无法保证将来能够永远在一起。横亘在我们面前的是那沉重的人生于漫长时间，让人不由得产生一种无力感" class="headerlink" title="9.我不知该如何珍藏明里这份温暖，也不知该将她的灵魂带往何处。我清楚地明白，我们无法保证将来能够永远在一起。横亘在我们面前的是那沉重的人生于漫长时间，让人不由得产生一种无力感"></a>9.我不知该如何珍藏明里这份温暖，也不知该将她的灵魂带往何处。我清楚地明白，我们无法保证将来能够永远在一起。横亘在我们面前的是那沉重的人生于漫长时间，让人不由得产生一种无力感</h5><p>——新海诚﻿﻿</p><h5 id="10-此刻有谁在世上某处哭，无缘无故在世上哭，在哭我。此刻有谁在夜间某处笑，无缘无故的在夜间笑，在笑我。此刻有谁在世上某处走，无缘无故的在世上走，走向我。此刻有谁在世上某处死，无缘无故在世上死，望着我。"><a href="#10-此刻有谁在世上某处哭，无缘无故在世上哭，在哭我。此刻有谁在夜间某处笑，无缘无故的在夜间笑，在笑我。此刻有谁在世上某处走，无缘无故的在世上走，走向我。此刻有谁在世上某处死，无缘无故在世上死，望着我。" class="headerlink" title="10.此刻有谁在世上某处哭，无缘无故在世上哭，在哭我。此刻有谁在夜间某处笑，无缘无故的在夜间笑，在笑我。此刻有谁在世上某处走，无缘无故的在世上走，走向我。此刻有谁在世上某处死，无缘无故在世上死，望着我。"></a>10.此刻有谁在世上某处哭，无缘无故在世上哭，在哭我。此刻有谁在夜间某处笑，无缘无故的在夜间笑，在笑我。此刻有谁在世上某处走，无缘无故的在世上走，走向我。此刻有谁在世上某处死，无缘无故在世上死，望着我。</h5><p>——里尔克﻿﻿</p><p><img src="https://upload-images.jianshu.io/upload_images/7326374-f33e20c34492e783.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="高山森林"></p><h5 id="11-不惋惜，不呼唤，我也不啼哭。一切将逝去。如苹果花丛的薄雾。金黄的落叶堆满心间，我已不再是青春少年"><a href="#11-不惋惜，不呼唤，我也不啼哭。一切将逝去。如苹果花丛的薄雾。金黄的落叶堆满心间，我已不再是青春少年" class="headerlink" title="11.不惋惜，不呼唤，我也不啼哭。一切将逝去。如苹果花丛的薄雾。金黄的落叶堆满心间，我已不再是青春少年"></a>11.不惋惜，不呼唤，我也不啼哭。一切将逝去。如苹果花丛的薄雾。金黄的落叶堆满心间，我已不再是青春少年</h5><p>——叶赛宁﻿﻿</p><h5 id="12-多希望我知道如何放弃你，你什么都没留给我却活在我心里。"><a href="#12-多希望我知道如何放弃你，你什么都没留给我却活在我心里。" class="headerlink" title="12.多希望我知道如何放弃你，你什么都没留给我却活在我心里。﻿﻿"></a>12.多希望我知道如何放弃你，你什么都没留给我却活在我心里。﻿﻿</h5><h5 id="13-最要紧的是，我们首先应该知道善良，其次要诚实，再其次是以后永远不要互相遗忘。"><a href="#13-最要紧的是，我们首先应该知道善良，其次要诚实，再其次是以后永远不要互相遗忘。" class="headerlink" title="13.最要紧的是，我们首先应该知道善良，其次要诚实，再其次是以后永远不要互相遗忘。﻿﻿"></a>13.最要紧的是，我们首先应该知道善良，其次要诚实，再其次是以后永远不要互相遗忘。﻿﻿</h5><h5 id="14-我向旧日的恋人道歉，因为我对新人如同初恋。"><a href="#14-我向旧日的恋人道歉，因为我对新人如同初恋。" class="headerlink" title="14.我向旧日的恋人道歉，因为我对新人如同初恋。"></a>14.我向旧日的恋人道歉，因为我对新人如同初恋。</h5><p>——辛波斯卡﻿﻿</p><h5 id="15-我永恒的灵魂，注视着你的心，纵然黑夜孤寂白昼如焚。"><a href="#15-我永恒的灵魂，注视着你的心，纵然黑夜孤寂白昼如焚。" class="headerlink" title="15.我永恒的灵魂，注视着你的心，纵然黑夜孤寂白昼如焚。"></a>15.我永恒的灵魂，注视着你的心，纵然黑夜孤寂白昼如焚。</h5><p>——兰波﻿﻿</p><h5 id="16-我常想，如果我拍够了足够的照片，我就不会再失去任何人。事实上，我的照片让我看到了我失去了多少"><a href="#16-我常想，如果我拍够了足够的照片，我就不会再失去任何人。事实上，我的照片让我看到了我失去了多少" class="headerlink" title="16.我常想，如果我拍够了足够的照片，我就不会再失去任何人。事实上，我的照片让我看到了我失去了多少"></a>16.我常想，如果我拍够了足够的照片，我就不会再失去任何人。事实上，我的照片让我看到了我失去了多少</h5><p>——南戈尔丁﻿﻿</p><h5 id="17-知识让我们愤世嫉俗，聪明让我们铁石心肠。我们想的太多，同情太少，除了机器我们更需要善良，没有这些品质，生命就没有意义。"><a href="#17-知识让我们愤世嫉俗，聪明让我们铁石心肠。我们想的太多，同情太少，除了机器我们更需要善良，没有这些品质，生命就没有意义。" class="headerlink" title="17.知识让我们愤世嫉俗，聪明让我们铁石心肠。我们想的太多，同情太少，除了机器我们更需要善良，没有这些品质，生命就没有意义。"></a>17.知识让我们愤世嫉俗，聪明让我们铁石心肠。我们想的太多，同情太少，除了机器我们更需要善良，没有这些品质，生命就没有意义。</h5><p>——卓别林﻿﻿</p><h5 id="18-你别赤脚走在这片草地上散步，我怕我的花园到处都是星星的碎片。"><a href="#18-你别赤脚走在这片草地上散步，我怕我的花园到处都是星星的碎片。" class="headerlink" title="18.你别赤脚走在这片草地上散步，我怕我的花园到处都是星星的碎片。"></a>18.你别赤脚走在这片草地上散步，我怕我的花园到处都是星星的碎片。</h5><p>——伊迪斯 索德格朗﻿﻿</p><h5 id="19-身体里的碳可以制成九千支铅笔，赠给诗人。身体里的铁，只够打成一枚铁钉，就钉在爱人的心上。"><a href="#19-身体里的碳可以制成九千支铅笔，赠给诗人。身体里的铁，只够打成一枚铁钉，就钉在爱人的心上。" class="headerlink" title="19.身体里的碳可以制成九千支铅笔，赠给诗人。身体里的铁，只够打成一枚铁钉，就钉在爱人的心上。﻿﻿"></a>19.身体里的碳可以制成九千支铅笔，赠给诗人。身体里的铁，只够打成一枚铁钉，就钉在爱人的心上。﻿﻿</h5><h5 id="20-岁月有加，并非垂老。理想丢弃，方坠暮年。岁月悠悠，衰微只及肌肤。热忱抛却，颓废必致灵魂。"><a href="#20-岁月有加，并非垂老。理想丢弃，方坠暮年。岁月悠悠，衰微只及肌肤。热忱抛却，颓废必致灵魂。" class="headerlink" title="20.岁月有加，并非垂老。理想丢弃，方坠暮年。岁月悠悠，衰微只及肌肤。热忱抛却，颓废必致灵魂。"></a>20.岁月有加，并非垂老。理想丢弃，方坠暮年。岁月悠悠，衰微只及肌肤。热忱抛却，颓废必致灵魂。</h5><p>——塞缪尔 厄尔曼﻿﻿</p><h5 id="21-情不知所起，一往而深"><a href="#21-情不知所起，一往而深" class="headerlink" title="21.情不知所起，一往而深"></a>21.情不知所起，一往而深</h5><p>——汤显祖﻿﻿</p><h5 id="22-渐渐觉得，友谊这个东西已经被世人捧的太高，它跟永恒其实没有太大关系。换了空间时间，总会有人离去。也总会有与当下的你心有相同的同伴不断出现，来陪你走接下来或短或长的人生。所以不要太念念不忘。也不要期待有什么回响。你要从同路者中寻找同伴，而非硬拽着旧人一起上路。"><a href="#22-渐渐觉得，友谊这个东西已经被世人捧的太高，它跟永恒其实没有太大关系。换了空间时间，总会有人离去。也总会有与当下的你心有相同的同伴不断出现，来陪你走接下来或短或长的人生。所以不要太念念不忘。也不要期待有什么回响。你要从同路者中寻找同伴，而非硬拽着旧人一起上路。" class="headerlink" title="22.渐渐觉得，友谊这个东西已经被世人捧的太高，它跟永恒其实没有太大关系。换了空间时间，总会有人离去。也总会有与当下的你心有相同的同伴不断出现，来陪你走接下来或短或长的人生。所以不要太念念不忘。也不要期待有什么回响。你要从同路者中寻找同伴，而非硬拽着旧人一起上路。﻿﻿"></a>22.渐渐觉得，友谊这个东西已经被世人捧的太高，它跟永恒其实没有太大关系。换了空间时间，总会有人离去。也总会有与当下的你心有相同的同伴不断出现，来陪你走接下来或短或长的人生。所以不要太念念不忘。也不要期待有什么回响。你要从同路者中寻找同伴，而非硬拽着旧人一起上路。﻿﻿</h5><h5 id="23-世界上最大的勇气，是压力下的优雅。"><a href="#23-世界上最大的勇气，是压力下的优雅。" class="headerlink" title="23.世界上最大的勇气，是压力下的优雅。"></a>23.世界上最大的勇气，是压力下的优雅。</h5><p>——海明威﻿﻿</p><h5 id="24-为你，千千万万遍"><a href="#24-为你，千千万万遍" class="headerlink" title="24.为你，千千万万遍"></a>24.为你，千千万万遍</h5><p>——卡勒德 胡塞尼﻿﻿</p><h5 id="25-你，一会看我一会看云；你看我时很远，你看云时很近"><a href="#25-你，一会看我一会看云；你看我时很远，你看云时很近" class="headerlink" title="25.你，一会看我一会看云；你看我时很远，你看云时很近"></a>25.你，一会看我一会看云；你看我时很远，你看云时很近</h5><p>——顾城﻿﻿</p><h5 id="26"><a href="#26" class="headerlink" title="26."></a>26.</h5><p>草在结它的种子﻿﻿</p><p>树在摇它的叶子﻿﻿</p><p>我们站着 不说话﻿﻿</p><p>就十分美好﻿﻿</p><p>——顾城《门前》﻿﻿</p><h5 id="27-曾国藩的交友原则，八交九不交："><a href="#27-曾国藩的交友原则，八交九不交：" class="headerlink" title="27.曾国藩的交友原则，八交九不交：﻿﻿"></a>27.曾国藩的交友原则，八交九不交：﻿﻿</h5><p>八交：胜己者；盛德者；趣味者；肯吃亏者；直言者；志趣广大者；惠在当厄者；体人者﻿﻿</p><p>九不交：志不同者；谀人者；恩怨颠倒者；全无性情者；不孝不悌者；迂人者；落井下石者；德薄者；好占便宜者。﻿﻿</p><h5 id="28-那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，我想吃，我还想一瞬间变成天上半明半暗的云。"><a href="#28-那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，我想吃，我还想一瞬间变成天上半明半暗的云。" class="headerlink" title="28.那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，我想吃，我还想一瞬间变成天上半明半暗的云。"></a>28.那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，我想吃，我还想一瞬间变成天上半明半暗的云。</h5><p>——王小波《黄金时代》﻿﻿</p><h5 id="29-从童年起，我便独自一人照顾着历代星辰"><a href="#29-从童年起，我便独自一人照顾着历代星辰" class="headerlink" title="29.从童年起，我便独自一人照顾着历代星辰"></a>29.从童年起，我便独自一人照顾着历代星辰</h5><p>——《孤独》白鹤林﻿﻿</p><h5 id="30-这样看你，用所有的眼睛和所有距离，就像风住了，风又起"><a href="#30-这样看你，用所有的眼睛和所有距离，就像风住了，风又起" class="headerlink" title="30.这样看你，用所有的眼睛和所有距离，就像风住了，风又起"></a>30.这样看你，用所有的眼睛和所有距离，就像风住了，风又起</h5><p>——《沉溺》冯唐﻿﻿<br><img src="https://upload-images.jianshu.io/upload_images/7326374-abdbf1d8c37fcc71.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="蓝天海滩"></p><h5 id="31-人时已尽，人世很长。我在中间应当休息，走过的人说树枝低了，走过的人说树枝在长。"><a href="#31-人时已尽，人世很长。我在中间应当休息，走过的人说树枝低了，走过的人说树枝在长。" class="headerlink" title="31.人时已尽，人世很长。我在中间应当休息，走过的人说树枝低了，走过的人说树枝在长。"></a>31.人时已尽，人世很长。我在中间应当休息，走过的人说树枝低了，走过的人说树枝在长。</h5><p>——《墓床》顾城﻿﻿</p><h5 id="32-万物皆有裂痕，那是光进来的地方。"><a href="#32-万物皆有裂痕，那是光进来的地方。" class="headerlink" title="32.万物皆有裂痕，那是光进来的地方。"></a>32.万物皆有裂痕，那是光进来的地方。</h5><p>——莱昂纳德 科恩﻿﻿</p><h5 id="33-成功只有一种，那就是用自己喜欢的方式度过一生"><a href="#33-成功只有一种，那就是用自己喜欢的方式度过一生" class="headerlink" title="33.成功只有一种，那就是用自己喜欢的方式度过一生"></a>33.成功只有一种，那就是用自己喜欢的方式度过一生</h5><p>——《明朝那些事》原出于美国记者﻿﻿</p><h5 id="34-生活永远不可能像你想象的那么好，但也不会像你想象的那么糟，无论是好的还是糟糕的时候都需要坚强"><a href="#34-生活永远不可能像你想象的那么好，但也不会像你想象的那么糟，无论是好的还是糟糕的时候都需要坚强" class="headerlink" title="34.生活永远不可能像你想象的那么好，但也不会像你想象的那么糟，无论是好的还是糟糕的时候都需要坚强"></a>34.生活永远不可能像你想象的那么好，但也不会像你想象的那么糟，无论是好的还是糟糕的时候都需要坚强</h5><p>——《人生》莫泊桑﻿﻿</p><h5 id="35-谁这时没有房屋，就不必建筑；谁这时孤独，就永远孤独，就醒着，读着，写着长信。在林荫道上来回，不安的游荡，当落叶纷飞。"><a href="#35-谁这时没有房屋，就不必建筑；谁这时孤独，就永远孤独，就醒着，读着，写着长信。在林荫道上来回，不安的游荡，当落叶纷飞。" class="headerlink" title="35.谁这时没有房屋，就不必建筑；谁这时孤独，就永远孤独，就醒着，读着，写着长信。在林荫道上来回，不安的游荡，当落叶纷飞。"></a>35.谁这时没有房屋，就不必建筑；谁这时孤独，就永远孤独，就醒着，读着，写着长信。在林荫道上来回，不安的游荡，当落叶纷飞。</h5><p>——《秋日》里尔克﻿﻿</p><h5 id="36-也许，我太会隐藏自己的悲伤；也许我太会安慰自己的伤；从阴雨走到艳阳，我路过泥泞，路过风"><a href="#36-也许，我太会隐藏自己的悲伤；也许我太会安慰自己的伤；从阴雨走到艳阳，我路过泥泞，路过风" class="headerlink" title="36.也许，我太会隐藏自己的悲伤；也许我太会安慰自己的伤；从阴雨走到艳阳，我路过泥泞，路过风"></a>36.也许，我太会隐藏自己的悲伤；也许我太会安慰自己的伤；从阴雨走到艳阳，我路过泥泞，路过风</h5><p>——《你若懂我 该多好》﻿﻿</p><h5 id="37-我想无论是在塞纳河还是滹沱河边，我们两个人都已经放下彼此，所以我并没有等，她也不会在那个路灯下了，那个灯光下笑盈盈的她和慌张无力却又自大的我，永远属于了二十出头的我们，仅止于此我很满足，毕竟我们都要朝着让自己幸福努力。"><a href="#37-我想无论是在塞纳河还是滹沱河边，我们两个人都已经放下彼此，所以我并没有等，她也不会在那个路灯下了，那个灯光下笑盈盈的她和慌张无力却又自大的我，永远属于了二十出头的我们，仅止于此我很满足，毕竟我们都要朝着让自己幸福努力。" class="headerlink" title="37.我想无论是在塞纳河还是滹沱河边，我们两个人都已经放下彼此，所以我并没有等，她也不会在那个路灯下了，那个灯光下笑盈盈的她和慌张无力却又自大的我，永远属于了二十出头的我们，仅止于此我很满足，毕竟我们都要朝着让自己幸福努力。﻿﻿"></a>37.我想无论是在塞纳河还是滹沱河边，我们两个人都已经放下彼此，所以我并没有等，她也不会在那个路灯下了，那个灯光下笑盈盈的她和慌张无力却又自大的我，永远属于了二十出头的我们，仅止于此我很满足，毕竟我们都要朝着让自己幸福努力。﻿﻿</h5><h5 id="38-一个人有两个我，一个在黑暗中醒着，一个在光明中睡着"><a href="#38-一个人有两个我，一个在黑暗中醒着，一个在光明中睡着" class="headerlink" title="38.一个人有两个我，一个在黑暗中醒着，一个在光明中睡着"></a>38.一个人有两个我，一个在黑暗中醒着，一个在光明中睡着</h5><p>——纪伯伦﻿﻿</p><h5 id="39-若我会见到你，事隔经年，我如何向你招呼，以眼泪，以沉默"><a href="#39-若我会见到你，事隔经年，我如何向你招呼，以眼泪，以沉默" class="headerlink" title="39.若我会见到你，事隔经年，我如何向你招呼，以眼泪，以沉默"></a>39.若我会见到你，事隔经年，我如何向你招呼，以眼泪，以沉默</h5><p>——拜伦﻿﻿</p><h5 id="40-枕上诗书闲处好，门前风景雨来佳"><a href="#40-枕上诗书闲处好，门前风景雨来佳" class="headerlink" title="40.枕上诗书闲处好，门前风景雨来佳"></a>40.枕上诗书闲处好，门前风景雨来佳</h5><p>——李清照﻿﻿<br><img src="https://upload-images.jianshu.io/upload_images/7326374-87ba94de06d5cd74.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="夕阳风雪"></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>也分享一些杂文~</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-0c30c361239e4cca?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 美文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 美文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试集锦：25道线程类相关面试题与答案（一）</title>
      <link href="/2019/11/14/interview/java/A-thread01/"/>
      <url>/2019/11/14/interview/java/A-thread01/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7326374-333fa10a973e7519.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java面试集锦：25道线程类相关面试题与答案（一）.png"></p><blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><h3 id="1-线程是什么？进程是什么？二者有什么区别和联系？"><a href="#1-线程是什么？进程是什么？二者有什么区别和联系？" class="headerlink" title="1. 线程是什么？进程是什么？二者有什么区别和联系？"></a>1. 线程是什么？进程是什么？二者有什么区别和联系？</h3><p>（1）线程是CPU独立运行和独立调度的基本单位；<br>（2）进程是资源分配的基本单位；是执行着的应用程序<br>两者的联系：进程和线程都是操作系统所运行的程序运行的基本单元。</p><p><strong>区别：</strong><br>（1）进程具有独立的空间地址，一个进程崩溃后，在保护模式下不会对其它进程产生影响。<br>（2）线程只是一个进程的不同执行路径，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。</p><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p><h3 id="2-线程和进程各自有什么区别和优劣呢？"><a href="#2-线程和进程各自有什么区别和优劣呢？" class="headerlink" title="2. 线程和进程各自有什么区别和优劣呢？"></a>2. 线程和进程各自有什么区别和优劣呢？</h3><p>进程是资源分配的最小单位，线程是程序执行的最小单位。</p><p>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</p><p>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p><p>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p><p>可参考文章<a href=""></a></p><h3 id="3-创建线程有几种不同的方式？你喜欢哪一种？为什么？"><a href="#3-创建线程有几种不同的方式？你喜欢哪一种？为什么？" class="headerlink" title="3. 创建线程有几种不同的方式？你喜欢哪一种？为什么？"></a>3. 创建线程有几种不同的方式？你喜欢哪一种？为什么？</h3><p>有三种方式可以用来创建线程：</p><p>继承<code>Thread</code>类</p><p>实现<code>Runnable</code>接口</p><p>应用程序可以使用Executor框架来创建线程池</p><p>实现<code>Runnable接口</code>这种方式更受欢迎，因为这不需要继承<code>Thread</code>类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p><h3 id="4-概括的解释下线程的几种可用状态"><a href="#4-概括的解释下线程的几种可用状态" class="headerlink" title="4. 概括的解释下线程的几种可用状态?"></a>4. 概括的解释下线程的几种可用状态?</h3><p>线程在执行过程中，可以处于下面几种状态：</p><p><strong>就绪(Runnable)</strong>:线程准备运行，不一定立马就能开始执行。</p><p><strong>运行中(Running)</strong>：进程正在执行线程的代码。</p><p><strong>等待中(Waiting)</strong>:线程处于阻塞的状态，等待外部的处理结束。</p><p><strong>睡眠中(Sleeping)</strong>：线程被强制睡眠。</p><p><strong>I/O阻塞(Blocked on I/O)</strong>：等待I/O操作完成。</p><p><strong>同步阻塞(Blocked on Synchronization)</strong>：等待获取锁。</p><p><strong>死亡(Dead)</strong>：线程完成了执行。</p><h3 id="5-同步方法和同步代码块的区别是什么？"><a href="#5-同步方法和同步代码块的区别是什么？" class="headerlink" title="5. 同步方法和同步代码块的区别是什么？"></a>5. 同步方法和同步代码块的区别是什么？</h3><p>在Java语言中，每一个对象有一把锁。线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。</p><p>Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p><p>（1）、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</p><p>（2）、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</p><p>（3）、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</p><p>（4）、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</p><p>（5）、以上规则对其它对象锁同样适用。</p><h3 id="6-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#6-在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="6. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>6. 在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h3><p>监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p><h3 id="7-什么是死锁-deadlock-？"><a href="#7-什么是死锁-deadlock-？" class="headerlink" title="7. 什么是死锁(deadlock)？"></a>7. 什么是死锁(deadlock)？</h3><p>两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p><h3 id="8-如何确保N个线程可以访问N个资源同时又不导致死锁？"><a href="#8-如何确保N个线程可以访问N个资源同时又不导致死锁？" class="headerlink" title="8. 如何确保N个线程可以访问N个资源同时又不导致死锁？"></a>8. 如何确保N个线程可以访问N个资源同时又不导致死锁？</h3><p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p><h3 id="9-如何避免死锁"><a href="#9-如何避免死锁" class="headerlink" title="9. 如何避免死锁?"></a>9. 如何避免死锁?</h3><p>多线程产生死锁的四个必要条件：<br><strong>互斥条件：</strong> 一个资源每次只能被一个进程使用。<br><strong>保持和请求条件：</strong> 一个进程因请求资源而阻塞时，对已获得资源保持不放。<br><strong>不可剥夺调教：</strong> 进程已获得资源，在未使用完成前，不能被剥夺。<br><strong>循环等待条件：</strong> 若干进程之间形成一种头尾相接的循环等待资源关系。</p><p>只要破坏其中任意一个条件，就可以避免死锁，其中最简单的就是破环循环等待条件。按同一顺序访问对象，加载锁，释放锁。</p><h3 id="10-Thread-类中的start-和-run-方法有什么区别？"><a href="#10-Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="10. Thread 类中的start() 和 run() 方法有什么区别？"></a>10. Thread 类中的start() 和 run() 方法有什么区别？</h3><p>start()方法被用来启动新创建的线程，使该被创建的线程状态变为可运行状态。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，直接运行run（）方法。为了在新的线程中执行我们的代码，必须使用Thread.start()方法。</p><h3 id="11-Java中Runnable和Callable有什么不同？"><a href="#11-Java中Runnable和Callable有什么不同？" class="headerlink" title="11. Java中Runnable和Callable有什么不同？"></a>11. Java中Runnable和Callable有什么不同？</h3><p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。</p><h3 id="12-Java中什么是竞态条件？"><a href="#12-Java中什么是竞态条件？" class="headerlink" title="12. Java中什么是竞态条件？"></a>12. Java中什么是竞态条件？</h3><p>在大多数实际的多线程应用中，两个或两个以上的线程需要共享对同一数据的存取。如果i线程存取相同的对象，并且每一个线程都调用了一个修改该对象状态的方法，将会发生什么呢？可以想象，线程彼此踩了对方的脚。根据线程访问数据的次序，可能会产生讹误的对象。这样的情况通常称为竞争条件。</p><h3 id="13-Java中如何停止一个线程？"><a href="#13-Java中如何停止一个线程？" class="headerlink" title="13. Java中如何停止一个线程？"></a>13. Java中如何停止一个线程？</h3><p><code>Java</code>提供了很丰富的API但没有为停止线程提供API。<br><code>JDK 1.0</code>本来有一些像<code>stop()</code>, <code>suspend()</code> 和 <code>resume()</code>的控制方法，但是由于潜在的死锁威胁。<br>因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供一个兼容且线程安全的方法来停止一个线程。<br>当<code>run()</code>或者 <code>call()</code> 方法执行完的时候线程会自动结束，如果要手动结束一个线程，可以用<code>volatile</code> 布尔变量来退出<code>run()</code>方法的循环或者是取消任务来中断线程。</p><h3 id="14-Java中notify-和-notifyAll有什么区别？"><a href="#14-Java中notify-和-notifyAll有什么区别？" class="headerlink" title="14. Java中notify 和 notifyAll有什么区别？"></a>14. Java中notify 和 notifyAll有什么区别？</h3><p>一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。<br>如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p><h3 id="15-Java中的同步集合与并发集合有什么区别？"><a href="#15-Java中的同步集合与并发集合有什么区别？" class="headerlink" title="15. Java中的同步集合与并发集合有什么区别？"></a>15. Java中的同步集合与并发集合有什么区别？</h3><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。<br>在<code>Java1.5</code>之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像<code>ConcurrentHashMap</code>，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p><h3 id="16-什么是线程池？"><a href="#16-什么是线程池？" class="headerlink" title="16. 什么是线程池？"></a>16. 什么是线程池？</h3><p>线程池是一种多线程处理形式，处理过程中将任务提交到线程池，任务的执行交由线程池来管理。<br>如果每个请求都创建一个线程去处理，那么服务器的资源很快就会被耗尽，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p><h3 id="17-为什么要使用线程池？"><a href="#17-为什么要使用线程池？" class="headerlink" title="17. 为什么要使用线程池？"></a>17. 为什么要使用线程池？</h3><p>创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。（我们可以把创建和销毁的线程的过程去掉）</p><h3 id="18-线程池有什么作用？"><a href="#18-线程池有什么作用？" class="headerlink" title="18. 线程池有什么作用？"></a>18. 线程池有什么作用？</h3><p>线程池作用就是限制系统中执行线程的数量。</p><p>1、提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。</p><p>2、方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。</p><h3 id="19-说说几种常见的线程池及使用场景"><a href="#19-说说几种常见的线程池及使用场景" class="headerlink" title="19. 说说几种常见的线程池及使用场景?"></a>19. 说说几种常见的线程池及使用场景?</h3><p>1、<code>newSingleThreadExecutor</code>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><p>2、<code>newFixedThreadPool</code>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>3、<code>newCachedThreadPool</code>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>4、<code>newScheduledThreadPool</code>创建一个定长线程池，支持定时及周期性任务执行。</p><h3 id="20-线程池中的几种重要的参数"><a href="#20-线程池中的几种重要的参数" class="headerlink" title="20. 线程池中的几种重要的参数?"></a>20. 线程池中的几种重要的参数?</h3><p><code>corePoolSize</code>就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会被回收</p><p><code>maximumPoolSize</code>就是线程池中可以容纳的最大线程的数量</p><p><code>keepAliveTime</code>，就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，除了核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间。<br><code>util</code>，就是计算这个时间的一个单位。</p><p><code>workQueue</code>，就是等待队列，任务可以储存在任务队列中等待被执行，执行的是FIFIO原则（先进先出）。</p><p><code>threadFactory</code>，就是创建线程的线程工厂。</p><p><code>handler</code>,是一种拒绝策略，我们可以在任务满了之后，拒绝执行某些任务。</p><h3 id="21-说说线程池的拒绝策略"><a href="#21-说说线程池的拒绝策略" class="headerlink" title="21. 说说线程池的拒绝策略?"></a>21. 说说线程池的拒绝策略?</h3><p>当请求任务不断的过来，而系统此时又处理不过来的时候，我们需要采取的策略是拒绝服务。RejectedExecutionHandler接口提供了拒绝任务处理的自定义方法的机会。在ThreadPoolExecutor中已经包含四种处理策略。</p><ul><li>AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作。</li></ul><ul><li><p>CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。</p></li><li><p>DiscardOleddestPolicy策略： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</p></li></ul><ul><li>DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。</li></ul><p>除了JDK默认提供的四种拒绝策略，我们可以根据自己的业务需求去自定义拒绝策略，自定义的方式很简单，直接实现<code>RejectedExecutionHandler</code>接口即可。</p><h3 id="22-execute和submit的区别？"><a href="#22-execute和submit的区别？" class="headerlink" title="22. execute和submit的区别？"></a>22. execute和submit的区别？</h3><p>我们执行任务是用的execute方法，除了execute方法，还有一个submit方法也可以执行我们提交的任务。</p><p>这两个方法有什么区别呢？分别适用于在什么场景下呢？<br>我们来做一个简单的分析。</p><ul><li><p>execute适用于不需要关注返回值的场景，只需要将线程丢到线程池中去执行就可以了。</p></li><li><p>submit方法适用于需要关注返回值的场景</p></li></ul><h3 id="23-五种线程池的使用场景"><a href="#23-五种线程池的使用场景" class="headerlink" title="23. 五种线程池的使用场景?"></a>23. 五种线程池的使用场景?</h3><ul><li><p>newSingleThreadExecutor：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。</p></li><li><p>newFixedThreadPool：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。</p></li></ul><ul><li>newCachedThreadPool：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。</li></ul><ul><li>newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</li><li>newWorkStealingPool：一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行。</li></ul><h3 id="24-线程池如何关闭-初始化线程池时线程数的选择？"><a href="#24-线程池如何关闭-初始化线程池时线程数的选择？" class="headerlink" title="24. 线程池如何关闭? 初始化线程池时线程数的选择？"></a>24. 线程池如何关闭? 初始化线程池时线程数的选择？</h3><p>关闭线程池可以调用shutdownNow和shutdown两个方法来实现</p><p>shutdownNow：对正在执行的任务全部发出interrupt()，停止执行，对还未开始执行的任务全部取消，并且返回还没开始的任务列表。</p><p>shutdown：当我们调用shutdown后，线程池将不再接受新的任务，但也不会去强制终止已经提交或者正在执行中的任务。</p><p>如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。</p><p>如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数也只能增加上下文切换，不能增加CPU利用率。</p><p>上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。</p><h3 id="25-线程池都有哪几种工作队列？"><a href="#25-线程池都有哪几种工作队列？" class="headerlink" title="25. 线程池都有哪几种工作队列？"></a>25. 线程池都有哪几种工作队列？</h3><p>1、<code>ArrayBlockingQueue</code></p><p>是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p>2、<code>LinkedBlockingQueue</code><br>一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列</p><p>3、<code>SynchronousQueue</code></p><p>一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p><p>4、<code>PriorityBlockingQueue</code></p><p>一个具有优先级的无限阻塞队列。</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">大厂笔试内容集合（内有详细解析）</a> 持续更新中….</p><p><a href="https://www.processon.com/i/5cd53c2fe4b01941c8cf1c21" target="_blank" rel="noopener">ProcessOn是一个在线作图工具的聚合平台~</a></p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>欢迎关注<strong>Coder编程</strong>公众号，主要分享数据结构与算法、Java相关知识体系、框架知识及原理、Spring全家桶、微服务项目实战、DevOps实践之路、每日一篇互联网大厂面试或笔试题以及PMP项目管理知识等。更多精彩内容正在路上~<br>新建了一个qq群：315211365，欢迎大家进群交流一起学习。谢谢了！也可以介绍给身边有需要的朋友。</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-fdefd65feb040355?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（五）</title>
      <link href="/2019/09/19/interview/java/B-bishi05/"/>
      <url>/2019/09/19/interview/java/B-bishi05/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-8a182e3da5ea417e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（五）"></p><h2 id="1-以下关于Integer与int的区别错误的是？"><a href="#1-以下关于Integer与int的区别错误的是？" class="headerlink" title="1.以下关于Integer与int的区别错误的是？"></a>1.以下关于Integer与int的区别错误的是？</h2><p>A.int是java提供的8种原始数据类型之一<br>B.Integer是java为int提供的封装类<br>C.int的默认值为0<br>D.Integer的默认值为1</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>略</p><h2 id="2-给定以下方法声明，调用执行mystery（1234）的输出结果？"><a href="#2-给定以下方法声明，调用执行mystery（1234）的输出结果？" class="headerlink" title="2.给定以下方法声明，调用执行mystery（1234）的输出结果？"></a>2.给定以下方法声明，调用执行mystery（1234）的输出结果？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;precondition:  x &gt;&#x3D;0</span><br><span class="line">public void mystery (int x)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(x % 10);</span><br><span class="line"> </span><br><span class="line">if ((x &#x2F; 10) !&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">mystery(x &#x2F; 10);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(x % 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.1441<br>B.43211234<br>C.3443<br>D.12344321</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>递归调用</p><h2 id="3-下面不是类及类成员的访问控制符的是-。（不考虑内部类的情况）"><a href="#3-下面不是类及类成员的访问控制符的是-。（不考虑内部类的情况）" class="headerlink" title="3.下面不是类及类成员的访问控制符的是( )。（不考虑内部类的情况）"></a>3.下面不是类及类成员的访问控制符的是( )。（不考虑内部类的情况）</h2><p>A.public<br>B.private<br>C.static<br>D.protected</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>类访问控制符只有三种：public ，private， protected  static和访问控制无关</p><h2 id="4-下列修饰符中与访问控制权限无关的是？（-）"><a href="#4-下列修饰符中与访问控制权限无关的是？（-）" class="headerlink" title="4.下列修饰符中与访问控制权限无关的是？（ ）"></a>4.下列修饰符中与访问控制权限无关的是？（ ）</h2><p>A.private<br>B.public<br>C.protected<br>D.final</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>private :        修饰私有变量<br>public :         修饰公有变量<br>protected:    修饰受保护变量<br>没有final, final用于保护变量不受改变</p><h2 id="5-局部变量能否和成员变量重名？"><a href="#5-局部变量能否和成员变量重名？" class="headerlink" title="5.局部变量能否和成员变量重名？"></a>5.局部变量能否和成员变量重名？</h2><p>A.可以，局部变量可以与成员变量重名，这时可用“this”来指向成员变量<br>B.可以，这时可用“local”关键字来指向局部变量<br>C.不能，局部变量不能与成员变量重名<br>D.不能，在一个类中不能有重名变量，不管是成员变量还是函数中的局部变量</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>JAVA访问变量采用就近原则，局部变量与成员变量重名时，局部变量比较近，使用局部变量</p><h2 id="6-下列说法正确的是"><a href="#6-下列说法正确的是" class="headerlink" title="6.下列说法正确的是()"></a>6.下列说法正确的是()</h2><p>A.在类方法中可用this来调用本类的类方法<br>B.在类方法中调用本类的类方法可直接调用<br>C.在类方法中只能调用本类的类方法<br>D.在类方法中绝对不能调用实例方法</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>在类方法中调用本类的类方法可直接调用。 实例方法也叫做对象方法。<br>类方法是属于整个类的，而实例方法是属于类的某个对象的。<br>由于类方法是属于整个类的，并不属于类的哪个对象，所以类方法的方法体中不能有与类的对象有关的内容。即类方法体有如下限制：<br>(1) 类方法中不能引用对象变量；<br>(2) 类方法中不能调用类的对象方法；<br>(3) 在类方法中不能使用super、this关键字。<br>(4)类方法不能被覆盖。<br>如果违反这些限制，就会导致程序编译错误。<br>与类方法相比，对象方法几乎没有什么限制：<br>(1) 对象方法中可以引用对象变量，也可以引用类变量；<br>(2) 对象方法中可以调用类方法；<br>(3) 对象方法中可以使用super、this关键字。</p><h2 id="7-关于依赖注入，下列选项中说法错误的是（）？"><a href="#7-关于依赖注入，下列选项中说法错误的是（）？" class="headerlink" title="7.关于依赖注入，下列选项中说法错误的是（）？"></a>7.关于依赖注入，下列选项中说法错误的是（）？</h2><p>A.依赖注入能够独立开发各组件，然后根据组件间关系进行组装<br>B.依赖注入提供使用接口编程<br>C.依赖注入使组件之间相互依赖，相互制约<br>D.依赖注入指对象在使用时动态注入</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>依赖注入目的是减少组件之间的耦合度，使开发变得简单。</p><h2 id="8-运行下面代码，输出的结果是（）"><a href="#8-运行下面代码，输出的结果是（）" class="headerlink" title="8.运行下面代码，输出的结果是（）"></a>8.运行下面代码，输出的结果是（）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public A() &#123;</span><br><span class="line">        System.out.println(&quot;class A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; System.out.println(&quot;I&#39;m A class&quot;); &#125;</span><br><span class="line">    static &#123; System.out.println(&quot;class A static&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class B extends A &#123;</span><br><span class="line">    public B() &#123;</span><br><span class="line">        System.out.println(&quot;class B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; System.out.println(&quot;I&#39;m B class&quot;); &#125;</span><br><span class="line">    static &#123; System.out.println(&quot;class B static&quot;); &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> new B();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static </span><br><span class="line">class B static </span><br><span class="line">I&#39;m A class </span><br><span class="line">class A</span><br><span class="line">I&#39;m B class </span><br><span class="line">class B</span><br></pre></td></tr></table></figure><p>B.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static</span><br><span class="line">I&#39;m A class</span><br><span class="line">class A</span><br><span class="line">class B static</span><br><span class="line">I&#39;m B class</span><br><span class="line">class B</span><br></pre></td></tr></table></figure><p>C.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static</span><br><span class="line">class B static</span><br><span class="line">class A</span><br><span class="line">I&#39;m A class </span><br><span class="line">class B</span><br><span class="line">I&#39;m B class</span><br></pre></td></tr></table></figure><p>D.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static</span><br><span class="line">class A</span><br><span class="line">I&#39;m A class</span><br><span class="line">class B static</span><br><span class="line">class B</span><br><span class="line">I&#39;m B class</span><br></pre></td></tr></table></figure><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>此题考虑 Java 中构造器、初始化块、静态初始化块的执行顺序。</p><p>静态初始化块 &gt; 初始化块 &gt; 构造器<br>父类 &gt; 子类<br>综合下来顺序就是：</p><p>父类静态初始化块<br>子类静态初始化块<br>父类初始化块<br>父类构造器<br>子类初始化块<br>子类构造器<br>需要注意静态初始化块是在类第一次加载的时候就会进行初始化。</p><h2 id="9-下面哪个标识符是合法的？"><a href="#9-下面哪个标识符是合法的？" class="headerlink" title="9.下面哪个标识符是合法的？"></a>9.下面哪个标识符是合法的？</h2><p>A.”9HelloWorld”<br>B.”_Hello World”<br>C.”Hello*World”<br>D.”Hello$World”</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>标识符是以字母开头的字母数字序列：<br>数字是指0~9，字母指大小写英文字母、下划线（_)和美元符号（$），也可以是Unicode字符集中的字符，如汉字；<br>字母、数字等字符的任意组合，不能包含+、- <em>等字符；<br>不能使用关键字；<br>大小写敏感<br>由此可以看出：<br>A：不可以数字开头<br>B：用下划线开头符合，但是中间有空格<br>C:不能包含“</em>”<br>排除ABC，答案即是D</p><h2 id="10-以下程序执行的结果是："><a href="#10-以下程序执行的结果是：" class="headerlink" title="10.以下程序执行的结果是："></a>10.以下程序执行的结果是：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class X&#123;</span><br><span class="line">    Y y&#x3D;new Y();</span><br><span class="line">    public X()&#123;</span><br><span class="line">        System.out.print(&quot;X&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Y&#123;</span><br><span class="line">    public Y()&#123;</span><br><span class="line">        System.out.print(&quot;Y&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Z extends X&#123;</span><br><span class="line">    Y y&#x3D;new Y();</span><br><span class="line">    public Z()&#123;</span><br><span class="line">        System.out.print(&quot;Z&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Z();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.ZYXX<br>B.ZYXY<br>C.YXYZ<br>D.XYZX</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>1.父类静态代码块 （java虚拟机加载类时，就会执行该块代码，故只执行一次）<br>2 .子类静态代码块 （java虚拟机加载类时，就会执行该块代码，故只执行一次）<br>3. 父类属性对象初始化<br>4.父类普通代码块（每次new,每次执行 ）<br>5. 父类构造函数（每次new,每次执行）<br>6.子 类 属性对象初始化<br>7.子类普通代码块（每次new,每次执行 ）<br>8.子 类构造函数（每次new,每次执行）</p><h2 id="11-以下声明合法的是"><a href="#11-以下声明合法的是" class="headerlink" title="11.以下声明合法的是"></a>11.以下声明合法的是</h2><p>A.default  String  s<br>B.public  final  static  native  int  w( )<br>C.abstract  double  d<br>D.abstract  final  double  hyperbolicCosine( )</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>A：java的访问权限有public、protected、private和default的，default不能修饰变量<br>C：普通变量不能用abstract修饰，abstract一般修饰方法和类<br>D：被定义为abstract的类需要被子类继承，但是被修饰为final的类是不能被继承和改写的心存疑问可以实验一下，看是否能通过编译.</p><h2 id="12-java用（）机制实现了进程之间的同步执行"><a href="#12-java用（）机制实现了进程之间的同步执行" class="headerlink" title="12.java用（）机制实现了进程之间的同步执行"></a>12.java用（）机制实现了进程之间的同步执行</h2><p>A.虚拟机<br>B.多个CPU<br>C.异步调用<br>D.监视器</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>同步执行，需要监视器，即锁。</p><h2 id="13-What-is-displayed-when-the-following-is-executed"><a href="#13-What-is-displayed-when-the-following-is-executed" class="headerlink" title="13.What is displayed when the following is executed;"></a>13.What is displayed when the following is executed;</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double d1&#x3D;-0.5;</span><br><span class="line">System.out.println(&quot;Ceil d1&#x3D;&quot;+Math.ceil(d1));</span><br><span class="line">System.out.println(&quot;floor d1&#x3D;&quot;+Math.floor(d1));</span><br></pre></td></tr></table></figure><p>A.Ceil d1=-0.0   floor d1=-1.0<br>B.Ceil d1=0.0    floor d1=-1.0<br>C.Ceil d1=-0.0  floor d1=-0.0<br>D.Ceil d1=0.0   floor d1=0.0<br>E.Ceil d1=0     floor d1=-1</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong></p><h2 id="14-有关下述Java代码描述正确的选项是-。"><a href="#14-有关下述Java代码描述正确的选项是-。" class="headerlink" title="14.有关下述Java代码描述正确的选项是____。"></a>14.有关下述Java代码描述正确的选项是____。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line">   private static void testMethod()&#123;</span><br><span class="line">        System.out.println(&quot;testMethod&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">        ((TestClass)null).testMethod();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.编译不通过<br>B.编译通过，运行异常，报NullPointerException<br>C.编译通过，运行异常，报IllegalArgumentException<br>D.编译通过，运行异常，报NoSuchMethodException<br>E.编译通过，运行异常，报Exception<br>F.运行正常，输出testMethod</p><p><strong>答案：</strong><br>F</p><p><strong>解析：</strong><br>1）此处是类对方法的调用，不是对象对方法的调用。<br>2）方法是static静态方法，直接使用”类.方法”即可，因为静态方法使用不依赖对象是否被创建。null可以被强制类型转换成任意类型（不是任意类型对象），于是可以通过它来执行静态方法。<br>3）非静态的方法用”对象.方法”的方式，必须依赖对象被创建后才能使用，若将testMethod()方法前的static去掉，则会报 空指针异常 。此处也验证了2）的观点<br>当然，不管是否静态方法，都是已经存在的，只是访问方式不同。</p><h2 id="15-下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持："><a href="#15-下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持：" class="headerlink" title="15.下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持：()"></a>15.下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持：()</h2><p>A.java.util.ConcurrentHashMap<br>B.java.util.Map<br>C.java.util.TreeMap<br>D.java.util.SortMap<br>E.java.util.Hashtable<br>F.java.util.HashMap</p><p><strong>答案：</strong><br>A E</p><p><strong>解析：</strong></p><ul><li>ConcurrentHashMap简称CHM,CHM 允许并发的读和线程安全的更新操作。在执行写操作时，CHM 只锁住部分的 Map，并发的更新是通过内部根据并发级别将 Map 分割成小部分实现的，高的并发级别会造成时间和空间的浪费，低的并发级别在写线程多时会引起线程间的竞争，CHM 的所有操作都是线程安全，CHM 返回的迭代器是弱一致性， fail-safe 并且不会抛出ConcurrentModificationException 异常，CHM不允许null的键值。可以使用 CHM 代替 HashTable，但要记住 CHM 不会锁住整个 Map</li><li>除了Hashtable，其他是非线性安全的。</li></ul><h2 id="16-JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是："><a href="#16-JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是：" class="headerlink" title="16.JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是：( )"></a>16.JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是：( )</h2><p>A.HttpSessionAttributeListener<br>B.HttpSessionBindingListener<br>C.HttpSessionObjectListener<br>D.HttpSessionListener;<br>E.HttpSession<br>F.HttpSessionActivationListener</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>HttpSessionAttributeListener：可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知；<br>HttpSessionBindingListener：当该对象从一个会话中被绑定或者解绑时通知该对象，这个对象由HttpSessionBindingEvent对象通知。这可能是servlet程序显式地从会话中解绑定属性的结果，可能是由于会话无效，也可能是由于会话超时；<br>HttpSessionObjectListener：没有该接口API；<br>HttpSessionListener：当web应用程序中的活动会话列表发生更改时通知该接口的实现类，为了接收该通知事件，必须在web应用程序的部署描述符中配置实现类；<br>HttpSessionActivationListener：绑定到会话的对象可以侦听容器事件，通知它们会话将被钝化，会话将被激活。需要一个在虚拟机之间迁移会话或持久会话的容器来通知所有绑定到实现该接口会话的属性。</p><h2 id="17-在java中重写方法应遵循规则的包括（）"><a href="#17-在java中重写方法应遵循规则的包括（）" class="headerlink" title="17.在java中重写方法应遵循规则的包括（）"></a>17.在java中重写方法应遵循规则的包括（）</h2><p>A.访问修饰符的限制一定要大于被重写方法的访问修饰符<br>B.可以有不同的访问修饰符<br>C.参数列表必须完全与被重写的方法相同<br>D.必须具有不同的参数列表</p><p><strong>答案：</strong><br>B C</p><p><strong>解析：</strong><br><strong>方法重写</strong></p><ul><li>参数列表必须完全与被重写方法的相同；</li><li>返回类型必须完全与被重写方法的返回类型相同；</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul><p><strong>方法重载</strong></p><ul><li>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><h2 id="18-What-might-cause-the-current-thread-to-stop-or-pause-executing"><a href="#18-What-might-cause-the-current-thread-to-stop-or-pause-executing" class="headerlink" title="18.What might cause the current thread to stop or pause executing"></a>18.What might cause the current thread to stop or pause executing</h2><p>A.An InterruptedException is thrown.<br>B.The thread executes a wait() call.<br>C.The thread constructs a new Thread.<br>D.A thread of higher priority becomes ready.<br>E.The thread executes a waitforID()call on a MediaTracker.</p><p><strong>答案：</strong><br>A B E</p><p><strong>解析：</strong><br>略</p><h2 id="19-下列说法错误的有（-）"><a href="#19-下列说法错误的有（-）" class="headerlink" title="19.下列说法错误的有（ ）"></a>19.下列说法错误的有（ ）</h2><p>A.Java面向对象语言容许单独的过程与函数存在<br>B.Java面向对象语言容许单独的方法存在<br>C.Java语言中的非静态方法属于类中的成员（member）<br>D.Java语言中的方法必定隶属于某一类（对象），调用方法与C语言的过程或C++语言的函数相同</p><p><strong>答案：</strong><br>A B C D</p><p><strong>解析：</strong><br>Java的静态方法属于类的成员，实例方法属于对象的成员。</p><h2 id="20-下列流当中，属于处理流的是：（）"><a href="#20-下列流当中，属于处理流的是：（）" class="headerlink" title="20.下列流当中，属于处理流的是：（）"></a>20.下列流当中，属于处理流的是：（）</h2><p>A.FilelnputStream<br>B.lnputStream<br>C.DatalnputStream<br>D.BufferedlnputStream</p><p><strong>答案：</strong><br>C D</p><p><strong>解析：</strong><br>此题考察对于java流的理解<br>节点流是实际工作的流，<br>处理流（我们叫包装流可能容易理解一点）设计的目的是让对流中数据的操作，转化成我们能更简单明了的看懂的数据（而不是二进制的字节等）的操作，但实际上增加了很多类，是io流变的更复杂<br>字节流必是一个接点流，字符流就是一个操作流<br>使用时，必须是有一个结点流，然后才能用操作流来包装结点流，即把结点流当参数传个操作流</p><blockquote><p>注：以上笔试题均来自网络，由笔者整理得出</p></blockquote><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">Java笔试内容集合</a> 欢迎关注，持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-f40a013aaaefba88?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（五）</title>
      <link href="/2019/09/19/interview/java/B-bishi06/"/>
      <url>/2019/09/19/interview/java/B-bishi06/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-8a182e3da5ea417e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（五）"></p><h2 id="1-以下关于Integer与int的区别错误的是？"><a href="#1-以下关于Integer与int的区别错误的是？" class="headerlink" title="1.以下关于Integer与int的区别错误的是？"></a>1.以下关于Integer与int的区别错误的是？</h2><p>A.int是java提供的8种原始数据类型之一<br>B.Integer是java为int提供的封装类<br>C.int的默认值为0<br>D.Integer的默认值为1</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>略</p><h2 id="2-给定以下方法声明，调用执行mystery（1234）的输出结果？"><a href="#2-给定以下方法声明，调用执行mystery（1234）的输出结果？" class="headerlink" title="2.给定以下方法声明，调用执行mystery（1234）的输出结果？"></a>2.给定以下方法声明，调用执行mystery（1234）的输出结果？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;precondition:  x &gt;&#x3D;0</span><br><span class="line">public void mystery (int x)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(x % 10);</span><br><span class="line"> </span><br><span class="line">if ((x &#x2F; 10) !&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">mystery(x &#x2F; 10);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(x % 10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.1441<br>B.43211234<br>C.3443<br>D.12344321</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>递归调用</p><h2 id="3-下面不是类及类成员的访问控制符的是-。（不考虑内部类的情况）"><a href="#3-下面不是类及类成员的访问控制符的是-。（不考虑内部类的情况）" class="headerlink" title="3.下面不是类及类成员的访问控制符的是( )。（不考虑内部类的情况）"></a>3.下面不是类及类成员的访问控制符的是( )。（不考虑内部类的情况）</h2><p>A.public<br>B.private<br>C.static<br>D.protected</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>类访问控制符只有三种：public ，private， protected  static和访问控制无关</p><h2 id="4-下列修饰符中与访问控制权限无关的是？（-）"><a href="#4-下列修饰符中与访问控制权限无关的是？（-）" class="headerlink" title="4.下列修饰符中与访问控制权限无关的是？（ ）"></a>4.下列修饰符中与访问控制权限无关的是？（ ）</h2><p>A.private<br>B.public<br>C.protected<br>D.final</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>private :        修饰私有变量<br>public :         修饰公有变量<br>protected:    修饰受保护变量<br>没有final, final用于保护变量不受改变</p><h2 id="5-局部变量能否和成员变量重名？"><a href="#5-局部变量能否和成员变量重名？" class="headerlink" title="5.局部变量能否和成员变量重名？"></a>5.局部变量能否和成员变量重名？</h2><p>A.可以，局部变量可以与成员变量重名，这时可用“this”来指向成员变量<br>B.可以，这时可用“local”关键字来指向局部变量<br>C.不能，局部变量不能与成员变量重名<br>D.不能，在一个类中不能有重名变量，不管是成员变量还是函数中的局部变量</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>JAVA访问变量采用就近原则，局部变量与成员变量重名时，局部变量比较近，使用局部变量</p><h2 id="6-下列说法正确的是"><a href="#6-下列说法正确的是" class="headerlink" title="6.下列说法正确的是()"></a>6.下列说法正确的是()</h2><p>A.在类方法中可用this来调用本类的类方法<br>B.在类方法中调用本类的类方法可直接调用<br>C.在类方法中只能调用本类的类方法<br>D.在类方法中绝对不能调用实例方法</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>在类方法中调用本类的类方法可直接调用。 实例方法也叫做对象方法。<br>类方法是属于整个类的，而实例方法是属于类的某个对象的。<br>由于类方法是属于整个类的，并不属于类的哪个对象，所以类方法的方法体中不能有与类的对象有关的内容。即类方法体有如下限制：<br>(1) 类方法中不能引用对象变量；<br>(2) 类方法中不能调用类的对象方法；<br>(3) 在类方法中不能使用super、this关键字。<br>(4)类方法不能被覆盖。<br>如果违反这些限制，就会导致程序编译错误。<br>与类方法相比，对象方法几乎没有什么限制：<br>(1) 对象方法中可以引用对象变量，也可以引用类变量；<br>(2) 对象方法中可以调用类方法；<br>(3) 对象方法中可以使用super、this关键字。</p><h2 id="7-关于依赖注入，下列选项中说法错误的是（）？"><a href="#7-关于依赖注入，下列选项中说法错误的是（）？" class="headerlink" title="7.关于依赖注入，下列选项中说法错误的是（）？"></a>7.关于依赖注入，下列选项中说法错误的是（）？</h2><p>A.依赖注入能够独立开发各组件，然后根据组件间关系进行组装<br>B.依赖注入提供使用接口编程<br>C.依赖注入使组件之间相互依赖，相互制约<br>D.依赖注入指对象在使用时动态注入</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>依赖注入目的是减少组件之间的耦合度，使开发变得简单。</p><h2 id="8-运行下面代码，输出的结果是（）"><a href="#8-运行下面代码，输出的结果是（）" class="headerlink" title="8.运行下面代码，输出的结果是（）"></a>8.运行下面代码，输出的结果是（）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public A() &#123;</span><br><span class="line">        System.out.println(&quot;class A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; System.out.println(&quot;I&#39;m A class&quot;); &#125;</span><br><span class="line">    static &#123; System.out.println(&quot;class A static&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class B extends A &#123;</span><br><span class="line">    public B() &#123;</span><br><span class="line">        System.out.println(&quot;class B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; System.out.println(&quot;I&#39;m B class&quot;); &#125;</span><br><span class="line">    static &#123; System.out.println(&quot;class B static&quot;); &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> new B();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static </span><br><span class="line">class B static </span><br><span class="line">I&#39;m A class </span><br><span class="line">class A</span><br><span class="line">I&#39;m B class </span><br><span class="line">class B</span><br></pre></td></tr></table></figure><p>B.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static</span><br><span class="line">I&#39;m A class</span><br><span class="line">class A</span><br><span class="line">class B static</span><br><span class="line">I&#39;m B class</span><br><span class="line">class B</span><br></pre></td></tr></table></figure><p>C.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static</span><br><span class="line">class B static</span><br><span class="line">class A</span><br><span class="line">I&#39;m A class </span><br><span class="line">class B</span><br><span class="line">I&#39;m B class</span><br></pre></td></tr></table></figure><p>D.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static</span><br><span class="line">class A</span><br><span class="line">I&#39;m A class</span><br><span class="line">class B static</span><br><span class="line">class B</span><br><span class="line">I&#39;m B class</span><br></pre></td></tr></table></figure><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>此题考虑 Java 中构造器、初始化块、静态初始化块的执行顺序。</p><p>静态初始化块 &gt; 初始化块 &gt; 构造器<br>父类 &gt; 子类<br>综合下来顺序就是：</p><p>父类静态初始化块<br>子类静态初始化块<br>父类初始化块<br>父类构造器<br>子类初始化块<br>子类构造器<br>需要注意静态初始化块是在类第一次加载的时候就会进行初始化。</p><h2 id="9-下面哪个标识符是合法的？"><a href="#9-下面哪个标识符是合法的？" class="headerlink" title="9.下面哪个标识符是合法的？"></a>9.下面哪个标识符是合法的？</h2><p>A.”9HelloWorld”<br>B.”_Hello World”<br>C.”Hello*World”<br>D.”Hello$World”</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>标识符是以字母开头的字母数字序列：<br>数字是指0~9，字母指大小写英文字母、下划线（_)和美元符号（$），也可以是Unicode字符集中的字符，如汉字；<br>字母、数字等字符的任意组合，不能包含+、- <em>等字符；<br>不能使用关键字；<br>大小写敏感<br>由此可以看出：<br>A：不可以数字开头<br>B：用下划线开头符合，但是中间有空格<br>C:不能包含“</em>”<br>排除ABC，答案即是D</p><h2 id="10-以下程序执行的结果是："><a href="#10-以下程序执行的结果是：" class="headerlink" title="10.以下程序执行的结果是："></a>10.以下程序执行的结果是：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class X&#123;</span><br><span class="line">    Y y&#x3D;new Y();</span><br><span class="line">    public X()&#123;</span><br><span class="line">        System.out.print(&quot;X&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Y&#123;</span><br><span class="line">    public Y()&#123;</span><br><span class="line">        System.out.print(&quot;Y&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Z extends X&#123;</span><br><span class="line">    Y y&#x3D;new Y();</span><br><span class="line">    public Z()&#123;</span><br><span class="line">        System.out.print(&quot;Z&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Z();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.ZYXX<br>B.ZYXY<br>C.YXYZ<br>D.XYZX</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>1.父类静态代码块 （java虚拟机加载类时，就会执行该块代码，故只执行一次）<br>2 .子类静态代码块 （java虚拟机加载类时，就会执行该块代码，故只执行一次）<br>3. 父类属性对象初始化<br>4.父类普通代码块（每次new,每次执行 ）<br>5. 父类构造函数（每次new,每次执行）<br>6.子 类 属性对象初始化<br>7.子类普通代码块（每次new,每次执行 ）<br>8.子 类构造函数（每次new,每次执行）</p><h2 id="11-以下声明合法的是"><a href="#11-以下声明合法的是" class="headerlink" title="11.以下声明合法的是"></a>11.以下声明合法的是</h2><p>A.default  String  s<br>B.public  final  static  native  int  w( )<br>C.abstract  double  d<br>D.abstract  final  double  hyperbolicCosine( )</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>A：java的访问权限有public、protected、private和default的，default不能修饰变量<br>C：普通变量不能用abstract修饰，abstract一般修饰方法和类<br>D：被定义为abstract的类需要被子类继承，但是被修饰为final的类是不能被继承和改写的心存疑问可以实验一下，看是否能通过编译.</p><h2 id="12-java用（）机制实现了进程之间的同步执行"><a href="#12-java用（）机制实现了进程之间的同步执行" class="headerlink" title="12.java用（）机制实现了进程之间的同步执行"></a>12.java用（）机制实现了进程之间的同步执行</h2><p>A.虚拟机<br>B.多个CPU<br>C.异步调用<br>D.监视器</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>同步执行，需要监视器，即锁。</p><h2 id="13-What-is-displayed-when-the-following-is-executed"><a href="#13-What-is-displayed-when-the-following-is-executed" class="headerlink" title="13.What is displayed when the following is executed;"></a>13.What is displayed when the following is executed;</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double d1&#x3D;-0.5;</span><br><span class="line">System.out.println(&quot;Ceil d1&#x3D;&quot;+Math.ceil(d1));</span><br><span class="line">System.out.println(&quot;floor d1&#x3D;&quot;+Math.floor(d1));</span><br></pre></td></tr></table></figure><p>A.Ceil d1=-0.0   floor d1=-1.0<br>B.Ceil d1=0.0    floor d1=-1.0<br>C.Ceil d1=-0.0  floor d1=-0.0<br>D.Ceil d1=0.0   floor d1=0.0<br>E.Ceil d1=0     floor d1=-1</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong></p><h2 id="14-有关下述Java代码描述正确的选项是-。"><a href="#14-有关下述Java代码描述正确的选项是-。" class="headerlink" title="14.有关下述Java代码描述正确的选项是____。"></a>14.有关下述Java代码描述正确的选项是____。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line">   private static void testMethod()&#123;</span><br><span class="line">        System.out.println(&quot;testMethod&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">        ((TestClass)null).testMethod();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.编译不通过<br>B.编译通过，运行异常，报NullPointerException<br>C.编译通过，运行异常，报IllegalArgumentException<br>D.编译通过，运行异常，报NoSuchMethodException<br>E.编译通过，运行异常，报Exception<br>F.运行正常，输出testMethod</p><p><strong>答案：</strong><br>F</p><p><strong>解析：</strong><br>1）此处是类对方法的调用，不是对象对方法的调用。<br>2）方法是static静态方法，直接使用”类.方法”即可，因为静态方法使用不依赖对象是否被创建。null可以被强制类型转换成任意类型（不是任意类型对象），于是可以通过它来执行静态方法。<br>3）非静态的方法用”对象.方法”的方式，必须依赖对象被创建后才能使用，若将testMethod()方法前的static去掉，则会报 空指针异常 。此处也验证了2）的观点<br>当然，不管是否静态方法，都是已经存在的，只是访问方式不同。</p><h2 id="15-下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持："><a href="#15-下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持：" class="headerlink" title="15.下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持：()"></a>15.下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持：()</h2><p>A.java.util.ConcurrentHashMap<br>B.java.util.Map<br>C.java.util.TreeMap<br>D.java.util.SortMap<br>E.java.util.Hashtable<br>F.java.util.HashMap</p><p><strong>答案：</strong><br>A E</p><p><strong>解析：</strong></p><ul><li>ConcurrentHashMap简称CHM,CHM 允许并发的读和线程安全的更新操作。在执行写操作时，CHM 只锁住部分的 Map，并发的更新是通过内部根据并发级别将 Map 分割成小部分实现的，高的并发级别会造成时间和空间的浪费，低的并发级别在写线程多时会引起线程间的竞争，CHM 的所有操作都是线程安全，CHM 返回的迭代器是弱一致性， fail-safe 并且不会抛出ConcurrentModificationException 异常，CHM不允许null的键值。可以使用 CHM 代替 HashTable，但要记住 CHM 不会锁住整个 Map</li><li>除了Hashtable，其他是非线性安全的。</li></ul><h2 id="16-JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是："><a href="#16-JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是：" class="headerlink" title="16.JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是：( )"></a>16.JavaWEB中有一个类，当会话种邦定了属性或者删除了属性时，他会得到通知，这个类是：( )</h2><p>A.HttpSessionAttributeListener<br>B.HttpSessionBindingListener<br>C.HttpSessionObjectListener<br>D.HttpSessionListener;<br>E.HttpSession<br>F.HttpSessionActivationListener</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>HttpSessionAttributeListener：可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知；<br>HttpSessionBindingListener：当该对象从一个会话中被绑定或者解绑时通知该对象，这个对象由HttpSessionBindingEvent对象通知。这可能是servlet程序显式地从会话中解绑定属性的结果，可能是由于会话无效，也可能是由于会话超时；<br>HttpSessionObjectListener：没有该接口API；<br>HttpSessionListener：当web应用程序中的活动会话列表发生更改时通知该接口的实现类，为了接收该通知事件，必须在web应用程序的部署描述符中配置实现类；<br>HttpSessionActivationListener：绑定到会话的对象可以侦听容器事件，通知它们会话将被钝化，会话将被激活。需要一个在虚拟机之间迁移会话或持久会话的容器来通知所有绑定到实现该接口会话的属性。</p><h2 id="17-在java中重写方法应遵循规则的包括（）"><a href="#17-在java中重写方法应遵循规则的包括（）" class="headerlink" title="17.在java中重写方法应遵循规则的包括（）"></a>17.在java中重写方法应遵循规则的包括（）</h2><p>A.访问修饰符的限制一定要大于被重写方法的访问修饰符<br>B.可以有不同的访问修饰符<br>C.参数列表必须完全与被重写的方法相同<br>D.必须具有不同的参数列表</p><p><strong>答案：</strong><br>B C</p><p><strong>解析：</strong><br><strong>方法重写</strong></p><ul><li>参数列表必须完全与被重写方法的相同；</li><li>返回类型必须完全与被重写方法的返回类型相同；</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul><p><strong>方法重载</strong></p><ul><li>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><h2 id="18-What-might-cause-the-current-thread-to-stop-or-pause-executing"><a href="#18-What-might-cause-the-current-thread-to-stop-or-pause-executing" class="headerlink" title="18.What might cause the current thread to stop or pause executing"></a>18.What might cause the current thread to stop or pause executing</h2><p>A.An InterruptedException is thrown.<br>B.The thread executes a wait() call.<br>C.The thread constructs a new Thread.<br>D.A thread of higher priority becomes ready.<br>E.The thread executes a waitforID()call on a MediaTracker.</p><p><strong>答案：</strong><br>A B E</p><p><strong>解析：</strong><br>略</p><h2 id="19-下列说法错误的有（-）"><a href="#19-下列说法错误的有（-）" class="headerlink" title="19.下列说法错误的有（ ）"></a>19.下列说法错误的有（ ）</h2><p>A.Java面向对象语言容许单独的过程与函数存在<br>B.Java面向对象语言容许单独的方法存在<br>C.Java语言中的非静态方法属于类中的成员（member）<br>D.Java语言中的方法必定隶属于某一类（对象），调用方法与C语言的过程或C++语言的函数相同</p><p><strong>答案：</strong><br>A B C D</p><p><strong>解析：</strong><br>Java的静态方法属于类的成员，实例方法属于对象的成员。</p><h2 id="20-下列流当中，属于处理流的是：（）"><a href="#20-下列流当中，属于处理流的是：（）" class="headerlink" title="20.下列流当中，属于处理流的是：（）"></a>20.下列流当中，属于处理流的是：（）</h2><p>A.FilelnputStream<br>B.lnputStream<br>C.DatalnputStream<br>D.BufferedlnputStream</p><p><strong>答案：</strong><br>C D</p><p><strong>解析：</strong><br>此题考察对于java流的理解<br>节点流是实际工作的流，<br>处理流（我们叫包装流可能容易理解一点）设计的目的是让对流中数据的操作，转化成我们能更简单明了的看懂的数据（而不是二进制的字节等）的操作，但实际上增加了很多类，是io流变的更复杂<br>字节流必是一个接点流，字符流就是一个操作流<br>使用时，必须是有一个结点流，然后才能用操作流来包装结点流，即把结点流当参数传个操作流</p><blockquote><p>注：以上笔试题均来自网络，由笔者整理得出</p></blockquote><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">Java笔试内容集合</a> 欢迎关注，持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-f40a013aaaefba88?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（四）</title>
      <link href="/2019/09/18/interview/java/B-bishi04/"/>
      <url>/2019/09/18/interview/java/B-bishi04/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-05e294342b1b1794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（四）"></p><h2 id="1-编译Java-Application-源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为-。"><a href="#1-编译Java-Application-源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为-。" class="headerlink" title="1.编译Java  Application 源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为(      )。"></a>1.编译Java  Application 源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为(      )。</h2><p>A.java<br>B.class<br>C.html<br>D.exe</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>Java源程序的后缀名为“.java”,经过编译之后生成的字节码文件后缀名为“.class”</p><h2 id="2-问以下哪个说法是正确的？（）"><a href="#2-问以下哪个说法是正确的？（）" class="headerlink" title="2. 问以下哪个说法是正确的？（）"></a>2. 问以下哪个说法是正确的？（）</h2><p>A 派生出子类 B, B 派生出子类 C,并且在 java 源代码有如下声明：</p><ol><li>A a0=new A();</li><li>A a1=new B();</li><li>A a2=new C();</li></ol><p>A.只有第一行能通过编译<br>B.第1、2行能通过编译，但第3行编译出错<br>C.第1、2、3行能通过编译，但第2、3行运行时出错<br>D.第1行，第2行和第3行的声明都是正确的</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>这个题考了两个点：</p><ol><li>继承的传递性。</li><li>多态，父类引用指向子类对象。 </li></ol><h2 id="3-以下哪个接口的定义是正确的？（-）"><a href="#3-以下哪个接口的定义是正确的？（-）" class="headerlink" title="3.以下哪个接口的定义是正确的？（ ）"></a>3.以下哪个接口的定义是正确的？（ ）</h2><p>A.interface  B{  void print()  {  } ;}<br>B.interface  B{ static void print() ;}<br>C.abstract  interface  B  extends  A1, A2  //A1、A2为已定义的接口{ abstract  void  print(){  };}<br>D.interface  B{  void  print();}</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>A，接口中方法的默认修饰符时public abstract，抽象方法可是没有方法体的，没有大括号{}<br>B，JDK8中，接口中的方法可以被default和static修饰，但是！！！被修饰的方法必须有方法体。<br>C，注意一下，接口是可以多继承的。整个没毛病，和A选项一样，抽象方法不能有方法体 </p><h2 id="4-以下会产生信息丢失的类型转换是-）"><a href="#4-以下会产生信息丢失的类型转换是-）" class="headerlink" title="4.以下会产生信息丢失的类型转换是( ）"></a>4.以下会产生信息丢失的类型转换是( ）</h2><p>A.float  a=10<br>B.int a=（int）8846.0<br>C.byte  a=10； int b=-a<br>D.double d=100</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>会产生信息丢失不如说<strong>丢失精度</strong>，这样可能更容易明白，而精度丢失只会发生在从大范围到小范围的转换。上面四个选项，只有 B 是从 double 到 int ，也就是从大范围到小范围。</p><h2 id="5-以下代码的输出的正确结果是"><a href="#5-以下代码的输出的正确结果是" class="headerlink" title="5.以下代码的输出的正确结果是"></a>5.以下代码的输出的正确结果是</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">String s &#x3D; &quot;祝你考出好成绩！&quot;;</span><br><span class="line">System.out.println(s.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.24<br>B.16<br>C.15<br>D.8</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>java的String底层是char数组，它的length()返回数组大小，而unicode中一个汉字是可以用一个char表示的。 一个汉字等于一个字符字符是char，一个汉字也等于二个字节，字节是byte。</p><h2 id="6-java中，StringBuilder和StringBuffer的区别，下面说法错误的是？"><a href="#6-java中，StringBuilder和StringBuffer的区别，下面说法错误的是？" class="headerlink" title="6.java中，StringBuilder和StringBuffer的区别，下面说法错误的是？"></a>6.java中，StringBuilder和StringBuffer的区别，下面说法错误的是？</h2><p>A.StringBuffer是线程安全的<br>B.StringBuilder是非线程安全的<br>C.StringBuffer对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。<br>D.效率比较String&lt;StringBuffer&lt;StringBuilder，但是在 String S1 = “This is only a” + “ simple” + “ test”时，String效率最高。</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>效率：String(大姐，出生于JDK1.0时代) 不可变字符序列&lt;StringBuffer(二姐，出生于JDK1.0时代)  线程安全的可变字符序列&lt;StringBuilder(小妹，出生于JDK1.5时代) 非线程安全的可变字符序列。Java中的String是一个类，而并非基本数据类型。string是值传入，不是引用传入。StringBuffer和StringBuilder可以算是双胞胎了，这两者的方法没有很大区别。但在线程安全性方面，StringBuffer允许多线程进行字符操作。这是因为在源代码中StringBuffer的很多方法都被关键字synchronized修饰了，而StringBuilder没有。StringBuilder的效率比StringBuffer稍高，如果不考虑线程安全，StringBuilder应该是首选。<strong>另外，JVM运行程序主要的时间耗费是在创建对象和回收对象上。</strong><br>关于D:因为进行字符串加运算时实际上是在堆中开辟大量空间，为了避免资源耗尽java编译器自动将String变量变为StringBulider而后进行append处理。</p><h2 id="7-下列关于修饰符混用的说法，错误的是"><a href="#7-下列关于修饰符混用的说法，错误的是" class="headerlink" title="7.下列关于修饰符混用的说法，错误的是( )"></a>7.下列关于修饰符混用的说法，错误的是( )</h2><p>A.abstract不能与final并列修饰同一个类<br>B.abstract类中不应该有private的成员<br>C.abstract方法必须在abstract类或接口中<br>D.static方法中能直接调用类里的非static的属性</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>1、abstract不能与final并列修饰同一个类  对的。<br>2、abstract类中不应该有private的成员  对的    ：abstract类中可以有private 但是不应该有。<br>3、abstract方法必须在abstract类或接口中  对的   ： 若类中方法有abstract修饰的，该类必须abstract修改。接口方法默认public abstract。<br>4、static方法中能处理非static的属性  错误  ：在JVM中static方法在静态区，静态区无法调用非静态区属性。</p><h2 id="8-如下语句通过算术运算和逻辑运算之后i和-j的结果是（-）"><a href="#8-如下语句通过算术运算和逻辑运算之后i和-j的结果是（-）" class="headerlink" title="8.如下语句通过算术运算和逻辑运算之后i和 j的结果是（ ）"></a>8.如下语句通过算术运算和逻辑运算之后i和 j的结果是（ ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i&#x3D;0;</span><br><span class="line">int j&#x3D;0;</span><br><span class="line">if((++i&gt;0)||(++j&gt;0))&#123;</span><br><span class="line">&#x2F;&#x2F;打印出i和j的值。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.i=0;j=0<br>B.i=1;j=1<br>C.i=0;j=1<br>D.i=1;j=0</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>考察的是短路逻辑的用法，即：当第一个逻辑表达式可以确定结果时，将不再进行剩余表达式的运算。</p><h2 id="9-以下是java-concurrent包下的4个类，选出差别最大的一个"><a href="#9-以下是java-concurrent包下的4个类，选出差别最大的一个" class="headerlink" title="9.以下是java concurrent包下的4个类，选出差别最大的一个"></a>9.以下是java concurrent包下的4个类，选出差别最大的一个</h2><p>A.Semaphore<br>B.ReentrantLock<br>C.Future<br>D.CountDownLatch</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>A、Semaphore：类，控制某个资源可被同时访问的个数;<br>B、ReentrantLock：类，具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大；<br>C、Future：接口，表示异步计算的结果；<br>D、CountDownLatch： 类，可以用来在一个线程中等待多个线程完成任务的类。</p><h2 id="10-下面有关java实例变量-局部变量-类变量和final变量的说法，错误的是？"><a href="#10-下面有关java实例变量-局部变量-类变量和final变量的说法，错误的是？" class="headerlink" title="10.下面有关java实例变量,局部变量,类变量和final变量的说法，错误的是？"></a>10.下面有关java实例变量,局部变量,类变量和final变量的说法，错误的是？</h2><p>A.实例变量指的是类中定义的变量，即成员变量，如果没有初始化，会有默认值。<br>B.局部变量指的是在方法中定义的变量，如果没有初始化，会有默认值<br>C.类变量指的是用static修饰的属性<br>D.final变量指的是用final 修饰的变量</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>B.定义在类中的变量是类的成员变量，可以不进行初始化，Java会自动进行初始化，如果是引用类型默认初始化为null,如果是基本类型例如int则会默认初始化为0<br>局部变量是定义在方法中的变量，必须要进行初始化。<br>被static关键字修饰的变量是静态的，静态变量随着类的加载而加载，所以也被称为类变量<br>被final修饰的变量是常量</p><h2 id="11-关于JAVA的垃圾回收机制，下面哪些结论是正确？"><a href="#11-关于JAVA的垃圾回收机制，下面哪些结论是正确？" class="headerlink" title="11.关于JAVA的垃圾回收机制，下面哪些结论是正确？"></a>11.关于JAVA的垃圾回收机制，下面哪些结论是正确？</h2><p>A.程序可以任意指定释放内存的时间<br>B.JAVA程序不能依赖于垃圾回收的时间或者顺序<br>C.程序可明确地标识某个局部变量的引用不再被使用<br>D.程序可以显式地立即释放对象占有的内存</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。当对象的引用变量被赋值为null，可能被当成垃圾。</p><h2 id="12-JSP分页代码中，哪个步骤次序是正确的？"><a href="#12-JSP分页代码中，哪个步骤次序是正确的？" class="headerlink" title="12.JSP分页代码中，哪个步骤次序是正确的？"></a>12.JSP分页代码中，哪个步骤次序是正确的？</h2><p>A.先取总记录数，得到总页数，最后显示本页的数据。<br>B.先取所有的记录，得到总页数，再取总记录数，最后显示本页的数据。<br>C.先取总页数，得到总记录数，再取所有的记录，最后显示本页的数据。<br>D.先取本页的数据，得到总页数，再取总记录数，最后显示所有的记录。</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>1、count(*)得到总记录数<br>2、计算总页数<br>3、获取所有记录(个人感觉这一步不需要，可以直接获取指定页数数据)<br>4、过滤显示本页数据</p><h2 id="13-关于访问权限说法正确的是-？"><a href="#13-关于访问权限说法正确的是-？" class="headerlink" title="13.关于访问权限说法正确的是 ？ ( )"></a>13.关于访问权限说法正确的是 ？ ( )</h2><p>A.外部类前面可以修饰public,protected和private<br>B.成员内部类前面可以修饰public,protected和private<br>C.局部内部类前面可以修饰public,protected和private<br>D.以上说法都不正确</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>(1)对于外部类而言，它也可以使用访问控制符修饰，但外部类只能有两种访问控制级别：public和默认。因为外部类没有处于任何类的内部，也就没有其所在类的内部、所在类的子类两个范围，因此 private 和 protected 访问控制符对外部类没有意义。<br>(2)内部类的上一级程序单元是外部类，它具有 4 个作用域：同一个类（ private ）、同一个包（ protected ）和任何位置（ public ）。<br>(3)因为局部成员的作用域是所在方法，其他程序单元永远不可能访问另一个方法中的局部变量，所以所有的局部成员都不能使用访问控制修饰符修饰。</p><h2 id="14-以下代码执行的结果显示是多少（-）？"><a href="#14-以下代码执行的结果显示是多少（-）？" class="headerlink" title="14.以下代码执行的结果显示是多少（ ）？"></a>14.以下代码执行的结果显示是多少（ ）？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123; </span><br><span class="line">class Super&#123;  </span><br><span class="line"> int flag&#x3D;1;</span><br><span class="line">         Super()&#123;</span><br><span class="line">             test();</span><br><span class="line">         &#125;  </span><br><span class="line"> void test()&#123;</span><br><span class="line">            System.out.println(&quot;Super.test() flag&#x3D;&quot;+flag);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125; </span><br><span class="line">class Sub extends Super&#123;</span><br><span class="line">        Sub(int i)&#123;  </span><br><span class="line">flag&#x3D;i;</span><br><span class="line">            System.out.println(&quot;Sub.Sub()flag&#x3D;&quot;+flag);</span><br><span class="line">        &#125;  </span><br><span class="line">void test()&#123;</span><br><span class="line">            System.out.println(&quot;Sub.test()flag&#x3D;&quot;+flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">public static void main(String[] args) &#123;  </span><br><span class="line">new Demo().new Sub(5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.Sub.test() flag=1,Sub.Sub() flag=5<br>B.Sub.Sub() flag=5,Sub.test() flag=5<br>C.Sub.test() flag=0,Sub.Sub() flag=5<br>D.Super.test() flag=1,Sub.Sub() flag=5</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong></p><p>在继承中代码的执行顺序为：<br>1.父类静态对象，父类静态代码块<br>2.子类静态对象，子类静态代码块<br>3.父类非静态对象，父类非静态代码块<br>4.父类构造函数<br>5.子类非静态对象，子类非静态代码块<br>6.子类构造函数<br>对于本题来说：在只想new Sub(5)的时候，父类先初始化了int flag=1，然后执行父类的构造函数Super（），父类构造函数中执行的test（）方法，因子类是重写了test（）方法的，因此父类构造函数中的test（）方法实际执行的是子类的test（）方法，所以输出为Sub.test() flag=1，接着执行子类构造函数Sub(5) 将flag赋值为5，因此输出结果Sub.Sub() flag=5。最终选择了A。</p><h2 id="15-Java多线程有几种实现方法？"><a href="#15-Java多线程有几种实现方法？" class="headerlink" title="15.Java多线程有几种实现方法？"></a>15.Java多线程有几种实现方法？</h2><p>A.继承Thread类<br>B.实现Runnable接口<br>C.实现Thread接口<br>D.以上都不正确</p><p><strong>答案：</strong><br>AB</p><p><strong>解析：</strong><br>AB.<br>多线程一共有三种实现方式<br>方式1：继承Thread类，并重写run()方法<br>方式2：实现Runnable接口，实现run()方法<br>方式3：实现Callable接口，线程结束后可以有返回值，但是该方式是依赖于线程池的。</p><h2 id="16-在Jdk1-7中，下述说法中抽象类与接口的区别与联系正确的有哪些？"><a href="#16-在Jdk1-7中，下述说法中抽象类与接口的区别与联系正确的有哪些？" class="headerlink" title="16.在Jdk1.7中，下述说法中抽象类与接口的区别与联系正确的有哪些？"></a>16.在Jdk1.7中，下述说法中抽象类与接口的区别与联系正确的有哪些？</h2><p>A.抽象类中可以有普通成员变量，接口中没有普通成员变量。<br>B.抽象类和接口中都可以包含静态成员常量。<br>C.一个类可以实现多个接口，但只能继承一个抽象类<br>D.抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法。</p><p><strong>答案：</strong><br>A B C D </p><p><strong>解析：</strong><br>总结一下</p><ol><li>一个子类只能继承一个抽象类,但能实现多个接口</li><li>抽象类可以有构造方法,接口没有构造方法</li><li>抽象类可以有普通成员变量,接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意,接口只能public static final(默认)</li><li>抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法</li><li>抽象类可以有静态方法,接口不能有静态方法</li><li>抽象类中的方法可以是public、protected;接口方法只有public </li></ol><h2 id="17-根据下面这个程序的内容，判断哪些描述是正确的：（-）"><a href="#17-根据下面这个程序的内容，判断哪些描述是正确的：（-）" class="headerlink" title="17.根据下面这个程序的内容，判断哪些描述是正确的：（ ）"></a>17.根据下面这个程序的内容，判断哪些描述是正确的：（ ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">String s &#x3D; &quot;tommy&quot;;</span><br><span class="line">Object o &#x3D; s;</span><br><span class="line">sayHello(o); &#x2F;&#x2F;语句1</span><br><span class="line">sayHello(s); &#x2F;&#x2F;语句2</span><br><span class="line">&#125;</span><br><span class="line">public static void sayHello(String to) &#123;</span><br><span class="line">System.out.println(String.format(&quot;Hello, %s&quot;, to));</span><br><span class="line">&#125;</span><br><span class="line">public static void sayHello(Object to) &#123;</span><br><span class="line">System.out.println(String.format(&quot;Welcome, %s&quot;, to));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.这段程序有编译错误<br>B.语句1输出为:Hello, tommy<br>C.语句2输出为:Hello, tommy<br>D.语句1输出为:Welcome, tommy<br>E.语句2输出为:Welcome, tommy<br>F.根据选用的Java编译器不同，这段程序的输出可能不同</p><p><strong>答案：</strong><br>CD</p><p><strong>解析：</strong><br>略</p><h2 id="18-Java特性中-abstract-class和interface有什么区别（）"><a href="#18-Java特性中-abstract-class和interface有什么区别（）" class="headerlink" title="18.Java特性中,abstract class和interface有什么区别（）"></a>18.Java特性中,abstract class和interface有什么区别（）</h2><p>A.抽象类可以有构造方法，接口中不能有构造方法<br>B.抽象类中可以有普通成员变量，接口中没有普通成员变量<br>C.抽象类中不可以包含静态方法，接口中可以包含静态方法<br>D.一个类可以实现多个接口，但只能继承一个抽象类。</p><p><strong>答案：</strong><br>A B D</p><p><strong>解析：</strong><br>接口中的成员变量被隐式的声明为public static final ，jdk1.8后接口中可以有静态方法而且存在方法体</p><h2 id="19-关于下面代码片段叙述正确的是（）"><a href="#19-关于下面代码片段叙述正确的是（）" class="headerlink" title="19.关于下面代码片段叙述正确的是（）"></a>19.关于下面代码片段叙述正确的是（）</h2><p>代码片段：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byte b1&#x3D;1,b2&#x3D;2,b3,b6; </span><br><span class="line">final byte b4&#x3D;4,b5&#x3D;6; </span><br><span class="line">b6&#x3D;b4+b5; </span><br><span class="line">b3&#x3D;(b1+b2); </span><br><span class="line">System.out.println(b3+b6);</span><br></pre></td></tr></table></figure><p>A.输出结果：13<br>B.语句：b6=b4+b5编译出错<br>C.语句：b3=b1+b2编译出错<br>D.运行期抛出异常</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>C.被final修饰的变量是常量，这里的b6=b4+b5可以看成是b6=10；在编译时就已经变为b6=10了。而b1和b2是byte类型，java中进行计算时候将他们提升为int类型，再进行计算，b1+b2计算后已经是int类型，赋值给b3，b3是byte类型，类型不匹配，编译不会通过，需要进行强制转换。Java中的byte，short，char进行计算时都会提升为int类型。 </p><h2 id="20-下列那些方法是线程安全的-所调用的方法都存在"><a href="#20-下列那些方法是线程安全的-所调用的方法都存在" class="headerlink" title="20.下列那些方法是线程安全的(所调用的方法都存在)"></a>20.下列那些方法是线程安全的(所调用的方法都存在)</h2><p>A.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyServlet implements Servlet &#123;</span><br><span class="line">public void service (ServletRequest req, ServletResponse resp) &#123;</span><br><span class="line">BigInteger I &#x3D; extractFromRequest(req);</span><br><span class="line">encodeIntoResponse(resp,factors);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyServlet implements Servlet &#123;</span><br><span class="line">private long count &#x3D;0;</span><br><span class="line">public long getCount() &#123;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line">public void service (ServletRequest req, ServletResponse resp) &#123;</span><br><span class="line">BigInteger I &#x3D; extractFromRequest(req);</span><br><span class="line">BigInteger[] factors &#x3D; factor(i);</span><br><span class="line">count ++;</span><br><span class="line">encodeIntoResponse(resp,factors);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyClass &#123;</span><br><span class="line">private int value;</span><br><span class="line">public synchronized int get() &#123;</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">public synchronized void set (int value) &#123;</span><br><span class="line">this.value &#x3D; value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>D.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Factorizer implements Servlet &#123;</span><br><span class="line">private volatile MyCache cache &#x3D; new MyCache(null,null);</span><br><span class="line"></span><br><span class="line">public void service(ServletRequest req, ServletResponse resp) &#123;</span><br><span class="line">BigInteger i &#x3D; extractFromRequest(req);</span><br><span class="line">BigInteger[] factors &#x3D; cache.getFactors(i);</span><br><span class="line">if (factors &#x3D;&#x3D; null) &#123;</span><br><span class="line">factors &#x3D; factor(i);</span><br><span class="line">cache &#x3D; new MyCache(i,factors);</span><br><span class="line">&#125;</span><br><span class="line">encodeIntoResponse(resp,factors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案：</strong><br>A C D</p><p><strong>解析：</strong><br>A：没有成员（没有共享资源），线程安全；<br>B：假设存在线程1和线程2，count初始值为0，当线程1执行count++中count+1（此时未写回最终计算值），这时线程2执行count++中读取count，发生数据错误，导致线程1线程2的结果都为1，而不是线程1的结果为1，线程2的结果为2，线程不安全；<br>C：成员私有，对成员的set get方法都加重量级锁，线程安全； D：volatile有两个作用：可见性（volatile变量的改变能使其他线程立即可见，但它不是线程安全的，参考B）和禁止重排序；这里是可见性的应用，类中方法对volatile修饰的变量只有赋值，线程安全； 欢迎指正。 </p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">笔试内容集合</a> 持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-68883ebbbccb6b4f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（三）</title>
      <link href="/2019/09/17/interview/java/B-bishi03/"/>
      <url>/2019/09/17/interview/java/B-bishi03/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-f8e19f0c0785f2e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（三）"></p><h2 id="1-下列InputStream类中哪个方法可以用于关闭流？"><a href="#1-下列InputStream类中哪个方法可以用于关闭流？" class="headerlink" title="1.下列InputStream类中哪个方法可以用于关闭流？"></a>1.下列InputStream类中哪个方法可以用于关闭流？</h2><p>A.skip（）<br>B.close（）<br>C.mark（）<br>D.reset（）</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>inputstream的close方法用来关闭流<br>skip()用来跳过一些字节<br>mark（）用来标记流<br>reset（）复位流 </p><h2 id="2-下面语句正确的是（）"><a href="#2-下面语句正确的是（）" class="headerlink" title="2.下面语句正确的是（）"></a>2.下面语句正确的是（）</h2><p>A.x+1=5<br>B.i++=1<br>C.a++b=1<br>D.x+=1</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>选D，+=，-=，*=，/=最常见。<br>ABC都编译错误。</p><h2 id="3-下面关于继承的描述正确的是？"><a href="#3-下面关于继承的描述正确的是？" class="headerlink" title="3.下面关于继承的描述正确的是？"></a>3.下面关于继承的描述正确的是？</h2><p>A.在Java中只允许单一继承<br>B.在Java中一个类只能实现一个接口<br>C.在Java中一个类不能同时继承一个类和实现一个接口<br>D.Java的单一继承使代码不可靠</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>略</p><h2 id="4-下列哪种说法是正确的？"><a href="#4-下列哪种说法是正确的？" class="headerlink" title="4.下列哪种说法是正确的？"></a>4.下列哪种说法是正确的？</h2><p>A.实例方法可直接调用超类的实例方法<br>B.实例方法可直接调用超类的类方法<br>C.实例方法可直接调用本类的类方法<br>D.实例方法可直接调用其他类的实例方法</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>a.实例方法可以调用超类公有实例方法<br>b.实例方法可以直接调用超类的公有类方法<br>d.实例方法可以通过类名调用其他类的类方法 </p><h2 id="5-A派生出子类B，B派生出子类C，并且在java源代码中有如下声明："><a href="#5-A派生出子类B，B派生出子类C，并且在java源代码中有如下声明：" class="headerlink" title="5.A派生出子类B，B派生出子类C，并且在java源代码中有如下声明："></a>5.A派生出子类B，B派生出子类C，并且在java源代码中有如下声明：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.A a0&#x3D;new A();</span><br><span class="line">2.A a1&#x3D;new B();</span><br><span class="line">3.A a2&#x3D;new C();</span><br></pre></td></tr></table></figure><p>以下哪个说法是正确的？ </p><p>A.第1行,第2行和第3行的声明都是正确的<br>B.第1,2,3行都能通过编译，但第2,3行运行时出错<br>C.第1,2行能通过编译，但第3行编译出错<br>D.只有第1行能通过编译</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>一句话 向上转型是无条件的 </p><h2 id="6-java中，静态变量static在不同线程的不同实例中地址是否一样？他们储存在什么区域？（）"><a href="#6-java中，静态变量static在不同线程的不同实例中地址是否一样？他们储存在什么区域？（）" class="headerlink" title="6.java中，静态变量static在不同线程的不同实例中地址是否一样？他们储存在什么区域？（）"></a>6.java中，静态变量static在不同线程的不同实例中地址是否一样？他们储存在什么区域？（）</h2><p>A.地址一样，在堆栈区。<br>B.地址不一样，在堆栈区。<br>C.地址一样，在全局区。<br>D.地址不一样，在全局区。</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>static变量存储在方法区，线程共享，全局区是方法区的一部分，其实用排除法也可以知道 static变量不可能位于堆栈区 </p><h2 id="7-下面代码的输出结果是什么？"><a href="#7-下面代码的输出结果是什么？" class="headerlink" title="7.下面代码的输出结果是什么？"></a>7.下面代码的输出结果是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ZeroTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">     try&#123;</span><br><span class="line">       int i &#x3D; 100 &#x2F; 0;</span><br><span class="line">       System.out.print(i);</span><br><span class="line">  &#125;catch(Exception e)&#123;</span><br><span class="line">       System.out.print(1);</span><br><span class="line">       throw new RuntimeException();</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line">       System.out.print(2);</span><br><span class="line">  &#125;</span><br><span class="line">      System.out.print(3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.3<br>B.123<br>C.1<br>D.12</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>1、inti = 100/ 0; 会出现异常，会抛出异常，System.out.print(i)不会执行，<br>2、catch捕捉异常，继续执行System.out.print(1);<br>3、当执行 thrownewRuntimeException(); 又会抛出异常，这时，除了会执行finally中的代码，其他地方的代码都不会执行 </p><h2 id="8-以下代码将打印出"><a href="#8-以下代码将打印出" class="headerlink" title="8.以下代码将打印出?"></a>8.以下代码将打印出?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">      List  Listlist1 &#x3D; new ArrayList();</span><br><span class="line">      Listlist1.add(0);</span><br><span class="line">      List Listlist2 &#x3D; Listlist1;</span><br><span class="line">  System.out.println(Listlist1.get(0) instanceof Integer);</span><br><span class="line">  System.out.println(Listlist2.get(0) instanceof Integer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.编译错误<br>B.true true<br>C.true false<br>D.false false</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据，该题中装入了0，是一个基本类型，但是JDK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。编译能够正常通过。<br>将list1的引用赋值给了list2，那么list1和list2都将指向同一个堆内存空间。instanceof是Java中关键字，用于判断一个对象是否属于某个特定类的实例，并且返回boolean类型的返回值。显然，list1.get(0)和list2.get(0)都属于Integer的实例 </p><h2 id="9-在运行时，由java解释器自动引入，而不用import语句引入的包是-。"><a href="#9-在运行时，由java解释器自动引入，而不用import语句引入的包是-。" class="headerlink" title="9. 在运行时，由java解释器自动引入，而不用import语句引入的包是()。"></a>9. 在运行时，由java解释器自动引入，而不用import语句引入的包是()。</h2><p>A.java.lang<br>B.java.system<br>C.java.io<br>D.java.util</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>ava.lang包是java语言包，是自动导入的。<br>java.util包是java的工具包，需要手动导入。<br>java.sql包，JDBC接口类，需要手动导入。<br>java.io;各种输入输入流，需要手动导入。 </p><h2 id="10-下面这三条语句"><a href="#10-下面这三条语句" class="headerlink" title="10.下面这三条语句"></a>10.下面这三条语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(“is ”+ 100 + 5)；</span><br><span class="line">System.out.println(100 + 5 +“ is”)；</span><br><span class="line">System.out.println(“is ”+ (100 + 5))；</span><br></pre></td></tr></table></figure><p>的输出结果分别是？ ( ) </p><p>A.is 1005, 1005 is, is 1005<br>B.is 105, 105 is, is 105<br>C.is 1005, 1005 is, is 105<br>D.is 1005, 105 is, is 105</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>1.”is”说明后面的内容都会被强制转换为string，所以是最后结果是拼接起来的<br>2.100+5先得到105，然后与is拼接<br>3.先算括号内的</p><h2 id="11-Given"><a href="#11-Given" class="headerlink" title="11.Given:"></a>11.Given:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class IfTest&#123;</span><br><span class="line">    public static void main(string[]args)&#123;</span><br><span class="line">        int x&#x3D;3;</span><br><span class="line">        int y&#x3D;1;</span><br><span class="line">        if(x&#x3D;y)</span><br><span class="line">            System.out.println(“Not equal”);</span><br><span class="line">        else</span><br><span class="line">            System.out.println(“Equal”);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>What is the result?</p><p>A.The output is “Equal”<br>B.The output in “Not Equal”<br>C.An error at line 5 causes compilation to fall.<br>D.The program executes but does not print a message.</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>这个题考查两个知识点。<br>1、Java中，赋值是有返回值的 ，赋什么值，就返回什么值。比如这题，x=y，返回y的值，所以括号里的值是1。<br>2、Java跟C的区别，C中赋值后会与0进行比较，如果大于0，就认为是true；而Java不会与0比较，而是直接把赋值后的结果放入括号。 </p><h2 id="12-在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？"><a href="#12-在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？" class="headerlink" title="12.在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？"></a>12.在一个基于分布式的游戏服务器系统中，不同的服务器之间，哪种通信方式是不可行的（）？</h2><p>A.管道<br>B.消息队列<br>C.高速缓存数据库<br>D.套接字</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 </p><h2 id="13-下列程序的运行结果"><a href="#13-下列程序的运行结果" class="headerlink" title="13.下列程序的运行结果"></a>13.下列程序的运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void getCustomerInfo() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; do something that may cause an Exception</span><br><span class="line">&#125; catch (java.io.FileNotFoundException ex) &#123;</span><br><span class="line">System.out.print(&quot;FileNotFoundException!&quot;);</span><br><span class="line">&#125; catch (java.io.IOException ex) &#123;</span><br><span class="line">System.out.print(&quot;IOException!&quot;);</span><br><span class="line">&#125; catch (java.lang.Exception ex) &#123;</span><br><span class="line">System.out.print(&quot;Exception!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.IOException!<br>B.IOException!Exception!<br>C.FileNotFoundException!IOException!<br>D.FileNotFoundException!IOException!Exception!</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>题目说抛出一个异常，但是没说具体是什么异常，那么就要分情况了：<br>1.如果抛出一个FileNotFoundException(或其子类)，那么最终结果就打印FileNotFoundException<br>2.如果抛出一个IOException,或者IOException的子类(不包含FileNotFoundException及其子类)，那么最终结果就打印IOException<br>3.如果抛出一个Exception(不包含IOException及其子类),那么最终结果就打印Exception.<br>以上，所以3个皆有可能.但是，不管是哪一种情况，只会输出其中之一。<br>从答案上来看，B,C，D的输出情况是不存在的。因此选A </p><h2 id="14-如下代码的输出结果是什么？"><a href="#14-如下代码的输出结果是什么？" class="headerlink" title="14.如下代码的输出结果是什么？"></a>14.如下代码的输出结果是什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public int aMethod()&#123;</span><br><span class="line">        static int i &#x3D; 0;</span><br><span class="line">        i++;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">public static void main(String args[])&#123;</span><br><span class="line">    Test test &#x3D; new Test();</span><br><span class="line">    test.aMethod();</span><br><span class="line">    int j &#x3D; test.aMethod();</span><br><span class="line">    System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.0<br>B.1<br>C.2<br>D.编译失败</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>静态变量只能在类主体中定义，不能在方法中定义</p><h2 id="15-下面有关servlet和cgi的描述，说法错误的是？"><a href="#15-下面有关servlet和cgi的描述，说法错误的是？" class="headerlink" title="15.下面有关servlet和cgi的描述，说法错误的是？"></a>15.下面有关servlet和cgi的描述，说法错误的是？</h2><p>A.servlet处于服务器进程中，它通过多线程方式运行其service方法<br>B.CGI对每个请求都产生新的进程，服务完成后就销毁<br>C.servlet在易用性上强于cgi，它提供了大量的实用工具例程，例如自动地解析和解码HTML表单数据、读取和设置HTTP头、处理Cookie、跟踪会话状态等<br>D.cgi在移植性上高于servlet，几乎所有的主流服务器都直接或通过插件支持cgi</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>选择D，servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。</p><h2 id="16-下列关于构造方法的叙述中，错误的是（）"><a href="#16-下列关于构造方法的叙述中，错误的是（）" class="headerlink" title="16.下列关于构造方法的叙述中，错误的是（）"></a>16.下列关于构造方法的叙述中，错误的是（）</h2><p>A.java语言规定构造方法名与类名必须相同<br>B.java语言规定构造方法没有返回值，但不同void声明<br>C.java语言规定构造方法不可以重载<br>D.java语言规定构造方法只能通过new自动调用</p><p><strong>答案：</strong><br>CD</p><p><strong>解析：</strong><br>关于答案d,通过this也可以调用 </p><h2 id="17-What-is-Static-Method-in-Java（）"><a href="#17-What-is-Static-Method-in-Java（）" class="headerlink" title="17.What is Static Method in Java（）"></a>17.What is Static Method in Java（）</h2><p>A.It is a method which belongs to the class and not to the object(instance)<br>B.A static method can access only static data. It can not access non-static data (instance variables)<br>C.A static method can call only other static methods and can not call a non-static method from it.<br>D.A static method can not be accessed directly by the class name and doesn’t need any object</p><p><strong>答案：</strong><br>ABC</p><p><strong>解析：</strong></p><p>A：静态方法是一个属于类而不属于对象(实例)的方法。（√）<br>B：静态方法只能访问静态数据。无法访问非静态数据(实例变量)。（√）<br>C：静态方法只能调用其他静态方法，不能从中调用非静态方法。（√）<br>D：静态方法不能通过类名直接访问，也不需要任何对象。（×） 静态方法可以直接用类名访问。</p><h2 id="18-下列哪种情况会调用拷贝构造函数（）"><a href="#18-下列哪种情况会调用拷贝构造函数（）" class="headerlink" title="18.下列哪种情况会调用拷贝构造函数（）"></a>18.下列哪种情况会调用拷贝构造函数（）</h2><p>A.用派生类的对象去初始化基类对象时<br>B.将类的一个对象赋值给该类的另一个对象时<br>C.函数的形参是类的对象，调用函数进行形参和实参结合时<br>D.函数的返回值是类的对象，函数执行返回调用时</p><p><strong>答案：</strong><br>A C D</p><p><strong>解析：</strong></p><p>复制构造函数被调用的三种情况</p><p>1.定义一个对象时，以本类另一个对象作为初始值，发生复制构造；</p><p>2.如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造；</p><p>3.如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。</p><h2 id="19-Java对象的初始化方式有（-）"><a href="#19-Java对象的初始化方式有（-）" class="headerlink" title="19.Java对象的初始化方式有（ ）"></a>19.Java对象的初始化方式有（ ）</h2><p>A.初始化块<br>B.构造器<br>C.定义变量时指定初始化值<br>D.其它各项都不对</p><p><strong>答案：</strong><br>A B C</p><p><strong>解析：</strong></p><p>对象的初始化方式：<br>1.new时初始化 ；<br>2.静态工厂 newInstance；<br>3.反射Class.forName()；<br>4.clone方式；<br>5.反序列化；</p><h2 id="20-截止JDK1-8版本-java并发框架支持锁包括"><a href="#20-截止JDK1-8版本-java并发框架支持锁包括" class="headerlink" title="20.截止JDK1.8版本,java并发框架支持锁包括?"></a>20.截止JDK1.8版本,java并发框架支持锁包括?</h2><p>A.读写锁<br>B.自旋锁<br>C.X锁<br>D.乐观锁<br>E.排他锁</p><p><strong>答案：</strong><br>A B D</p><p><strong>解析：</strong></p><p>1、自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁<br>2、阻塞锁 被阻塞的线程，不会争夺锁。<br>3、可重入锁 多次进入改锁的域<br>4、读写锁<br>5、互斥锁 锁本身就是互斥的<br>6、悲观锁 不相信，这里会是安全的，必须全部上锁<br>7、乐观锁 相信，这里是安全的。<br>8、公平锁 有优先级的锁<br>9、非公平锁 无优先级的锁<br>10、偏向锁 无竞争不锁，有竞争挂起，转为轻量锁<br>11、对象锁 锁住对象<br>12、线程锁<br>13、锁粗化 多锁变成一个，自己处理<br>14、轻量级锁 CAS 实现<br>15、锁消除 偏向锁就是锁消除的一种<br>16、锁膨胀 jvm实现，锁粗化<br>17、信号量 使用阻塞锁 实现的一种策略<br>18、排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p><blockquote><p>注：以上笔试题均来自网络，由笔者整理得出</p></blockquote><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">笔试内容集合</a> 欢迎关注，持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-3d2d38cc1d994291?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（二）</title>
      <link href="/2019/09/16/interview/java/B-bishi02/"/>
      <url>/2019/09/16/interview/java/B-bishi02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-c168c90d99f96d7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（二）"></p><h2 id="1-HashMap的数据结构是怎样的？"><a href="#1-HashMap的数据结构是怎样的？" class="headerlink" title="1. HashMap的数据结构是怎样的？"></a>1. HashMap的数据结构是怎样的？</h2><p>A.数组<br>B.链表<br>C.数组+链表<br>D.二叉树</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong></p><p>JDK8以后，HashMap的数据结构是数组+链表+红黑树 </p><h2 id="2-在-JAVA-编程中，Java-编译器会将-Java-程序转换为（-）？"><a href="#2-在-JAVA-编程中，Java-编译器会将-Java-程序转换为（-）？" class="headerlink" title="2. 在 JAVA 编程中，Java 编译器会将 Java 程序转换为（ ）？"></a>2. 在 JAVA 编程中，Java 编译器会将 Java 程序转换为（ ）？</h2><p>A.字节码<br>B.可执行代码<br>C.机器代码<br>D.以上都不对</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong></p><ul><li>编译器将Java源代码编译成字节码class文件</li><li>类加载到JVM里面后，执行引擎把字节码转为可执行代码</li><li>执行的过程，再把可执行代码转为机器码，由底层的操作系统完成执行。 </li></ul><h2 id="3-下面有关JVM内存，说法错误的是？"><a href="#3-下面有关JVM内存，说法错误的是？" class="headerlink" title="3.下面有关JVM内存，说法错误的是？"></a>3.下面有关JVM内存，说法错误的是？</h2><p>A.程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的<br>B.Java方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的<br>C.方法区用于存储JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程隔离的<br>D.原则上讲，所有的对象都在堆区上分配内存，是线程之间共享的</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器</p><ul><li>虚拟机栈区：也就是我们常说的栈区，线程私有，存放基本类型，对象的引用和 returnAddress ，在编译期间完成分配。</li><li>堆区：JAVA 堆，也称 GC 堆，所有线程共享，存放对象的实例和数组， JAVA 堆是垃圾收集器管理的主要区域。</li><li>方法区：所有线程共享，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。</li><li>程序计数器：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址。</li></ul><ol start="4"><li>JAVA中，下列语句哪一个正确（） </li></ol><p>A.class中的constructor不可省略<br>B.constructor必须与class同名，但方法不能与class同名<br>C.constructor在一个对象被new时执行<br>D.一个class只能定义一个constructor</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>A 省略构造函数,编译器会自动生成。<br>D 构造函数可以重载<br>B 方法是可以和类名同名的，和构造方法唯一的区别就是，构造方法没有返回值。</p><h2 id="5-在JAVA中，假设A有构造方法A-int-a-，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）"><a href="#5-在JAVA中，假设A有构造方法A-int-a-，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）" class="headerlink" title="5.在JAVA中，假设A有构造方法A(int a)，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）"></a>5.在JAVA中，假设A有构造方法A(int a)，则在类A的其他构造方法中调用该构造方法和语句格式应该为（）</h2><p>A.this.A(x)<br>B.this(x)<br>C.super(x)<br>D.A(x)</p><p><strong>答案：</strong><br>B </p><p><strong>解析：</strong><br>this的作用其中一个就是在一个构造方法中调用另一个构造方法，格式为this(参数)；<br>super是调用父类的方法；<br>A(a)这种形式是在new一个类时使用。 </p><h2 id="6-下列选项中属于面向对象程序设计语言特征的是（）"><a href="#6-下列选项中属于面向对象程序设计语言特征的是（）" class="headerlink" title="6.下列选项中属于面向对象程序设计语言特征的是（）"></a>6.下列选项中属于面向对象程序设计语言特征的是（）</h2><p>A.继承性<br>B.多态性<br>C.相似性<br>D.封装性</p><p><strong>答案：</strong><br> A B D</p><p><strong>解析：</strong><br>面对对象三大特征：封装，继承，多态 </p><h2 id="7-以下哪个正确？"><a href="#7-以下哪个正确？" class="headerlink" title="7.以下哪个正确？"></a>7.以下哪个正确？</h2><p>A.abstract类只能用来派生子类，不能用来创建abstract类的对象。<br>B.final类不但可以用来派生子类，也可以用来创建final类的对象。<br>C.abstract不能与final同时修饰一个类。<br>D.abstract类定义中可以没有abstract方法。</p><p><strong>答案：</strong><br>A C D</p><p><strong>解析：</strong><br>1、abstract类不能用来创建abstract类的对象；<br>2、final类不能用来派生子类，因为用final修饰的类不能被继承；<br>3、如2所述，final不能与abstract同时修饰一个类，abstract类就是被用来继承的；<br>4、类中有abstract方法必须用abstract修饰，但abstract类中可以没有抽象方法，接口中也可以有abstract方法。</p><h2 id="8-JAVA反射机制主要提供了以下哪些功能？"><a href="#8-JAVA反射机制主要提供了以下哪些功能？" class="headerlink" title="8. JAVA反射机制主要提供了以下哪些功能？"></a>8. JAVA反射机制主要提供了以下哪些功能？</h2><p>A.在运行时判断一个对象所属的类<br>B.在运行时构造一个类的对象<br>C.在运行时判断一个类所具有的成员变量和方法<br>D.在运行时调用一个对象的方法</p><p><strong>答案：</strong><br>A B C D</p><p><strong>解析：</strong><br>Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。<br>因此，答案为：ABCD </p><h2 id="9-以下关于Histroy对象的属性或方法描述正确的是（）"><a href="#9-以下关于Histroy对象的属性或方法描述正确的是（）" class="headerlink" title="9.以下关于Histroy对象的属性或方法描述正确的是（）"></a>9.以下关于Histroy对象的属性或方法描述正确的是（）</h2><p>A.bcak回到浏览器载入历史URL地址列表的当前URL的前一个URL<br>B.go表示刷新当前页面<br>C.length保存历史URL地址列表的长度信息<br>D.forward转到浏览器载入历史URL地址列表的当前URL的下一个URL。</p><p><strong>答案：</strong><br>A D</p><p><strong>解析：</strong></p><p>选A、D。考察的是浏览器的内置对象管理模型，简称BOM(Browser Object Model)中的Histroy属性和方法。</p><ul><li>length 返回浏览器历史列表中的URL数量。所以C中表述的长度信息是错误的。</li><li>back() 加载 history列表中的前一个URL。</li><li>forward() 加载  history  列表中的下一个URL。</li><li>go()  加载history列表中的某个具体页面。所以B的表述刷新当前页面是错误的。</li></ul><h2 id="10"><a href="#10" class="headerlink" title="10."></a>10.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class NameList</span><br><span class="line">&#123;</span><br><span class="line">    private List names &#x3D; new ArrayList();</span><br><span class="line">    public synchronized void add(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        names.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void printAll()     &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; names.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(names.get(i) + ””);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[]args)</span><br><span class="line">    &#123;</span><br><span class="line">        final NameList sl &#x3D; new NameList();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            new Thread()</span><br><span class="line">            &#123;</span><br><span class="line">                public void run()</span><br><span class="line">                &#123;</span><br><span class="line">                    sl.add(“A”);</span><br><span class="line">                    sl.add(“B”);</span><br><span class="line">                    sl.add(“C”);</span><br><span class="line">                    sl.printAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; .start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Which two statements are true if this class is compiled and run? </p><p>A.An exception may be thrown at runtime.<br>B.The code may run with no output, without exiting.<br>C.The code may run with no output, exiting normally(正常地).<br>D.The code may rum with output “A B A B C C “, then exit.<br>E.The code may rum with output “A B C A B C A B C “, then exit.<br>F.The code may ruin with output “A A A B C A B C C “, then exit.<br>G.The code may ruin with output “A B C A A B C A B C “, then exit.</p><p><strong>答案：</strong><br>E G</p><p><strong>解析：</strong></p><p>在每个线程中都是顺序执行的，所以sl.printAll();必须在前三句执行之后执行，也就是输出的内容必有（连续或非连续的）ABC。而线程之间是穿插执行的，所以一个线程执行 sl.printAll();之前可能有另一个线程执行了前三句的前几句。<br>E答案相当于线程1顺序执行完然后线程2顺序执行完。<br>G答案则是线程1执行完前三句add之后线程2插一脚执行了一句add然后线程1再执行 sl.printAll();输出ABCA。接着线程2顺序执行完输出ABCABC<br>输出加起来即为ABCAABCABC。</p><h2 id="11-关于容器下面说法正确的是？"><a href="#11-关于容器下面说法正确的是？" class="headerlink" title="11. 关于容器下面说法正确的是？ ( )"></a>11. 关于容器下面说法正确的是？ ( )</h2><p>A.列表(List)和集合(Set)存放的元素都是可重复的。<br>B.列表(List)和集合(Set)存放的元素都是不可重复的。<br>C.映射(Map)&lt;key,value&gt;中key是可以重复的。<br>D.映射(Map)&lt;key,value&gt;中value是可以重复的。</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>列表（List）的元素是有序、可重复的；<br>集合（Set）的元素是无序、不可重复的。 </p><h2 id="12-以下说法错误的是-（）"><a href="#12-以下说法错误的是-（）" class="headerlink" title="12.以下说法错误的是?（）"></a>12.以下说法错误的是?（）</h2><p>A.数组是一个对象<br>B.数组不是一种原生类<br>C.数组的大小可以任意改变<br>D.在Java中，数组存储在堆中连续内存空间里</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>在java中,数组是一个对象,不是一种原生类,对象所以存放在堆中,又因为数组特性,是连续的,只有C不对</p><h2 id="13-下列哪个修饰符可以使在一个类中定义的成员变量只能被同一包中的类访问？"><a href="#13-下列哪个修饰符可以使在一个类中定义的成员变量只能被同一包中的类访问？" class="headerlink" title="13.下列哪个修饰符可以使在一个类中定义的成员变量只能被同一包中的类访问？"></a>13.下列哪个修饰符可以使在一个类中定义的成员变量只能被同一包中的类访问？</h2><p>A.private<br>B.无修饰符<br>C.public<br>D.protected</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br><img src="https://upload-images.jianshu.io/upload_images/7326374-da4c30aa9fc41454.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="解析"></p><h2 id="14-关于以下程序代码的说明正确的是"><a href="#14-关于以下程序代码的说明正确的是" class="headerlink" title="14.关于以下程序代码的说明正确的是?"></a>14.关于以下程序代码的说明正确的是?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class HasStatic &#123;</span><br><span class="line">private static int x &#x3D; 100;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) &#123;</span><br><span class="line">HasStatic hs1 &#x3D; new HasStatic();</span><br><span class="line">hs1.x++;</span><br><span class="line">HasStatic hs2 &#x3D; new HasStatic();</span><br><span class="line">hs2.x++;</span><br><span class="line">hs1 &#x3D; new HasStatic();</span><br><span class="line">;</span><br><span class="line">hs1.x++;</span><br><span class="line">HasStatic.x--;</span><br><span class="line">System.out.println(&quot;x&#x3D;&quot; + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.程序通过编译，输出结果为：x=103<br>B.10行不能通过编译，因为x是私有静态变量<br>C.5行不能通过编译，因为引用了私有静态变量<br>D.程序通过编译，输出结果为：x=102</p><p><strong>答案：</strong><br>D </p><p><strong>解析：</strong><br>此题选择D。<br>首先要了解static的意思。</p><p>static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。<br>static变量在第一次使用的时候初始化，但只会有一份成员对象。<br>所以这里不仅可以调用，而且每一次调用都确实修改了x的值，也就是变化情况是这样的：<br>x=101<br>x=102<br>x=103<br>x=102</p><h2 id="15-如何放掉一个指定占据的内存空间？（）"><a href="#15-如何放掉一个指定占据的内存空间？（）" class="headerlink" title="15.如何放掉一个指定占据的内存空间？（）"></a>15.如何放掉一个指定占据的内存空间？（）</h2><p>A.调用free()方法<br>B.代用system.gc()方法<br>C.赋值给该项对象的引用为null<br>D.程序员无法明确强制垃圾回收器运行</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>在《java虚拟机》一书中明确讲了，释放掉占据的内存空间是由gc完成，但是程序员无法明确强制其运行，该空间在不被引用的时候不一定会立即被释放，这取决于GC本身，无法由程序员通过代码控制。 </p><h2 id="16-一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？"><a href="#16-一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？" class="headerlink" title="16.一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？"></a>16.一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？</h2><p>A.表对应类<br>B.记录对应对象<br>C.表的字段对应类的属性<br>D.表之间的参考关系对应类之间的依赖关系</p><p><strong>答案：</strong><br>D</p><p><strong>解析：</strong><br>一般关系数据模型和对象数据模型之间有以下对应关系：表对应类，记录对应对象，表的字段对应类的属性</p><h2 id="17-下列关于Java并发的说法中正确的是（）"><a href="#17-下列关于Java并发的说法中正确的是（）" class="headerlink" title="17.下列关于Java并发的说法中正确的是（）"></a>17.下列关于Java并发的说法中正确的是（）</h2><p>A.CopyOnWriteArrayList适用于写多读少的并发场景<br>B.ReadWriteLock适用于读多写少的并发场景<br>C.ConcurrentHashMap的写操作不需要加锁，读操作需要加锁<br>D.只要在定义int类型的成员变量i的时候加上volatile关键字，那么多线程并发执行i++这样的操作的时候就是线程安全的了</p><p><strong>答案：</strong><br>B</p><p><strong>解析：</strong><br>A，CopyOnWriteArrayList适用于写少读多的并发场景<br>B，ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥，读与读之间可以并发执行。在读多写少的情况下可以提高效率<br>C，ConcurrentHashMap是同步的HashMap，读写都加锁<br>D，volatile只保证多线程操作的可见性，不保证原子性 </p><h2 id="18-以下代码执行后输出结果为（-）"><a href="#18-以下代码执行后输出结果为（-）" class="headerlink" title="18.以下代码执行后输出结果为（ ）"></a>18.以下代码执行后输出结果为（ ）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    public static Test t1 &#x3D; new Test();</span><br><span class="line">    &#123;</span><br><span class="line">         System.out.println(&quot;blockA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;blockB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Test t2 &#x3D; new Test();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>A.blockAblockBblockA<br>B.blockAblockAblockB<br>C.blockBblockBblockA<br>D.blockBblockAblockB</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>静态块：用static申明，JVM加载类时执行，仅执行一次<br>构造块：类中直接用{}定义，每一次创建对象时执行<br>执行顺序优先级：静态块&gt;main()&gt;构造块&gt;构造方法  静态块按照申明顺序执行，先执行Test t1 = new Test();<br>所有先输出blockA，然后执行静态块，输出blockB，最后执行main<br>方法中的Test t2 = new Test();输出blockA。 </p><h2 id="19-有关hashMap跟hashTable的区别，说法正确的是？"><a href="#19-有关hashMap跟hashTable的区别，说法正确的是？" class="headerlink" title="19.有关hashMap跟hashTable的区别，说法正确的是？"></a>19.有关hashMap跟hashTable的区别，说法正确的是？</h2><p>A.HashMap和Hashtable都实现了Map接口<br>B.HashMap是非synchronized，而Hashtable是synchronized<br>C.HashTable使用Enumeration，HashMap使用Iterator<br>D.HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</p><p><strong>答案：</strong><br>ABCD</p><p><strong>解析：</strong></p><p>A正确。Map是一个接口，hashtable,hashmap都是它的实现。<br>B正确。由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。<br>C正确。HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。<br>D正确。 哈希值的使用不同，HashTable直接使用对象的hashCode，代码是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int hash &#x3D; key.hashCode();</span><br><span class="line">int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br></pre></td></tr></table></figure><p>而HashMap重新计算hash值，而且用与代替求模：<br>int hash = hash(k);<br>int i = indexFor(hash, table.length); </p><h2 id="20-以下可以正确获取结果集的有"><a href="#20-以下可以正确获取结果集的有" class="headerlink" title="20.以下可以正确获取结果集的有?"></a>20.以下可以正确获取结果集的有?</h2><p>A.Statement sta=con.createStatement();<br>ResultSet rst=sta.executeQuery(“select * from book”);</p><p>B.Statement sta=con.createStatement(“select * from book”); ResultSet rst=sta.executeQuery();</p><p>C.PreparedStatement pst=con.prepareStatement();<br>ResultSet rst=pst.executeQuery(“select * from book”);</p><p>D.PreparedStatement pst=con.prepareStatement(“select * from book”);<br>ResultSet rst=pst.executeQuery();</p><p><strong>答案：</strong><br>A D  </p><p><strong>解析：</strong><br>A,D是正确的；创建Statement是不传参的，PreparedStatement是需要传入sql语句<br>说一下preparedStatement和statement的区别与联系：在JDBC应用中,如果你已经是稍有水平开发者,你就应该始终以PreparedStatement代替Statement.也就是说,在任何时候都不要使用Statement。<br>PreparedStatement 接口继承 Statement,PreparedStatement 实例包含已编译的 SQL 语句,所以其执行速度要快于Statement对象。Statement为一条Sql语句生成执行计划，如果要执行两条sql语句select colume from table where colume=1;select colume from table where colume=2; 会生成两个执行计划一千个查询就生成一千个执行计划！ PreparedStatement用于使用绑定变量重用执行计划 select colume from table where colume=:x; 通过set不同数据只需要生成一次执行计划，可以重用</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">笔试内容集合</a> 持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-283e473b53f21625?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础笔试练习（一）</title>
      <link href="/2019/09/11/interview/java/B-bishi01/"/>
      <url>/2019/09/11/interview/java/B-bishi01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎访问个人网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7326374-9b65a59238ede835.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Java基础笔试练习（一）"></p><h2 id="1-若在某一个类定义中定义有如下的方法：-abstract-void-performDial-该方法属于（）"><a href="#1-若在某一个类定义中定义有如下的方法：-abstract-void-performDial-该方法属于（）" class="headerlink" title="1. 若在某一个类定义中定义有如下的方法： abstract void performDial( ); 该方法属于（） ?"></a>1. 若在某一个类定义中定义有如下的方法： abstract void performDial( ); 该方法属于（） ?</h2><p>A.本地方法<br>B.最终方法<br>C.静态方法<br>D.抽象方法</p><p><strong>答案：</strong> D</p><p><strong>解析：</strong></p><ul><li>本地方法：简单地讲，一个native Method就是一个java调用非java代码的接口；native方法表示该方法要用另外一种依赖平台的编程语言实现。</li><li>最终方法：final void B(){},这样定义的方法就是最终方法，最终方法在子类中不可以被重写，也就是说，如果有个子类继承了这个最终方法所在的类，那么这个子类中不能出现void B(){}这样的方法。 </li><li>最终类：final class A {},这样定义的类就是最终类，最终类不能被继承。 </li><li>abstract修饰抽象类 </li></ul><h2 id="2-在为传统面向对象语言的程序做单元测试的时候-经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？"><a href="#2-在为传统面向对象语言的程序做单元测试的时候-经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？" class="headerlink" title="2.在为传统面向对象语言的程序做单元测试的时候,经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？"></a>2.在为传统面向对象语言的程序做单元测试的时候,经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？</h2><p>A.封装<br>B.多态<br>C.继承<br>D.抽象</p><p><strong>答案：</strong>  A</p><p><strong>解析：</strong><br>A.封装<br>反射破坏代码的封装性，破坏原有的访问修饰符访问限制 </p><h2 id="3-以下程序的执行结果是："><a href="#3-以下程序的执行结果是：" class="headerlink" title="3.以下程序的执行结果是："></a>3.以下程序的执行结果是：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static boolean foo(char c) &#123;</span><br><span class="line">System.out.print(c);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main1(String[] args) &#123;</span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">for (foo(&#39;A&#39;); foo(&#39;B&#39;) &amp;&amp; (i &lt; 2); foo(&#39;C&#39;)) &#123;</span><br><span class="line">i++;</span><br><span class="line">foo(&#39;D&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.ABDCBDCB<br>B.ABCDABCD<br>C.编译时出错<br>D.运行时抛出异常</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>略，代码敲一遍就知道了= =！</p><ol start="4"><li>一个完整的URL地址由(),(),端口和文件四部分组成。 </li></ol><p>A.协议 用户名<br>B.协议 主机名<br>C.主机名 ip<br>D.以上都不正确</p><p><strong>答案：</strong><br>B </p><p><strong>解析：</strong><br><strong>URL(Uniform Resource Locator) *<em>，统一资源定位符，能够对因特网的资源进行定位。<br>*</em>URL</strong>一般有四部分组成： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><ul><li>现在最常用的&lt;协议&gt;为http协议。</li><li>&lt;主机&gt;是指主机在因特网上的域名。</li><li>http协议的默认&lt;端口&gt;为80（可以省略）。</li><li>&lt;路径&gt;是指要活的的文件的路径。 </li></ul><h2 id="5-以下程序的输出结果是？"><a href="#5-以下程序的输出结果是？" class="headerlink" title="5.以下程序的输出结果是？"></a>5.以下程序的输出结果是？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    String str &#x3D; new String(&quot;good&quot;);</span><br><span class="line">    char[] ch &#x3D; &#123; &#39;a&#39;, &#39;b&#39;, &#39;c&#39; &#125;;</span><br><span class="line"> </span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Example ex &#x3D; new Example();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str + &quot; and &quot;);</span><br><span class="line">        System.out.print(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   public static void change(String str, char ch[])      </span><br><span class="line">   &#123;</span><br><span class="line">        str &#x3D; &quot;test ok&quot;;</span><br><span class="line">        ch[0] &#x3D; &#39;g&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.good and abc<br>B.good and gbc<br>C.test ok and abc<br>D.test ok and gbc</p><p><strong>答案：</strong><br>B </p><p><strong>解析：</strong><br>考察值传递和引用传递。对于值传递，拷贝的值用完之后就会被释放，对原值没有任何影响，但是对于引用传递，拷贝的是对象的引用，和原值指向的同一块地址，即操作的是同一个对象，所以操作之间会相互影响<br>所以对于String str是值传递，操作之间互不影响，原值保持不变。而ch是数组，拷贝的是对象的引用，值发生了改变，因此选择B </p><h2 id="6-下面有关servlet-service描述错误的是？"><a href="#6-下面有关servlet-service描述错误的是？" class="headerlink" title="6.下面有关servlet service描述错误的是？"></a>6.下面有关servlet service描述错误的是？</h2><p>A.不管是post还是get方法提交过来的连接，都会在service中处理<br>B.doGet/doPost 则是在 javax.servlet.GenericServlet 中实现的<br>C.service()是在javax.servlet.Servlet接口中定义的<br>D.service判断请求类型，决定是调用doGet还是doPost方法</p><p><strong>答案：</strong><br>B </p><p><strong>解析：</strong><br>doGet/doPost 则是在 javax.servlet.http.HttpServlet 中实现的</p><h2 id="7-以下代码运行输出的是"><a href="#7-以下代码运行输出的是" class="headerlink" title="7.以下代码运行输出的是"></a>7.以下代码运行输出的是</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">    private String name &#x3D; &quot;Person&quot;;</span><br><span class="line">    int age&#x3D;0;</span><br><span class="line">&#125;</span><br><span class="line">public class Child extends Person&#123;</span><br><span class="line">    public String grade;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Person p &#x3D; new Child();</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A.输出：Person<br>B.没有输出<br>C.编译出错<br>D.运行出错</p><p><strong>答案：</strong><br>C</p><p><strong>解析：</strong><br>Java中对字段属性是静态绑定，方法成员是动态绑定，这里错在：在子类中试图访问父类的private字段，所以编译不通过，将private去掉就可访问，不是动态绑定的问题，它本来就属于静态绑定。</p><h2 id="8-在-myjsp-jsp-中，关于下面的代码说法错误的是："><a href="#8-在-myjsp-jsp-中，关于下面的代码说法错误的是：" class="headerlink" title="8.  在 myjsp.jsp 中，关于下面的代码说法错误的是： (  )"></a>8.  在 myjsp.jsp 中，关于下面的代码说法错误的是： (  )</h2><p>&lt;%@ page language=”java” import=”java.util.*” errorPage=”error.jsp” isErrorPage=”false” %&gt; </p><p>A.该页面可以使用 exception 对象<br>B.该页面发生异常会转向 error.jsp<br>C.存在 errorPage 属性时，isErrorPage 是默认为 false<br>D.error.jsp 页面一定要有isErrorPage 属性且值为 true</p><p><strong>答案：</strong><br>A</p><p><strong>解析：</strong><br>exception是JSP九大内置对象之一，其实例代表其他页面的异常和错误。只有当页面是错误处理页面时，即isErroePage为true时，该对象才可以使用。对于C项，errorPage的实质就是JSP的异常处理机制,发生异常时才会跳转到errorPage指定的页面，没必要给errorPage再设置一个errorPage。所以当errorPage属性存在时， isErrorPage属性值为false </p><h2 id="9-Java对象的初始化方式有（-）"><a href="#9-Java对象的初始化方式有（-）" class="headerlink" title="9.Java对象的初始化方式有（ ）"></a>9.Java对象的初始化方式有（ ）</h2><p>A.初始化块<br>B.构造器<br>C.定义变量时指定初始化值<br>D.其它各项都不对</p><p><strong>答案：</strong><br>A B C</p><p><strong>解析：</strong></p><p>对象的初始化方式：<br>1.new时初始化 ；<br>2.静态工厂 newInstance；<br>3.反射Class.forName()；<br>4.clone方式；<br>5.反序列化；</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p><a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzIwMTg3NzYyOA==&hid=10&sn=34bfdf3ba4ff1ef1852e392195616f4e" target="_blank" rel="noopener">Java笔试内容集合</a> 持续更新中….</p><h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><blockquote><p>欢迎关注个人微信公众号：<strong>Coder编程</strong><br>获取最新原创技术文章和免费学习资料，更有大量精品思维导图、面试资料、PMP备考资料等你来领，方便你随时随地学习技术知识！</p></blockquote><blockquote><p>文章收录至<br>Github: <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">https://github.com/CoderMerlin/coder-programming</a><br>Gitee: <a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">https://gitee.com/573059382/coder-programming</a><br>欢迎<strong>关注</strong>并star~<br><img src="https://upload-images.jianshu.io/upload_images/7326374-dcdca3329b2e2104?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP备考指南之第二章：项目运作环境</title>
      <link href="/2019/04/24/pmp/PMP03/"/>
      <url>/2019/04/24/pmp/PMP03/</url>
      
        <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/7326374-4b037c7db1d5d591.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PMP备考指南之第二章：项目运作环境" title="PMP备考指南之第二章：项目运作环境"></p><blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎关注个人博客网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><blockquote><p>本文已同步至 <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">GitHub</a>/<a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">Gitee</a>/公众号，感兴趣的同学帮忙点波关注~</p></blockquote><h1 id="第二章：项目运作环境"><a href="#第二章：项目运作环境" class="headerlink" title="第二章：项目运作环境"></a>第二章：项目运作环境</h1><h2 id="1-事业环境因素、组织过程资产"><a href="#1-事业环境因素、组织过程资产" class="headerlink" title="1. 事业环境因素、组织过程资产"></a>1. 事业环境因素、组织过程资产</h2><p>事业环境因素 Enterprise Environmental Factors:是项目团队不能控制的，将对项目产生影响、限制或指令作用的各种条件。可能提高或限制项目管理的灵活性，也可能对项目结果产生积极或消极影响。包括：</p><p>1）组织文化、结构和治理；<br>2）设施和资源的地理分布；<br>3）基础设施：现有设施、设备、组织通讯渠道、IT 硬件、可用性和性能等<br>4）信息技术软件：进度计划软件工具、配置管理系统、其他在线自动化系统的网络接口、工作授权系统等<br>5）资源可用性：合同和采购制约因素、已批准的供应商、分包商和合作协议等）<br>6）员工能力：现有人力资源的专业知识、技能、能力和特定知识</p><p>（以上6条来自组织内部）</p><p>7）市场条件：竞争者、市场份额、品牌认知、商标等<br>8）社会和文化影响与问题：政治氛围、行为规范、道德、观念等<br>9）法律限制：与安全、数据保护、商业行为、雇佣与采购等有关的国家和地方法律法规<br>10）商业数据库：标杆对照结果、标准化的成本估算数据、行业风险研究信息、风险数据库等<br>11）学术研究：行业研究、出版物、标杆对照结果等<br>12）政府或行业标准：与产品、生产、环境、质量、工艺等有关的监管机构法规和标准<br>13）财务考虑因素：货币汇率、利率、通货膨胀率、关税、地理位置等<br>14）物理环境因素：工作条件、天气、制约因素等</p><p>（以上 8 条来自组织外部 ）</p><h2 id="2-组织文化与风格（内部的事业环境因素）"><a href="#2-组织文化与风格（内部的事业环境因素）" class="headerlink" title="2. 组织文化与风格（内部的事业环境因素）"></a>2. 组织文化与风格（内部的事业环境因素）</h2><ul><li>文化与风格是经过长期积淀而形成的群体现象，组织文化由组织成员的共同经验积淀而成。</li><li>共同的愿景、使命、价值观、信念和期望；</li><li>规章、政策、方法和程序；</li><li>对领导力、层级体系和职权关系的看法；</li><li>行为准则、职业道德；</li><li>风险承受力；</li><li>运营环境等等。</li></ul><p><strong>事业环境因素 ： 有来自组织内的、也有组织外的，都是项目团队不能控制、无法避免的。</strong></p><h2 id="3-组织过程资产"><a href="#3-组织过程资产" class="headerlink" title="3. 组织过程资产"></a>3. 组织过程资产</h2><p>一定是组织内部的。组织过程资产是执行组织所特有并使用的计划、流程、政策、程序和知识库，包括来自任何项目参与组织的，可用于执行或治理项目的任何产物、实践或知识。</p><p>包括两大类：</p><ul><li>过程、政策与程序（通常由 PMO 更新）</li><li>组织知识库（通常由项目更新）。</li></ul><h3 id="3-1-过程、政策与程序"><a href="#3-1-过程、政策与程序" class="headerlink" title="3.1 过程、政策与程序"></a>3.1 过程、政策与程序</h3><p>组织用于执行工作的流程与程序。</p><h4 id="3-1-1-启动和规划："><a href="#3-1-1-启动和规划：" class="headerlink" title="3.1.1 启动和规划："></a>3.1.1 启动和规划：</h4><p>1）指南和标准，用于裁剪的标准流程和程序以满足项目的特定要求<br>2）特定的组织标准，例如各种政策（如 HR、HSE、安保与保密、质量、采购和环境等政策）<br>3）产品和项目生命周期、方法与程序（如项目管理方法、评估指标、过程审计、改进目标、核对单、组织内使用的标准化的过程定义等）<br>4）模板（如项目管理计划、项目文件、项目登记册、报告格式、合同模板、风险分类、风险描述模板、概率与影响定义、概率和影响矩阵、以及干系人登记册模板等）<br>5） 预先批准的供应商清单和各种合同协议类型（如总价合同、成本补偿合同和工料合同）</p><h4 id="3-1-2-执行和监控："><a href="#3-1-2-执行和监控：" class="headerlink" title="3.1.2 执行和监控："></a>3.1.2 执行和监控：</h4><p>1） 变更控制程序<br>2） 风险控制程序<br>3） 跟踪矩阵<br>4） 财务控制程序<br>5） 问题与缺陷管理程序<br>6） 资源的可用性控制和分配管理<br>7） 组织对沟通的要求<br>8） 确定工作优先顺序、批准工作与签发工作授权的程序<br>9）模板（如风险登记册、问题日志和变更日志）<br>10）标准化的指南、工作指示、建议书评价准则和绩效测量准<br>11）产品、服务或成果的核实和确认程序</p><h4 id="3-1-3-收尾"><a href="#3-1-3-收尾" class="headerlink" title="3.1.3 收尾"></a>3.1.3 收尾</h4><p>项目收尾指南和要求（如项目终期审计、项目评价、可交付成果验收、合同收尾、资源分配，以及向生产和（或）运营部门转移知识等）</p><h3 id="3-2-组织知识库"><a href="#3-2-组织知识库" class="headerlink" title="3.2 组织知识库"></a>3.2 组织知识库</h3><p>组织用来存取信息的知识库。</p><p>包括：<br>1）配置管理知识库；<br>2）财务数据库；<br>3）历史信息与经验教训知识库；（项目收尾时，要总结经验教训、更新组织过程资产，供<br>将来的项目参考。这是考点）<br>4）问题与缺陷管理数据库；<br>5）测量指标数据库；<br>6）以往项目的项目档案；</p><h2 id="4-如何区分组织过程资产和事业环境因素？"><a href="#4-如何区分组织过程资产和事业环境因素？" class="headerlink" title="4. 如何区分组织过程资产和事业环境因素？"></a>4. 如何区分组织过程资产和事业环境因素？</h2><p>第 1，是组织内部的还是外部的，如果是外部的，一定是事业环境因素；如果是组织内部，可能是组织过程资产，也可能是事业环境因素。<br>第 2，项目经理是否可以选择，组织过程资产是可以选择用或不用；事业环境因素是不容项目经理选择的。<br>第 3，以“程序”结尾的词大多是组织过程资产；以“系统”结尾的词大多是事业环境因素</p><h2 id="5-组织结构"><a href="#5-组织结构" class="headerlink" title="5.组织结构"></a>5.组织结构</h2><p>组织结构/组织形式定义：人员的职责、权限和相互关系的安排；是一种事业环境因素。可能影响人力资源的可用性和项目的执行方式。<br>三大类：职能型、矩阵型（弱矩阵、平衡矩阵、强矩阵）、项目导向型，所以一共是五种组织结构。<br>五种组织结构我们一个个介绍：</p><h3 id="5-1-职能型组织"><a href="#5-1-职能型组织" class="headerlink" title="5.1 职能型组织"></a>5.1 职能型组织</h3><p><img src="http://upload-images.jianshu.io/upload_images/7326374-829f7696b02b2a43.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="职能型组织" title="职能型组织"></p><p>职能经理就是部门经理角色，职能经理掌握人员绩效、完全掌握项目预算。pm 是兼职，pm极小或没有权力。</p><p>职能型组织 优点：员工只有一个上级、单线沟通、职责分工明确。<br>职能型组织 缺点：跨部门沟通困难，部门利益高于项目，员工以自己的本职工作为重点，妨碍客户参与项目，因此对项目的反应速度特别慢。</p><h3 id="5-2-弱矩阵型组织"><a href="#5-2-弱矩阵型组织" class="headerlink" title="5.2 弱矩阵型组织"></a>5.2 弱矩阵型组织</h3><p><img src="http://upload-images.jianshu.io/upload_images/7326374-32ff5286311580e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="弱矩阵型组织" title="弱矩阵型组织"></p><p>pm 权力小于职能经理比起职能型组织，弱矩阵的优点：加强了部门间沟通.pm 是项目联络员或协调员。</p><p>项目联络员和协调员有区别：<br>项目联络员：联络沟通作用，没有权力，需要职能经理做决定。<br>项目协调员：有一定的决策权、可以向高层经理汇报,打小报告。<br>所以两者最大的区别在于：是否能够做决策。职能经理完全掌握预算，pm 是兼职</p><h3 id="5-3-平衡矩阵组织"><a href="#5-3-平衡矩阵组织" class="headerlink" title="5.3 平衡矩阵组织"></a>5.3 平衡矩阵组织</h3><p><img src="http://upload-images.jianshu.io/upload_images/7326374-0f2f5e24d5a5e2d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="平衡矩阵组织" title="平衡矩阵组织"></p><p>PM 权力几乎等于职能经理</p><p>优点：资源使用效率高</p><p>缺点：员工要听 2 个领导<br>pm 和职能经理共同掌握预算，pm 兼职。平衡矩阵可以叫项目经理了，弱矩阵和职能型里叫项目协调员或项目联络员。<br>缺省组织架构：如果 pmp 考试中，题目没有特别声明是什么组织类型，就默认是平衡矩阵。</p><h3 id="5-4-强矩阵组织"><a href="#5-4-强矩阵组织" class="headerlink" title="5.4 强矩阵组织"></a>5.4 强矩阵组织</h3><p><img src="http://upload-images.jianshu.io/upload_images/7326374-2f5b6306ee43eff1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="强矩阵组织" title="强矩阵组织"></p><p>pm 拥有中到高的权力。强矩阵型组织中，PM 和项目管理行政人员都是全职，并且拥有全权管理项目预算的权力。这是强矩阵组织和职能型、弱矩阵、平衡矩阵最大的不同。</p><p>PM 的汇报上级不再是职能经理，而是项目经理的经理。</p><p>矩阵式组织：<br>优点：兼顾项目与职能工作，资源使用率更高，比职能型组织部门间沟通更好<br>缺点：一个员工有 2 个汇报对象（pm 和职能经理），沟通复杂。</p><h3 id="5-5-项目型组织"><a href="#5-5-项目型组织" class="headerlink" title="5.5 项目型组织"></a>5.5 项目型组织</h3><p><img src="http://upload-images.jianshu.io/upload_images/7326374-01eeeb6250e3f2bf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目型组织" title="项目型组织"></p><p>Pm 拥有高到几乎全部的职权，对预算完全掌握，pm 和项目管理行政人员都是全职。<br>优点：pm 权力充分，团队职责清晰，沟通容易，对项目的反应速度非常快。<br>缺点：员工缺乏归属感、缺乏事业的连续性和保障，资源配置重复使用效率低。</p><p>三大类组织结构总结如下：</p><p>1）职能型：适合专业技能单一、在部门内开展简单项目活动；<br>2）矩阵型：适合跨部门、跨专业的项目，提高资源的使用效率；<br>3）项目型：适合项目难度高、风险大，需要团队全身心投入，pm 最大限度的掌握项目资源。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-291660ad31b1f9f4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三大类组织结构" title="三大类组织结构"></p><p>项目管理办公室（ Project Management Office ， PMO ）<br>1、定义：是对与项目相关的治理过程进行标准化，并促进资源、方法论、工具和技术共享的一个组织部门。<br>2、按照对项目控制权力的大小来分，支持型、控制型、指令型。PMO的职责范围可大可小，从提供项目管理支持服务，到直接管理一个或多个项目。<br> 1）支持型：担当顾问角色，为各位项目经理提供项目模板、最佳实践、培训、经验教训等资源支持，权力很小，打打酱油玩的 PMO。<br> 2）控制型：PMO 权力居中<br> 3）指令型：直接管理和控制项目，控制权力最大的是指令型。</p><p>3、PM 和 PMO 角色差异：<br>PM——Project Manager 项目经理<br>PMO——Project Management Office 项目管理办公室<br>1）项目经理关注特定的项目目标（单个项目），PMO 关注项目集（多个项目）范围的变更；<br>2）项目经理控制分配给本项目资源，PMO 优化利用所有项目所共享的组织资源；<br>3）项目经理管理单个项目的制约因素（范围、进度、成本、质量等），PMO 站在企业的高度对方法论、标准、整体风险/机会、测量指标和项目间的依赖关系进行管理。从以上总结的三点我们能感觉出来 PMO 是 PM 的上级领导。 </p><h2 id="6-练习题"><a href="#6-练习题" class="headerlink" title="6. 练习题"></a>6. 练习题</h2><p>一个项目经理刚接手一个新项目，该项目和他以前做过的一个项目类似。为了借鉴以前项目的经验，他应该先查看哪份文件？</p><p>A、项目章程<br>B、项目管理计划<br>C、历史信息<br>D、合同</p><p>参考答案：C。为了借鉴项目的经验，应该查看历史信息。历史信息属于组织过程资产，里面有以往项目的成功经验与失败教训。</p><p>发起人因费用超标要终止项目，关键干系人不同意，关键干系人认为项目不能仅仅用钱衡量。项目经理需要做一个经验教训总结报告，该文件属于以下哪一项？</p><p>A、组织过程资产<br>B、项目管理计划<br>C、风险管理计划<br>D、事业环境因素</p><p>参考答案：A。经验教训总结报告存档在组织过程资产中。</p><p>在实施一个新的 it 系统后，公司遭遇持续不满。项目经理应该做什么来改进未来类似项目的满意度？</p><p>A.建立一个通用的软件模块代码库<br>B.确保更新项目管理信息系统（pmis）数据并可用<br>C.安排一次与公司其他项目经理的会议<br>D.创建一个经验教训知识库</p><p>答案：D。要改进未来项目的满意度，需要参考过去的成功经验和失败的教训。组织过程资产的价值</p><p>某公司建立了一个项目管理办公室，用于协调和管理其众多项目。公司的 PMO 提出了一个具体的项目组织结构建议，并作为标准在全公司实施。该组织结构特点是设置了享有中高级权力（包括控制项目预算）的全职项目经理和全职管理人员。该 PMO 提出了何种组织结构？</p><p>A、 强矩阵<br>B、 弱矩阵<br>C、 项目型<br>D、 职能型</p><p>答案：A。中高级权力的 PM，管理人员是全职，这是强矩阵组织结构。</p><p>很小或没有职权的项目经理属于下列哪一种组织类型组成部分？</p><p>A、 弱矩阵<br>B、 职能型<br>C、 强矩阵<br>D、 平衡矩阵</p><p>答案：B。很小或没有权力的 PM 是职能型。</p><p>你在不同文化、不同部门间，负责一个项目，请问在什么组织类型中？</p><p>A、项目型<br>B、职能型<br>C、矩阵型<br>D、完全项目型</p><p>答案：C。矩阵型：适合跨部门、跨专业的项目，提高资源的使用效率；</p><blockquote><p>关注公众号，随时随地获取编程知识，面试题，PMP等相关资料<br><img src="http://upload-images.jianshu.io/upload_images/7326374-acf306463da9635e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/7326374-5036c26bc9329384.jpg?imageMogr2/auto-orient/strip" alt="求关注" title="求关注"></p>]]></content>
      
      
      <categories>
          
          <category> PMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP备考指南之第一章：引论</title>
      <link href="/2019/04/23/pmp/PMP02/"/>
      <url>/2019/04/23/pmp/PMP02/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7326374-bd3bfc390a2513e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PMP-引论.png"></p><blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎关注个人博客网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><blockquote><p>本文已同步至 <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">GitHub</a>/<a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">Gitee</a>/公众号，感兴趣的同学帮忙点波关注~</p></blockquote><h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章  引论"></a>第一章  引论</h1><p>1、“项目管理知识体系”：应该包含所有行业、应用领域项目管理的具体知识、技能、方法和实践。<br>2、我们发的这本巨厚的书叫“项目管理知识体系指南”简称“PMBOK 指南”，PMBOK 指南的目的：</p><ul><li>收录项目管理知识体系中被“普遍公认”的“良好做法”的那一部分。</li><li>形成的一个项目管理标准和框架，提供一套项目管理专业的通用词汇；适用于所有领域、行业的项目管理。</li><li>标准实践中可以加以选择和裁剪；</li><li>PMBOK 指南只讨论单个项目的管理</li><li>PMBOK 指南只讨论项目管理的共性</li><li>它是一套项目管理的指南，并不是具体的方法论。</li></ul><h2 id="1-什么是项目？"><a href="#1-什么是项目？" class="headerlink" title="1. 什么是项目？"></a>1. 什么是项目？</h2><p>项目是：为创造独特的产品、服务或成果而进行的临时性工作。</p><p><strong>pmbok 告诉我们项目有三大特性：<code>临时性</code>、<code>独特性</code>、<code>渐进明细</code></strong>。</p><p>1）项目的过程是临时的，但临时并不意味着时间短。比如：修建体育场鸟巢是个项目，这个项目用了好几年时间，这个时间很长。过程是临时的，指的是项目有明确的起点和终点，起点是立项的时候。终点是：</p><ul><li>目标达成（正常收尾）</li><li>不能达到目标项目终止（有可能是没钱了）</li><li>项目需求不复存在</li><li>客户或发起人希望终止等等</li></ul><p>2）结果的独特性：项目创造的可交付成果是独特的，所以导致项目的不确定性和风险。项目创造出来的结果，PMBOK 里叫做可交付成果。可交付成果：可以是有形的产品，也可以是无形的服务能力、知识。比如：咱们参加PMP 培训这是一个项目，参加考试后得到的 PMP 的培训证书这是有形的产品，所掌握的项目管理知识这是无形的。这些都是可交付成果。</p><p>3）渐进明细：项目的计划不可能一步到位，随着项目的进展信息越来越详细具体、估算越来越准确，而持续改进和细化计划。由于可能发生变化，应该在整个项目生命周期中，反复开展制定项目管理计划工作，对计划进行渐进明细。</p><h3 id="1-1-商业价值"><a href="#1-1-商业价值" class="headerlink" title="1.1 商业价值"></a>1.1 商业价值</h3><p>是指组织所从事业务的整体价值，包括全部的有形和无形价值。</p><p>1）有形价值包括：货币资产、固定设施、股东权益、物品器材等</p><p>2）无形价值包括：商誉、品牌认知度、公共利益、商标等</p><p>对持续运营的有效管理可以创造商业价值。<br>对项目的投资可以提升创造商业价值的能力。</p><h2 id="2-什么是项目管理？"><a href="#2-什么是项目管理？" class="headerlink" title="2. 什么是项目管理？"></a>2. 什么是项目管理？</h2><ol><li><p>项目管理是将知识、技能、工具与技术应用于项目活动，以满足项目的要求。项目管理通过合理运用和整合 49 个项目管理过程得以实现。</p></li><li><p>49个项目管理过程归类于五大过程组：启动、规划、执行、监控、收尾。项目可能各种各样，但是项目管理的过程和过程组是通用的。</p></li><li><p>项目管理需要满足并平衡相互制约的多重因素，比如：范围、质量、进度、预算、资源、风险。</p></li></ol><h3 id="2-1-项目集管理、项目组合管理："><a href="#2-1-项目集管理、项目组合管理：" class="headerlink" title="2.1 项目集管理、项目组合管理："></a>2.1 项目集管理、项目组合管理：</h3><ol><li><p>项目集：是一组相互关联且被协调管理的项目、子项目集和项目集活动。<br>项目集重点关注项目间的依赖关系，找到管理这些依赖关系的最佳方法。比如：参加英文培训+大学英语考试 CET 四六级、托福、雅思考试。这是一组项目集。互相有关联性都是英语培训考试、有依赖关系。</p></li><li><p>项目组合：是为了实现战略目标组合在一起管理的项目、项目集、子项目组合和运营工作。为实现战略目标或便于管理而组合在一起的项目，不一定彼此有依赖关系或直接相关，但可共享资源、供应商、技术等，关注资源的优先分配。比如：周杰伦自己的本行是歌手，应该唱歌开演唱会，但是现在还做一些与本行没有关系的事，开餐厅、卖古董、开健身房等等，这些事不一定直接相关，但它是关注资源（周杰伦的钱）的优先分配，到底钱先用来开餐厅还是开健身房？并且共享了周杰伦这位共同的雇主。</p></li><li><p>项目集、项目组合和项目之间的关系：项目组合中可以包含若干项目集或项目，项目集可以包含若干项目。</p></li></ol><h2 id="3-项目与战略规划"><a href="#3-项目与战略规划" class="headerlink" title="3. 项目与战略规划"></a>3. 项目与战略规划</h2><p>项目是组织实现战略目标的常用手段。这句话的意思是说做任何一个项目，都要和组织的战略目标保持一致，如果和战略目标不一致，这个项目也就没有存在的意义。</p><p>出于以下战略考虑来批准项目：</p><ul><li>市场需求</li><li>战略机会/业务需求</li><li>社会需要</li><li>环境考虑</li><li>客户要求</li><li>技术进步</li><li>法律要求</li></ul><h3 id="3-1-项目与运营"><a href="#3-1-项目与运营" class="headerlink" title="3.1 项目与运营"></a>3.1 项目与运营</h3><p>运营是支撑日常业务，实现业务战略和战术目标的手段。<br>运营的特性：持续性、重复性。<br>项目的特性：临时性、独特性。</p><p>运营的目标是为了维持经营，运营工作中会产生项目需求，某些运营无法实现的结果需要通过项目的方式实现；<br>项目的结果可能回到运营中去，变成日常工作内容。因此，项目经理在项目中需要充分考虑来自运营部门的干系人的需求。项目的目标是实现其目标，然后结束项目。</p><h3 id="3-2-项目生命周期"><a href="#3-2-项目生命周期" class="headerlink" title="3.2 项目生命周期"></a>3.2 项目生命周期</h3><p>1 、定义：项目生命周期是指从启动到收尾的一系列阶段，这些阶段通常按顺序排列，阶段通常有时间限制，每一个阶段都是一个子项目，有明确的起点和终点。</p><p>通用的项目生命周期结构：</p><ul><li>启动项目（概念阶段）</li><li>组织与准备（开发/规划阶段）</li><li>执行项目工作（实施阶段）</li><li>结束项目（收尾阶段）</li></ul><p>需要定义多少个阶段，和管理控制要求有关。如果希望管控的更严密些，则可以多定义一些阶段；反之则可以少一些。阶段，是从技术角度来划分的；过程组，从管理的角度来划分项目。既然每一个阶段都是一个子项目，那么就意味着每一个阶段都包括了五大过程组（启动、规划、执行、监控、收尾）。</p><p>​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​</p><h3 id="3-3-项目生命周期的特征：​"><a href="#3-3-项目生命周期的特征：​" class="headerlink" title="3.3 项目生命周期的特征：​"></a>3.3 项目生命周期的特征：​</h3><p>​​​​​​​​​​<br>​​​​​​​​​​​<img src="http://upload-images.jianshu.io/upload_images/7326374-8e0503841717e38e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命特征"></p><p>1）成本与人力投入开始时低，执行期间最高，项目收尾结束时迅速回落；</p><p>2）项目的风险与不确定性、干系人的影响力，开始最大，逐步减小；项目一开始风险是最大的，因为一开始一切都是未知，随着项目进行中，项目渐进明细，风险和不确定性慢慢减小。干系人影响力一开始最大，产品最初只有雏形干系人很轻易的可以改变它，随着项目进展产品逐步有了明确特性，干系人如果要改变它是很困难的，变更的代价非常高，因此干系人的影响力是减小的。</p><p>3）变更的代价，开始时最小，项目收尾时最大。因为随着项目的进行成本投入越来越多，变更付出的代价也会越来越大。</p><p>3 、阶段与阶段的关系：<br>1）阶段按顺序进行，一个阶段只能在前一阶段完成后开始，称为“顺序关系”。按部就班的特点减少了项目的不确定性，但也排除缩短项目总工期的可能性。</p><p>2）为缩短项目工期，一个阶段在前一个阶段完成前开始，称为“交叠关系”。这种做法可能需要额外的资源来并行开展工作，可能增加风险和返工的机会。阶段的结束，以阶段性可交付成果的移交为标志，阶段结束时间点可称为：里程碑、阶段关口、阶段审查、阶段门、关键决策点。</p><h3 id="3-4-五种类型的生命周期："><a href="#3-4-五种类型的生命周期：" class="headerlink" title="3.4 五种类型的生命周期："></a>3.4 五种类型的生命周期：</h3><p>1）预测型生命周期：也叫完全计划型，一个阶段一个阶段的按部就班执行，适用于对项目结果了解很充分的项目。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-1c715aa7c93b4c20?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="预测型生命周期"></p><p>先做需求分析，再做概要设计、详细设计、然后编码、测试、最后发布，按照计划去做，基本没有变更。</p><p>2）迭代型生命周期：通过一系列重复的循环活动、来不断优化产品功能。比如：磨刀，每一轮迭代都要把刀磨的更加锋利。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-7d8f9601b2710b6c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="迭代型生命周期"></p><p>3）增量型生命周期：在预定的时间内渐进地增加产品的功能。例如：开发多功能洗衣机，第一个阶段开发出一个功能（漂洗），第二个阶段开发出第二个功能（甩干），第三个阶段开发出第三个功能（烘干）。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-c4f4978d0555236c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增量型生命周期"></p><p>4）适应型生命周期（也叫变更驱动、敏捷方法）：迭代型和增量型的混合。最终目标和交付的成果也难以事先确定，管理过程也经常有变化,需要应对快速变化的环境。例如：秘书为领导写稿，秘书先根据领导的最初要求写出第一个版本的草稿（可交付成果）。领导看了以后提出意见（新的需求），秘书再根据意见写出第二个草稿（可交付成果），交给领导查看。如此多次迭代，直到写出让领导满意的稿子。相当于一边提需求，一边交付。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-79d6bf9b0d30ef04?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="适应型生命周期"></p><p>5）混合型生命周期：瀑布与敏捷的混合，充分了解或有确定需求的项目要素遵循预测型开发生命周期，而仍在发展中的要素遵循适应型开发生命周期。例如：硬件部分用预测型，软件部分用适应型。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-b7f52ff527499302?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="混合型生命周期"></p><h3 id="3-5-项目管理过程"><a href="#3-5-项目管理过程" class="headerlink" title="3.5 项目管理过程"></a>3.5 项目管理过程</h3><p>1、过程是为创建预定的产品、服务或成果而执行的一系列相互关联的行动和活动。过程将会是以后我们面对 PMP 讲义主要内容，组织过程资产和事业环境因素即使没有列出也需要参考。事业环境因素（EEFs）限制项目的灵活性，组织过程资产（OPAs）为裁剪过程提供指南和准则。</p><p>2、过程由输入、工具与技术、输出三部分构成</p><p>Input 输入<br>Tools &amp; Technique 工具与技术<br>Output 输出</p><p>输入、工具与技术、输出简称为 ITTO<br>I 输入，需要什么？<br>TT 用什么方法和手段？<br>O 输出，产生什么？</p><p>比如：制作红茶的过程；<br>输入：茶叶、水等；<br>工具与技术：发酵、加热、烹、煮；<br>输出：红茶。</p><p>3、PMI 把项目管理分为 49 个过程；那么这 49 个过程间是怎么样联系的呢？</p><p>一个过程的输出会成为另一个过程的输入。比如我们刚才讲的例子，制作红茶的过程。输出是：红茶。对于另一个过程“制作珍珠奶茶”，此时“红茶”又作为输入了。</p><p>输入：红茶、珍珠、水<br>工具与技术：混合搅拌、煮<br>输出：珍珠奶茶</p><p>这是制作珍珠奶茶的过程。</p><p><strong>49个项目管理过程被分在5大过程组中，启动、规划、执行、监控、收 尾。PMP学习重点将围绕这49个过程的ITTO展开。</strong></p><p>49  个项目管理过程被分在 5  大过程组中，启动、规划、执行、监控、收尾。PMP学习重点将围绕这 49  个过程的 ITTO  展开。</p><p>1 ）启动过程组：</p><p>定义一个新项目或一个新阶段；过程组目的：保证干系人期望与项目目的的一致性，让干系人明了项目范围和目标，明白他们在项目和阶段中的参与，实现他们的期望。</p><ul><li>启动过程组的两个过程：识别干系人、制定项目章程。</li><li>识别干系人：是要识别他们的参与度、期望、影响力以及对项目成功的影响。</li><li>制定项目章程：一般由项目经理编写，项目管理团队协助编写。由发起人、PMO 或项目组合治理委员会等公司高层领导来批准。一旦项目章程获得批准，项目也就得到了正式的授权。</li></ul><p>2 ）规划过程组</p><p>明确项目范围，为实现目标制定行动方案；<br>过程组目的：制定用于指导项目实施的项目管理计划和项目文件。<br>过程组作用：为成功完成项目或阶段确定战略、战术及行动方案及路线。随着收集和掌握的项目信息或特性不断增多，以及发生的重大变更，项目可能需要进一步规划。项目管理计划的逐渐细化叫“渐进明细”，表明项目规划和文档编制是反复进行的秩序性活动。在规划项目、制定项目管理计划和项目文件时，项目团队应当征求所有干系人的意见，鼓励所有干系人的参与。</p><p>3）执行过程组</p><p>完成项目管理计划中确定的工作，满足项目规范要求；过程组需要：按照项目管理计划来协调人员与资源，管理干系人期望，以及整合并实施项目活动。执行的结果可能引发计划更新和基准重建，执行的偏差可能影响项目管理计划或项目文件，需要加以仔细分析，并制定适当的管理应对措施。项目的大部分预算将花费在执行过程组中。</p><p>4）监控过程组</p><p>跟踪、审查和调整项目进展与绩效，启动有必要的变更；过程组作用：定期对项目绩效进行测量和分析，从而识别与项目管理计划的偏差。控制变更，推荐纠正措施、制定预防措施等等。</p><p>5）收尾过程组</p><p>完结所有过程组的活动，正式结束项目或阶段。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-28e58257dc3df938?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="收尾过程组"></p><p>逻辑上五个过程组是按顺序进行的，但实际上有交叉部分，监控过程组贯穿整个生命周期。阶段是从技术角度来分解项目；过程是从管理角度来分解项目。</p><h2 id="4-十五矩阵"><a href="#4-十五矩阵" class="headerlink" title="4. 十五矩阵"></a>4. 十五矩阵</h2><p>把 49 个项目管理过程归入十大项目管理知识领域和五大项目管理过程组。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-2ac7be298da4797c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="十五矩阵"></p><p>1、最左边，纵向按照十大知识领域：项目整合管理、项目范围管理、项目时间管理、项目成本管理、项目质量管理、项目资源管理、项目沟通管理、项目风险管理、项目采购管理、项目干系人管理；</p><p>在 pmbok 第六版当中第 13 章叫相关方管理，但是考虑到干系人这个词在项目管理界用了10 多年，我们依然认为 “ 干系人 ” 更加的专业，仍然把 13 章叫做干系人管理，特此声明</p><p>第四章 项目整合管理：协调子计划的接口管理；<br>第五章 项目范围管理：确定项目哪些工作该做、哪些不该做；<br>第六章 项目进度管理：确保项目工作按时完成；<br>第七章 项目成本管理：确保项目工作按照预算完成；<br>第八章 项目质量管理：确保项目工作到达要求；<br>第九章 项目资源管理：做好实物资源和项目团队的管理；<br>第十章 项目沟通管理：有团队就需要沟通，做好沟通管理；<br>第十一章 项目风险管理：项目有不确定的、有可能发生的事件，做好风险管理；<br>第十二章 项目采购管理：有些工作自己不能做需要外包，做好采购管理；<br>第十三章 项目干系人管理：项目是满足干系人的要求，做好干系人管理。</p><p>2、最上方，横向按照项目管理过程五大过程组：启动过程组、规划过程组、执行过程组、监控过程组、收尾过程组；右边，灰色和白色填充处一共 49 个过程，是以后学习 PMP 理论的重点内容；</p><p>3、第四章项目整合管理知识领域包含:4.1 制定项目章程、4.2 制定项目管理计划、4.3 指导与管理项目执行、4.4 管理项目知识、4.5 监控项目工作、4.6 实施整体变更控制、4.7 结束项目或阶段 7 个过程。</p><p>4.1 制定项目章程过程属于启动过程组<br>4.2 制定项目管理计划过程属于规划过程组<br>4.3 指导与管理项目执行过程、4.4 管理项目知识，两个过程属于执行过程组<br>4.5 监控项目工作、4.6 实施整体变更控制，两个过程属于监控过程组<br>4.7 结束项目或阶段过程属于收尾过程组</p><p>以此类推，一共有 49 个过程。<br>可以看出之所以叫十五矩阵，是因为“十”十大知识领域，“五”五大过程组。之后的章节我们将围绕49个过程和过程的输入、工具与技术、输出展开。49个过程必须熟悉，要知道他们分别属于哪个知识领域，他们分别属于哪个过程组</p><h2 id="5-练习题"><a href="#5-练习题" class="headerlink" title="5. 练习题"></a>5. 练习题</h2><p>公司里面有 A、B、C 三个项目。这些项目根据公司的目标，按照一套相同的标准化分优先顺序。项目 B 的优先级较高，因为它将会扩大公司的市场份额，减少对不可靠供应商的依赖性。这是在执行什么活动？</p><p>A、 项目组合管理<br>B、 项目集管理<br>C、 项目管理<br>D、 份额管理</p><p>答案：A。题干说：关注资源的优先分配、减少依赖性。这是关键词</p><p>某个技术重组项目的计划处于计划编制阶段已经数月，在此期间，这项技术已得到显著的进步。这项目预计在这个月开始，而且必须更新范围管理计划来反映技术上的变化。项目经理必须向关键干系人详细说明项目范围存在的可能变更。项目经理理解项目的不确定性水平将会处于下列哪一种情况？</p><p>A、保持在预计和计划水平<br>B、增加<br>C、开始是增加，然后减少<br>D、减少</p><p>答案：D。项目一开始风险最大，因为一开始一切都是未知，随着项目进行中，项目渐进明细，风险和不确定性慢慢减小。</p><p>以下哪项陈述最准确描述了项目？</p><p>A、项目范围变更的代价在项目的最初阶段最大<br>B、项目干系人的影响在整个项目期间是相同的<br>C、在项目执行阶段成本和人力投入量达到顶峰<br>D、项目的下一阶段永远不应该开始，直到前一个阶段的可交付成果被完全审查和批准</p><p>答案：C。 项目范围变更的代价在项目的最初阶段是最小的，排除 A。项目干系人的影响在整个项目期间开始时最大，之后递减。排除 B 阶段可能交叠进行，排除 D。</p><p>在一个快速变化环境中工作的项目经理，将收集到的需求清单排列优先顺序进行工作计划。让优先级最高的可交付成果 3 周内完成。项目经理正在使用哪一种项目生命周期方法？</p><p>A、适应<br>B、预测<br>C、直觉<br>D、反复</p><p>答案 A，题干关键字“快速变化环境中”工作的 PM，这是适应型敏捷开发。快速变化就不可能用预测型，排除 B。</p><p>下列哪项陈述反映了项目的风险程度？</p><p>A、 项目初始阶段的风险最小<br>B、 风险在整个项目期间保持恒定<br>C、 项目实施过程中风险最大<br>D、 项目初始阶段风险最大</p><p>答案：D。项目的风险与不确定性，开始最大，逐步减小；</p><p>下列哪项最好地描述了项目利害关系者介入项目规划时所造成的影响？</p><p>A、耗时,使得规划过程变慢<br>B、只对内部服务合同有帮助<br>C、通常有助于制订完整、准确的项目计划<br>D、不需要，因为项目利害关系者通常不想介入</p><p>答案：C。在规划项目、制定项目管理计划和项目文件时，项目团队应当征求所以干系人的意见，鼓励所有干系人的参与。</p><p>项目经理正在负责一个十分复杂的大型项目，与项目团队成员讨论后决定分阶段予以实施，并定下了第一个阶段为设计阶段。请问在设计阶段中应进行哪些项目管理过程组？</p><p>A、启动和规划过程组<br>B、规划和执行过程组<br>C、启动、规划、执行、监控、收尾过程组<br>D、启动、执行、收尾过程组</p><p>答案：C。每个阶段都是一个子项目，都应该进行五大过程组。阶段＝子项目</p><p>在项目的什么时间点，项目经理将会审查控制措施？</p><p>A、在计划编制阶段<br>B、在启动和执行阶段<br>C、在项目收尾阶段<br>D、在项目过程中持续审查</p><p>答案：D。监控过程组贯穿整个项目始终。</p><p>执行过程组的主要目标是什么？</p><p>A. 跟踪并审查项目进度<br>B. 管理利害关系者的期望<br>C. 满足项目规范<br>D．监控进度表</p><p>答案:C.执行过程组定义：完成项目管理计划中的工作，满足项目规范要求。</p><blockquote><p>关注公众号，随时随地获取编程知识，面试题，PMP等相关资料<br><img src="http://upload-images.jianshu.io/upload_images/7326374-acf306463da9635e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PMP备考指南之相关事项介绍</title>
      <link href="/2019/04/22/pmp/PMP01/"/>
      <url>/2019/04/22/pmp/PMP01/</url>
      
        <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/7326374-15a6057e82bcb5dd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PMP相关事项" title="PMP相关事项"></p><blockquote><p>每天进步一点，不做curd工程师与Api调用工程师<br>欢迎关注个人博客网站：<a href="https://www.coder-programming.cn/" target="_blank" rel="noopener">https://www.coder-programming.cn/</a></p></blockquote><blockquote><p>本文已同步至 <a href="https://github.com/CoderMerlin/coder-programming" target="_blank" rel="noopener">GitHub</a>/<a href="https://gitee.com/573059382/coder-programming" target="_blank" rel="noopener">Gitee</a>/公众号，感兴趣的同学帮忙点波关注~</p></blockquote><p>PMP是当今IT、通信、建筑、等高新技术行业的热门资格认证，无论是技术升级管理，还是管理者的能力提升，都离不开PMP的理论体系。今天就来介绍下PMP备考前的相关内容。</p><h2 id="PMP认证的报名条件"><a href="#PMP认证的报名条件" class="headerlink" title="PMP认证的报名条件"></a>PMP认证的报名条件</h2><p>1、申请者具有学士学位或同等的大学学历，并且须至少具有4500小时的项目管理相关经历。PMI要求申请者需至少3年以上，具有4500小时的项目管理经历(计算方法：不重叠累积)。仅在申请日之前6年之内的经历有效。</p><p>2、申请者虽不具备学士学位或同等大学学历，但持有中学文凭或同等中学学历证书， 并且至少具有7500小时的项目管理经历(计算方法：不重叠累积)。PMI要求申请者需至少5年以上，具有7500小时的项目管理经历。仅在申请日之前8年之内的经历有效。</p><p>3、具备PMI授权培训机构颁发的35PDU培训证书(必须由PMI或中国外专局授权的培训机构出具)。报考者可以在资格申请后的一年内，申请考试。</p><h2 id="PMP考试时间"><a href="#PMP考试时间" class="headerlink" title="PMP考试时间"></a>PMP考试时间</h2><p>PMP每年有4次的考试机会，分别是 3月30日、6月22日、9月7日、12月7日。<br>而PMP认证考试报名时间一般是在PMP考试前两个半月截止，建议大家提前做好时间计划!</p><h2 id="考试费用"><a href="#考试费用" class="headerlink" title="考试费用"></a>考试费用</h2><p>一、初考：2018年PMP认证考试初考需要交纳3900元人民币。（培训费另算）</p><p>二、重考：未通过PMP考试的考生，建议及时报名参加重考，因为考生只有一年的资格期来通过考试，在资格期内，有2-3次的考试机会。重考者需要交纳重考费。重考费为2500元人民币。（培训费另算）</p><p>注：缴费方式只能使用汇款/转账。</p><h2 id="PMP-考试介绍"><a href="#PMP-考试介绍" class="headerlink" title="PMP 考试介绍"></a>PMP 考试介绍</h2><ul><li><p>它是笔试，200 道选择题，都是单选题，四选一；</p></li><li><p>不做选择，算答错。选了多个，也算错；</p></li><li><p>中英文对照，对于中国考生看中文就可以了，但是有些题的翻译不咋样，所以当读到题 目有些别扭、或者觉得选项与题目都有点不符的时候，应该对照一下英文；</p></li><li><p>200 题里面有 25 题不计分，是 PMI 用来测试本次考试是否太难、或太容易、或者争议 非常大的题目。但是这 25 题并不知道是哪些，随机散乱的分布在试卷中。所以 200 题的 PMP 考试，131 及以上算是及格，我们清晖要求 140 以上。</p></li><li><p>答题时间：9：00～13：00，共计 4 个小时。</p></li></ul><h2 id="PMP-考试试题分布"><a href="#PMP-考试试题分布" class="headerlink" title="PMP 考试试题分布"></a>PMP 考试试题分布</h2><table><thead><tr><th>过程组</th><th>比例</th><th>题目数量</th></tr></thead><tbody><tr><td>启动过程组</td><td>13%</td><td>26 题</td></tr><tr><td>规划过程组</td><td>24%</td><td>48 题</td></tr><tr><td>执行过程组</td><td>30%</td><td>60 题</td></tr><tr><td>监控过程组</td><td>25%</td><td>50 题</td></tr><tr><td>收尾过程组</td><td>8%</td><td>16 题</td></tr></tbody></table><p>1、题目也是随机分布，不按过程组顺序。<br>2、从 2017 年 9 月份的考试开始，PMI 对 PMP 的成绩显示进行了调整，不再用之前的 P\M\B 三个等级来体现成绩，而是以：Needs Improvement（需要提高） \ Below Target（低 于目标） \ Targer（目标水平） \ Above Target（高于目标） 四个标准来分别体现五个过程 组的成绩状态。<br>考题类型：<br>1、直接考输入、工具、输出的题，这类题较少，5 题以内。<br>2、情景题：PM 在管理一个项目，前一个阶段如何„.后一个阶段„客户提出变更，问 PM 下 一步应该怎么办？<br>3、过程描述题：描述了某一处理过程，问这是应用的哪一项技术？项目团队采用的是哪一 种工具？项目经理使用的是哪种风险应对策略？<br>4、计算题：挣值管理、风险管理、三点估算、关键路径时差等等。<br>5、管理常识题：墨菲定律、彼得原理等<br>6、冷僻题：比如 KISS 法则：Keep It Simple and Stupid 简约并不简单。</p><h2 id="PMI-理念"><a href="#PMI-理念" class="headerlink" title="PMI 理念"></a>PMI 理念</h2><p>1 、项目经理是整合者，是在做整合管理。<br>项目经理对项目管理负责，“管理”是你的核心任务，项目经理并不需要亲自去做所有 事情，比如：并不需要亲自写代码、并不需要负责所有风险、并不需要解决所有问题，PMI 讲究团队合作。</p><p>2 、项目经理必须被授权。<br>就像我们做项目首先需要立项，获得项目批准书。没有被授权的项目经理就像没有拿到 “圣旨”，就没有权力调动或使用资源。各个公司可能叫法不同，有的叫立项报告。但是 PMI 统一把项目批准书称为“项目章程”。项目章程的批准就意味着项目经理被授权了。</p><p>3 、项目经理要积极主动，鼓励干系人的参与。<br>项目经理不能简单地服从领导安排，也不能消极拖延工作。</p><p>4 、拒绝镀金，拒绝多此一举。<br>镀金：是项目人员为了“讨好”客户而“画蛇添足”做的项目活动。PMI 觉得镀金的 项目是失败的，反对镀金。比如客户要 PM 去买包烟，PM 买了烟后又私自决定给客户配了 个打火机。这就是镀金了，客户并不需要打火机，也许客户自己有更高级的“ZIPPO”。镀金，是画蛇添足、因为浪费了资源。镀金，PMI 是明令禁止。</p><p>5 、项目团队必须得到尊重、重视、并且要及时沟通，反对免费加班。</p><p>6 、做项目时有两个因素必须考虑：组织过程资产、事业环境因素。<br>组织过程资产：比如，项目做完了，收尾时候把成功经验和失败教训记录在组织过程资 产中，下一个项目启动时要参考组织过程资产。组织过程资产当中，不仅仅包括经验教训， 还有其他，我们后续章节会陆续介绍。事业环境因素：是项目团队无法改变的，比如：公司文化、公司的制度、政治氛围等。</p><h2 id="答题技巧"><a href="#答题技巧" class="headerlink" title="答题技巧"></a>答题技巧</h2><p>1、一定要看清四个选项后，选择一个相对正确的答案。有时候四个选项都没有原则性的错 误，但是要选一个“最”对的.</p><p>2、PMP 考试答题不能完全按照自己的实际工作凭经验判断，美国人的思路跟我们有些差异, 答题要从 PMI 理念的角度出发。</p><p>比如：实际工作中为了提高客户满意度，会赠送一些增值功能，而这些功能在原本约定的范 围中没有的，这就是镀金。但是 PMI 的态度是非常坚决的，反对镀金。</p><p>3、注意区分多余和误导信息，注意题目中问什么，有些题目问：以上都是正确的，除了？</p><p>4、项目经理直接拒绝、和直接服从的肯定要排除，绝对不是答案。项目经理要积极主动。</p><p>5、对于项目团队的管理，要注意人性化管理，如团队成员疲劳，应支持休息，反对加班， 一般来说牺牲团队个人休息、休假、离职等请求的选项都不正确。</p><p>6、一般不选 PMBOK 中没有出现过的陌生词汇，这样太不专业了；</p><p>比如：在月项目状态会上，客户抱怨缺乏与项目进展有关的信息。项目经理应参考下列哪一 份文件？<br>A、进度进展报告<br>B、进度管理计划<br>C、沟通管理计划<br>D、工作绩效报告</p><p>题干说“客户抱怨缺乏与项目进展有关的信息”，凭经验判断答案选 A 进度进展报告。但是 PMBOK 并没有“进度进展报告”这个说法，一定不能选 A，选 A 太不专业了，A 就 是用来打酱油的。<br>正确答案 C ，缺乏信息是因为没有沟通导致的。</p><h2 id="学习方法与建议"><a href="#学习方法与建议" class="headerlink" title="学习方法与建议"></a>学习方法与建议</h2><p>距离考试有接近三个月时间。</p><p>1 、 学习时间<br>模拟考试前：每天 1<del>2 小时复习，模拟考试后：每天 3</del>4 小时。绝大多数考试不过的 原因，是学习时间不够。所以请大家务必坚持每天学习。</p><p>2 、学习方式<br>模拟考试前：看讲义、看 PMBOK、做单元测试题；模拟考试后：看讲义、看 PMBOK、模拟考试题、单元测试。注：输入、工具、输出简称 ITTO。</p><p>3 、学习技巧<br>（1）温故而知新，不仅要多看错题，做完一套题，对的也要重看一遍。因为难免有些题是我们蒙对的，虽然选对了，但是我们并不知道具体原理，为了保证下一次不需要蒙，我们也都要看一遍，保证做过的每一道题，我们都清楚的知道其中的原理，或者同类型的选择方式。<br>（2）要善于总结，对于自己的错题和易混淆题，应该善于对比、总结，自己记录其中的规律。<br>（3）要善于利用碎片化时间进行学习。大家白天上班很忙，晚上也没整块的时间学习，那么就要善于利用上<br>班路上、下班回家路上、中午休息或者晚上睡前的时间多多学习。</p><p><img src="http://upload-images.jianshu.io/upload_images/7326374-acf306463da9635e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号"></p>]]></content>
      
      
      <categories>
          
          <category> PMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PMP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
